{"version":3,"file":"ink-full.js","sources":["../src/compiler/Parser/ErrorType.ts","../src/compiler/CompilerOptions.ts","../src/compiler/DebugSourceRange.ts","../src/compiler/Parser/ParsedHierarchy/Argument.ts","../src/engine/TypeAssertion.ts","../src/engine/Debug.ts","../src/compiler/Parser/ParsedHierarchy/Object.ts","../src/compiler/Parser/ParsedHierarchy/AuthorWarning.ts","../src/engine/Path.ts","../src/engine/NullException.ts","../src/engine/Object.ts","../src/engine/StringBuilder.ts","../src/engine/InkList.ts","../src/engine/StoryException.ts","../src/engine/TryGetResult.ts","../src/engine/Value.ts","../src/engine/SearchResult.ts","../src/engine/Container.ts","../src/engine/ControlCommand.ts","../src/compiler/Parser/ParsedHierarchy/Expression/Expression.ts","../src/engine/Void.ts","../src/engine/NativeFunctionCall.ts","../src/compiler/Parser/ParsedHierarchy/Expression/NumberExpression.ts","../src/compiler/Parser/ParsedHierarchy/Expression/UnaryExpression.ts","../src/compiler/Parser/ParsedHierarchy/Expression/BinaryExpression.ts","../src/compiler/Parser/CharacterSet.ts","../src/compiler/Parser/CharacterRange.ts","../src/engine/PushPop.ts","../src/engine/ChoicePoint.ts","../src/compiler/Parser/ParsedHierarchy/SymbolType.ts","../src/engine/Pointer.ts","../src/engine/Divert.ts","../src/engine/VariableAssignment.ts","../src/compiler/Parser/ParsedHierarchy/Choice.ts","../src/compiler/Parser/StringParser/StringParserElement.ts","../src/compiler/Parser/StringParser/StringParserState.ts","../src/compiler/Parser/StringParser/StringParser.ts","../src/compiler/Parser/ParsedHierarchy/Flow/FlowLevel.ts","../src/compiler/Parser/CommentEliminator.ts","../src/compiler/Parser/ParsedHierarchy/Conditional/Conditional.ts","../src/compiler/Parser/ParsedHierarchy/Text.ts","../src/compiler/Parser/ParsedHierarchy/Declaration/ConstantDeclaration.ts","../src/compiler/Parser/ParsedHierarchy/Gather/Gather.ts","../src/compiler/Parser/ParsedHierarchy/Path.ts","../src/compiler/Parser/ParsedHierarchy/ReturnType.ts","../src/compiler/Parser/ParsedHierarchy/Flow/ClosestFlowBase.ts","../src/compiler/Parser/ParsedHierarchy/Identifier.ts","../src/compiler/Parser/ParsedHierarchy/Flow/FlowBase.ts","../src/compiler/Parser/ParsedHierarchy/ContentList.ts","../src/engine/VariableReference.ts","../src/compiler/Parser/ParsedHierarchy/Variable/VariableReference.ts","../src/compiler/Parser/ParsedHierarchy/FunctionCall.ts","../src/compiler/Parser/ParsedHierarchy/Sequence/SequenceType.ts","../src/compiler/Parser/ParsedHierarchy/Expression/MultipleConditionExpression.ts","../src/compiler/Parser/ParsedHierarchy/Divert/DivertTarget.ts","../src/compiler/Parser/ParsedHierarchy/Divert/Divert.ts","../src/compiler/Parser/ParsedHierarchy/Gather/GatherPointToResolve.ts","../src/compiler/Parser/ParsedHierarchy/Sequence/SequenceDivertToResolve.ts","../src/compiler/Parser/CustomFlags.ts","../src/compiler/Parser/ParsedHierarchy/Sequence/Sequence.ts","../src/compiler/Parser/ParsedHierarchy/TunnelOnwards.ts","../src/engine/ListDefinition.ts","../src/compiler/Parser/ParsedHierarchy/List/ListDefinition.ts","../src/compiler/Parser/ParsedHierarchy/Variable/VariableAssignment.ts","../src/compiler/Parser/ParsedHierarchy/Weave.ts","../src/compiler/Parser/ParsedHierarchy/Conditional/ConditionalSingleBranch.ts","../src/compiler/Parser/StatementLevel.ts","../src/engine/DebugMetadata.ts","../src/compiler/Parser/ParsedHierarchy/Declaration/ExternalDeclaration.ts","../src/compiler/Parser/FlowDecl.ts","../src/compiler/Parser/ParsedHierarchy/Wrap.ts","../src/compiler/Parser/ParsedHierarchy/Glue.ts","../src/engine/Glue.ts","../src/compiler/Parser/ParsedHierarchy/Expression/IncDecExpression.ts","../src/compiler/Parser/ParsedHierarchy/IncludedFile.ts","../src/compiler/Parser/InfixOperator.ts","../src/compiler/Parser/ParsedHierarchy/Knot.ts","../src/compiler/Parser/ParsedHierarchy/List/List.ts","../src/compiler/Parser/ParsedHierarchy/List/ListElementDefinition.ts","../src/compiler/Parser/ParsedHierarchy/Stitch.ts","../src/engine/Tag.ts","../src/engine/Choice.ts","../src/engine/ListDefinitionsOrigin.ts","../src/engine/JsonSerialisation.ts","../src/engine/CallStack.ts","../src/engine/VariablesState.ts","../src/engine/PRNG.ts","../src/engine/StatePatch.ts","../src/engine/SimpleJson.ts","../src/engine/Error.ts","../src/engine/Flow.ts","../src/engine/StoryState.ts","../src/engine/StopWatch.ts","../src/engine/Story.ts","../src/compiler/Parser/ParsedHierarchy/Story.ts","../src/compiler/Parser/InkParser.ts","../src/compiler/Parser/ParsedHierarchy/Expression/StringExpression.ts","../src/compiler/Parser/ParsedHierarchy/Tag.ts","../src/compiler/Compiler.ts"],"sourcesContent":["export enum ErrorType {\n  Author,\n  Error,\n  Warning,\n}\n","import { ErrorHandler } from \"../engine/Error\";\nimport { IFileHandler } from \"./IFileHandler\";\n\nexport class CompilerOptions {\n  constructor(\n    public readonly sourceFilename: string | null = null,\n    public readonly pluginNames: string[] = [],\n    public readonly countAllVisits: boolean = false,\n    public readonly errorHandler: ErrorHandler | null = null,\n    public readonly fileHandler: IFileHandler | null = null\n  ) {}\n}\n","import { DebugMetadata } from \"../engine/DebugMetadata\";\n\nexport class DebugSourceRange {\n  constructor(\n    public readonly length: number,\n    public readonly debugMetadata: DebugMetadata | null,\n    public text: string\n  ) {}\n}\n","import { Identifier } from \"./Identifier\";\n\nexport class Argument {\n  constructor(\n    public identifier: Identifier | null = null,\n    public isByReference: boolean | null = null,\n    public isDivertTarget: boolean | null = null\n  ) {}\n}\n","import { INamedContent } from \"./INamedContent\";\n\nexport function asOrNull<T>(\n  obj: any,\n  type: (new (...arg: any[]) => T) | (Function & { prototype: T })\n): T | null {\n  if (obj instanceof type) {\n    return unsafeTypeAssertion(obj, type);\n  } else {\n    return null;\n  }\n}\n\nexport function asOrThrows<T>(\n  obj: any,\n  type: (new (...arg: any[]) => T) | (Function & { prototype: T })\n): T | never {\n  if (obj instanceof type) {\n    return unsafeTypeAssertion(obj, type);\n  } else {\n    throw new Error(`${obj} is not of type ${type}`);\n  }\n}\n\nexport function asNumberOrThrows(obj: any) {\n  if (typeof obj === \"number\") {\n    return obj as number;\n  } else {\n    throw new Error(`${obj} is not a number`);\n  }\n}\n\nexport function asBooleanOrThrows(obj: any) {\n  if (typeof obj === \"boolean\") {\n    return obj as boolean;\n  } else {\n    throw new Error(`${obj} is not a boolean`);\n  }\n}\n\n// So here, in the reference implementation, contentObj is casted to an INamedContent\n// but here we use js-style duck typing: if it implements the same props as the interface,\n// we treat it as valid.\nexport function asINamedContentOrNull(obj: any): INamedContent | null {\n  if (obj.hasValidName && obj.name) {\n    return obj as INamedContent;\n  }\n\n  return null;\n}\n\nexport function nullIfUndefined<T>(obj: T | undefined): T | null {\n  if (typeof obj === \"undefined\") {\n    return null;\n  }\n\n  return obj;\n}\n\nexport function isEquatable(type: any) {\n  return typeof type === \"object\" && typeof type.Equals === \"function\";\n}\n\nfunction unsafeTypeAssertion<T>(\n  obj: any,\n  type: (new () => T) | (Function & { prototype: T })\n) {\n  return obj as T;\n}\n\nexport function filterUndef<T>(element: T | undefined): element is T {\n  return element != undefined;\n}\n","export namespace Debug {\n  export function AssertType<T>(\n    variable: any,\n    type: new () => T,\n    message: string\n  ): void | never {\n    Assert(variable instanceof type, message);\n  }\n\n  export function Assert(condition: boolean, message?: string): void | never {\n    if (!condition) {\n      if (typeof message !== \"undefined\") {\n        console.warn(message);\n      }\n\n      if (console.trace) {\n        console.trace();\n      }\n\n      throw new Error(\"\");\n    }\n  }\n}\n","import { Container as RuntimeContainer } from \"../../../engine/Container\";\nimport { DebugMetadata } from \"../../../engine/DebugMetadata\";\nimport { FindQueryFunc } from \"./FindQueryFunc\";\nimport { InkObject as RuntimeObject } from \"../../../engine/Object\";\nimport { Path as RuntimePath } from \"../../../engine/Path\";\nimport { Story } from \"./Story\";\nimport { asOrNull } from \"../../../engine/TypeAssertion\";\n\nexport abstract class ParsedObject {\n  public abstract readonly GenerateRuntimeObject: () => RuntimeObject | null;\n\n  private _alreadyHadError: boolean = false;\n  private _alreadyHadWarning: boolean = false;\n  private _debugMetadata: DebugMetadata | null = null;\n  private _runtimeObject: RuntimeObject | null = null;\n\n  public content: ParsedObject[] = [];\n  public parent: ParsedObject | null = null;\n\n  get debugMetadata() {\n    if (this._debugMetadata === null && this.parent) {\n      return this.parent.debugMetadata;\n    }\n\n    return this._debugMetadata;\n  }\n\n  set debugMetadata(value: DebugMetadata | null) {\n    this._debugMetadata = value;\n  }\n\n  get hasOwnDebugMetadata(): boolean {\n    return Boolean(this.debugMetadata);\n  }\n\n  get typeName(): string {\n    return \"ParsedObject\";\n  }\n\n  public readonly GetType = (): string => this.typeName;\n\n  get story(): Story {\n    let ancestor: ParsedObject = this;\n    while (ancestor.parent) {\n      ancestor = ancestor.parent;\n    }\n\n    return ancestor as Story;\n  }\n\n  get runtimeObject(): RuntimeObject {\n    if (!this._runtimeObject) {\n      this._runtimeObject = this.GenerateRuntimeObject();\n      if (this._runtimeObject) {\n        this._runtimeObject.debugMetadata = this.debugMetadata;\n      }\n    }\n\n    return this._runtimeObject as RuntimeObject;\n  }\n\n  set runtimeObject(value: RuntimeObject) {\n    this._runtimeObject = value;\n  }\n\n  get runtimePath(): RuntimePath {\n    if (!this.runtimeObject.path) {\n      throw new Error();\n    }\n\n    return this.runtimeObject.path;\n  }\n\n  // When counting visits and turns since, different object\n  // types may have different containers that needs to be counted.\n  // For most it'll just be the object's main runtime object,\n  // but for e.g. choices, it'll be the target container.\n  get containerForCounting(): RuntimeContainer | null {\n    return this.runtimeObject as RuntimeContainer;\n  }\n\n  get ancestry(): ParsedObject[] {\n    let result = [];\n\n    let ancestor = this.parent;\n    while (ancestor) {\n      result.push(ancestor);\n      ancestor = ancestor.parent;\n    }\n\n    result = result.reverse();\n\n    return result;\n  }\n\n  /*\n  get descriptionOfScope(): string {\n    const locationNames: string[] = [];\n\n    let ancestor: ParsedObject | null = this;\n    while (ancestor) {\n      var ancestorFlow = ancestor as FlowBase;\n      if (ancestorFlow && ancestorFlow.name != null) {\n        locationNames.push(`'${ancestorFlow.name}'`);\n      }\n      ancestor = ancestor.parent;\n    }\n\n    let scopeSB = '';\n    if (locationNames.length > 0) {\n      const locationsListStr = locationNames.join(', ');\n      scopeSB += `${locationsListStr} and`;\n    }\n\n    scopeSB += 'at top scope';\n\n    return scopeSB;\n  }\n*/\n\n  // Return the object so that method can be chained easily\n  public readonly AddContent = <T extends ParsedObject, V extends T | T[]>(\n    subContent: V\n  ) => {\n    if (this.content === null) {\n      this.content = [];\n    }\n\n    const sub = Array.isArray(subContent) ? subContent : [subContent];\n\n    // Make resilient to content not existing, which can happen\n    // in the case of parse errors where we've already reported\n    // an error but still want a valid structure so we can\n    // carry on parsing.\n    for (const ss of sub) {\n      if (ss.hasOwnProperty(\"parent\")) {\n        ss.parent = this;\n      }\n      this.content.push(ss);\n    }\n\n    if (Array.isArray(subContent)) {\n      return;\n    } else {\n      return subContent;\n    }\n  };\n\n  public readonly InsertContent = <T extends ParsedObject>(\n    index: number,\n    subContent: T\n  ): T => {\n    if (this.content === null) {\n      this.content = [];\n    }\n\n    subContent.parent = this;\n    this.content.splice(index, 0, subContent);\n\n    return subContent;\n  };\n\n  public readonly Find = <T extends ParsedObject>(\n    type: (new (...arg: any[]) => T) | (Function & { prototype: T })\n  ) => (queryFunc: FindQueryFunc<T> | null = null): T | null => {\n    let tObj = (asOrNull(this, type) as any) as T;\n    if (tObj !== null && (queryFunc === null || queryFunc(tObj) === true)) {\n      return tObj;\n    }\n\n    if (this.content === null) {\n      return null;\n    }\n\n    for (const obj of this.content) {\n      let nestedResult = obj.Find && obj.Find(type)(queryFunc);\n      if (nestedResult) {\n        return nestedResult as T;\n      }\n    }\n\n    return null;\n  };\n\n  public readonly FindAll = <T extends ParsedObject>(\n    type: (new (...arg: any[]) => T) | (Function & { prototype: T })\n  ) => (queryFunc?: FindQueryFunc<T>, foundSoFar?: T[]): T[] => {\n    const found = Array.isArray(foundSoFar) ? foundSoFar : [];\n\n    const tObj = asOrNull(this, type);\n    if (tObj !== null && (!queryFunc || queryFunc(tObj) === true)) {\n      found.push(tObj);\n    }\n\n    if (this.content === null) {\n      return [];\n    }\n\n    for (const obj of this.content) {\n      obj.FindAll && obj.FindAll(type)(queryFunc, found);\n    }\n\n    return found;\n  };\n\n  public ResolveReferences(context: Story) {\n    if (this.content !== null) {\n      for (const obj of this.content) {\n        obj.ResolveReferences(context);\n      }\n    }\n  }\n\n  public Error(\n    message: string,\n    source: ParsedObject | null = null,\n    isWarning: boolean = false\n  ): void {\n    if (source === null) {\n      source = this;\n    }\n\n    // Only allow a single parsed object to have a single error *directly* associated with it\n    if (\n      (source._alreadyHadError && !isWarning) ||\n      (source._alreadyHadWarning && isWarning)\n    ) {\n      return;\n    }\n\n    if (this.parent) {\n      this.parent.Error(message, source, isWarning);\n    } else {\n      throw new Error(`No parent object to send error to: ${message}`);\n    }\n\n    if (isWarning) {\n      source._alreadyHadWarning = true;\n    } else {\n      source._alreadyHadError = true;\n    }\n  }\n\n  public readonly Warning = (\n    message: string,\n    source: ParsedObject | null = null\n  ): void => {\n    this.Error(message, source, true);\n  };\n}\n","﻿import { ParsedObject } from \"./Object\";\n\nexport class AuthorWarning extends ParsedObject {\n  constructor(public readonly warningMessage: string) {\n    super();\n  }\n\n  public readonly GenerateRuntimeObject = (): null => {\n    this.Warning(this.warningMessage);\n    return null;\n  };\n}\n","export class Path {\n  public static parentId = \"^\";\n\n  public _isRelative: boolean;\n  public _components: Path.Component[];\n  public _componentsString: string | null;\n\n  constructor();\n  constructor(componentsString: string);\n  constructor(head: Path.Component, tail: Path);\n  constructor(head: Path.Component[], relative?: boolean);\n  constructor() {\n    this._components = [];\n    this._componentsString = null;\n    this._isRelative = false;\n\n    if (typeof arguments[0] == \"string\") {\n      let componentsString = arguments[0] as string;\n      this.componentsString = componentsString;\n    } else if (\n      arguments[0] instanceof Path.Component &&\n      arguments[1] instanceof Path\n    ) {\n      let head = arguments[0] as Path.Component;\n      let tail = arguments[1] as Path;\n      this._components.push(head);\n      this._components = this._components.concat(tail._components);\n    } else if (arguments[0] instanceof Array) {\n      let head = arguments[0] as Path.Component[];\n      let relative = !!arguments[1] as boolean;\n      this._components = this._components.concat(head);\n      this._isRelative = relative;\n    }\n  }\n  get isRelative() {\n    return this._isRelative;\n  }\n  get componentCount(): number {\n    return this._components.length;\n  }\n  get head(): Path.Component | null {\n    if (this._components.length > 0) {\n      return this._components[0];\n    } else {\n      return null;\n    }\n  }\n  get tail(): Path {\n    if (this._components.length >= 2) {\n      // careful, the original code uses length-1 here. This is because the second argument of\n      // List.GetRange is a number of elements to extract, wherease Array.slice uses an index\n      let tailComps = this._components.slice(1, this._components.length);\n      return new Path(tailComps);\n    } else {\n      return Path.self;\n    }\n  }\n  get length(): number {\n    return this._components.length;\n  }\n  get lastComponent(): Path.Component | null {\n    let lastComponentIdx = this._components.length - 1;\n    if (lastComponentIdx >= 0) {\n      return this._components[lastComponentIdx];\n    } else {\n      return null;\n    }\n  }\n  get containsNamedComponent(): boolean {\n    for (let i = 0, l = this._components.length; i < l; i++) {\n      if (!this._components[i].isIndex) {\n        return true;\n      }\n    }\n    return false;\n  }\n  static get self(): Path {\n    let path = new Path();\n    path._isRelative = true;\n    return path;\n  }\n\n  public GetComponent(index: number): Path.Component {\n    return this._components[index];\n  }\n  public PathByAppendingPath(pathToAppend: Path): Path {\n    let p = new Path();\n\n    let upwardMoves = 0;\n    for (let i = 0; i < pathToAppend._components.length; ++i) {\n      if (pathToAppend._components[i].isParent) {\n        upwardMoves++;\n      } else {\n        break;\n      }\n    }\n\n    for (let i = 0; i < this._components.length - upwardMoves; ++i) {\n      p._components.push(this._components[i]);\n    }\n\n    for (let i = upwardMoves; i < pathToAppend._components.length; ++i) {\n      p._components.push(pathToAppend._components[i]);\n    }\n\n    return p;\n  }\n  get componentsString(): string {\n    if (this._componentsString == null) {\n      this._componentsString = this._components.join(\".\");\n      if (this.isRelative)\n        this._componentsString = \".\" + this._componentsString;\n    }\n\n    return this._componentsString;\n  }\n  set componentsString(value: string) {\n    this._components.length = 0;\n\n    this._componentsString = value;\n\n    if (this._componentsString == null || this._componentsString == \"\") return;\n\n    if (this._componentsString[0] == \".\") {\n      this._isRelative = true;\n      this._componentsString = this._componentsString.substring(1);\n    }\n\n    let componentStrings = this._componentsString.split(\".\");\n    for (let str of componentStrings) {\n      // we need to distinguish between named components that start with a number, eg \"42somewhere\", and indexed components\n      // the normal parseInt won't do for the detection because it's too relaxed.\n      // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt\n      if (/^(\\-|\\+)?([0-9]+|Infinity)$/.test(str)) {\n        this._components.push(new Path.Component(parseInt(str)));\n      } else {\n        this._components.push(new Path.Component(str));\n      }\n    }\n  }\n  public toString(): string {\n    return this.componentsString;\n  }\n  public Equals(otherPath: Path | null): boolean {\n    if (otherPath == null) return false;\n\n    if (otherPath._components.length != this._components.length) return false;\n\n    if (otherPath.isRelative != this.isRelative) return false;\n\n    // the original code uses SequenceEqual here, so we need to iterate over the components manually.\n    for (let i = 0, l = otherPath._components.length; i < l; i++) {\n      // it's not quite clear whether this test should use Equals or a simple == operator,\n      // see https://github.com/y-lohse/inkjs/issues/22\n      if (!otherPath._components[i].Equals(this._components[i])) return false;\n    }\n\n    return true;\n  }\n  public PathByAppendingComponent(c: Path.Component): Path {\n    let p = new Path();\n    p._components.push(...this._components);\n    p._components.push(c);\n    return p;\n  }\n}\n\nexport namespace Path {\n  export class Component {\n    public readonly index: number;\n    public readonly name: string | null;\n\n    constructor(indexOrName: string | number) {\n      this.index = -1;\n      this.name = null;\n      if (typeof indexOrName == \"string\") {\n        this.name = indexOrName;\n      } else {\n        this.index = indexOrName;\n      }\n    }\n    get isIndex(): boolean {\n      return this.index >= 0;\n    }\n    get isParent(): boolean {\n      return this.name == Path.parentId;\n    }\n\n    public static ToParent(): Component {\n      return new Component(Path.parentId);\n    }\n    public toString(): string | null {\n      if (this.isIndex) {\n        return this.index.toString();\n      } else {\n        return this.name;\n      }\n    }\n    public Equals(otherComp: Component): boolean {\n      if (otherComp != null && otherComp.isIndex == this.isIndex) {\n        if (this.isIndex) {\n          return this.index == otherComp.index;\n        } else {\n          return this.name == otherComp.name;\n        }\n      }\n\n      return false;\n    }\n  }\n}\n","/**\n * In the original C# code, a SystemException would be thrown when passing\n * null to methods expected a valid instance. Javascript has no such\n * concept, but TypeScript will not allow `null` to be passed to methods\n * explicitely requiring a valid type.\n *\n * Whenever TypeScript complain about the possibility of a `null` value,\n * check the offending value and it it's null, throw this exception using\n * `throwNullException(name: string)`.\n */\nexport class NullException extends Error {}\n\n/**\n * Throw a NullException.\n *\n * @param name a short description of the offending value (often its name within the code).\n */\nexport function throwNullException(name: string): never {\n  throw new NullException(`${name} is null or undefined`);\n}\n","import { Path } from \"./Path\";\nimport { Container } from \"./Container\";\nimport { Debug } from \"./Debug\";\nimport { asOrNull, asINamedContentOrNull } from \"./TypeAssertion\";\nimport { throwNullException } from \"./NullException\";\nimport { SearchResult } from \"./SearchResult\";\nimport { DebugMetadata } from \"./DebugMetadata\";\n\nexport class InkObject {\n  public parent: InkObject | null = null;\n\n  get debugMetadata(): DebugMetadata | null {\n    if (this._debugMetadata === null) {\n      if (this.parent) {\n        return this.parent.debugMetadata;\n      }\n    }\n\n    return this._debugMetadata;\n  }\n\n  set debugMetadata(value) {\n    this._debugMetadata = value;\n  }\n\n  get ownDebugMetadata() {\n    return this._debugMetadata;\n  }\n\n  private _debugMetadata: DebugMetadata | null = null;\n\n  public DebugLineNumberOfPath(path: Path) {\n    if (path === null) return null;\n\n    // Try to get a line number from debug metadata\n    let root = this.rootContentContainer;\n    if (root) {\n      let targetContent = root.ContentAtPath(path).obj;\n      if (targetContent) {\n        let dm = targetContent.debugMetadata;\n        if (dm !== null) {\n          return dm.startLineNumber;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  get path() {\n    if (this._path == null) {\n      if (this.parent == null) {\n        this._path = new Path();\n      } else {\n        let comps: Path.Component[] = [];\n\n        let child: InkObject = this;\n        let container = asOrNull(child.parent, Container);\n\n        while (container !== null) {\n          let namedChild = asINamedContentOrNull(child);\n          if (namedChild != null && namedChild.hasValidName) {\n            if (namedChild.name === null)\n              return throwNullException(\"namedChild.name\");\n            comps.unshift(new Path.Component(namedChild.name!));\n          } else {\n            comps.unshift(new Path.Component(container.content.indexOf(child)));\n          }\n\n          child = container;\n          container = asOrNull(container.parent, Container);\n        }\n\n        this._path = new Path(comps);\n      }\n    }\n\n    return this._path;\n  }\n  private _path: Path | null = null;\n\n  public ResolvePath(path: Path | null): SearchResult {\n    if (path === null) return throwNullException(\"path\");\n    if (path.isRelative) {\n      let nearestContainer = asOrNull(this, Container);\n\n      if (nearestContainer === null) {\n        Debug.Assert(\n          this.parent !== null,\n          \"Can't resolve relative path because we don't have a parent\"\n        );\n        nearestContainer = asOrNull(this.parent, Container);\n        Debug.Assert(\n          nearestContainer !== null,\n          \"Expected parent to be a container\"\n        );\n        Debug.Assert(path.GetComponent(0).isParent);\n        path = path.tail;\n      }\n\n      if (nearestContainer === null) {\n        return throwNullException(\"nearestContainer\");\n      }\n      return nearestContainer.ContentAtPath(path);\n    } else {\n      let contentContainer = this.rootContentContainer;\n      if (contentContainer === null) {\n        return throwNullException(\"contentContainer\");\n      }\n      return contentContainer.ContentAtPath(path);\n    }\n  }\n\n  public ConvertPathToRelative(globalPath: Path) {\n    let ownPath = this.path;\n\n    let minPathLength = Math.min(globalPath.length, ownPath.length);\n    let lastSharedPathCompIndex = -1;\n\n    for (let i = 0; i < minPathLength; ++i) {\n      let ownComp = ownPath.GetComponent(i);\n      let otherComp = globalPath.GetComponent(i);\n\n      if (ownComp.Equals(otherComp)) {\n        lastSharedPathCompIndex = i;\n      } else {\n        break;\n      }\n    }\n\n    // No shared path components, so just use global path\n    if (lastSharedPathCompIndex == -1) return globalPath;\n\n    let numUpwardsMoves = ownPath.componentCount - 1 - lastSharedPathCompIndex;\n\n    let newPathComps: Path.Component[] = [];\n\n    for (let up = 0; up < numUpwardsMoves; ++up)\n      newPathComps.push(Path.Component.ToParent());\n\n    for (\n      let down = lastSharedPathCompIndex + 1;\n      down < globalPath.componentCount;\n      ++down\n    )\n      newPathComps.push(globalPath.GetComponent(down));\n\n    let relativePath = new Path(newPathComps, true);\n    return relativePath;\n  }\n\n  public CompactPathString(otherPath: Path) {\n    let globalPathStr = null;\n    let relativePathStr = null;\n\n    if (otherPath.isRelative) {\n      relativePathStr = otherPath.componentsString;\n      globalPathStr = this.path.PathByAppendingPath(otherPath).componentsString;\n    } else {\n      let relativePath = this.ConvertPathToRelative(otherPath);\n      relativePathStr = relativePath.componentsString;\n      globalPathStr = otherPath.componentsString;\n    }\n\n    if (relativePathStr.length < globalPathStr.length) return relativePathStr;\n    else return globalPathStr;\n  }\n\n  get rootContentContainer() {\n    let ancestor: InkObject = this;\n    while (ancestor.parent) {\n      ancestor = ancestor.parent;\n    }\n    return asOrNull(ancestor, Container);\n  }\n\n  public Copy(): InkObject {\n    throw Error(\"Not Implemented: Doesn't support copying\");\n  }\n  // SetChild works slightly diferently in the js implementation.\n  // Since we can't pass an objets property by reference, we instead pass\n  // the object and the property string.\n  // TODO: This method can probably be rewritten with type-safety in mind.\n  public SetChild(obj: any, prop: any, value: any) {\n    if (obj[prop]) obj[prop] = null;\n\n    obj[prop] = value;\n\n    if (obj[prop]) obj[prop].parent = this;\n  }\n\n  public Equals(obj: any) {\n    return obj === this;\n  }\n}\n","export class StringBuilder {\n  private string: string;\n\n  constructor(str?: string) {\n    str = typeof str !== \"undefined\" ? str.toString() : \"\";\n    this.string = str;\n  }\n  get Length(): number {\n    return this.string.length;\n  }\n  public Append(str: string | null) {\n    if (str !== null) {\n      this.string += str;\n    }\n  }\n  public AppendLine(str?: string) {\n    if (typeof str !== \"undefined\") this.Append(str);\n    this.string += \"\\n\";\n  }\n  public AppendFormat(format: string, ...args: any[]) {\n    // taken from http://stackoverflow.com/questions/610406/javascript-equivalent-to-printf-string-format\n    this.string += format.replace(/{(\\d+)}/g, (match: string, num: number) =>\n      typeof args[num] != \"undefined\" ? args[num] : match\n    );\n  }\n  public toString(): string {\n    return this.string;\n  }\n}\n","import { throwNullException } from \"./NullException\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { ListDefinition } from \"./ListDefinition\";\nimport { Story } from \"./Story\";\n\nexport class InkListItem implements IInkListItem {\n  // InkListItem is a struct\n\n  public readonly originName: string | null = null;\n  public readonly itemName: string | null = null;\n\n  constructor(originName: string | null, itemName: string | null);\n  constructor(fullName: string | null);\n  constructor() {\n    if (typeof arguments[1] !== \"undefined\") {\n      let originName = arguments[0] as string | null;\n      let itemName = arguments[1] as string | null;\n\n      this.originName = originName;\n      this.itemName = itemName;\n    } else if (arguments[0]) {\n      let fullName = arguments[0] as string;\n\n      let nameParts = fullName.toString().split(\".\");\n      this.originName = nameParts[0];\n      this.itemName = nameParts[1];\n    }\n  }\n  public static get Null() {\n    return new InkListItem(null, null);\n  }\n  public get isNull() {\n    return this.originName == null && this.itemName == null;\n  }\n  get fullName() {\n    return (\n      (this.originName !== null ? this.originName : \"?\") + \".\" + this.itemName\n    );\n  }\n  public toString(): string {\n    return this.fullName;\n  }\n  public Equals(obj: InkListItem) {\n    if (obj instanceof InkListItem) {\n      let otherItem = obj;\n      return (\n        otherItem.itemName == this.itemName &&\n        otherItem.originName == this.originName\n      );\n    }\n\n    return false;\n  }\n\n  // These methods did not exist in the original C# code. Their purpose is to\n  // make `InkListItem` mimics the value-type semantics of the original\n  // struct. Please refer to the end of this file, for a more in-depth\n  // explanation.\n\n  /**\n   * Returns a shallow clone of the current instance.\n   */\n  public copy() {\n    return new InkListItem(this.originName, this.itemName);\n  }\n  /**\n   * Returns a `SerializedInkListItem` representing the current\n   * instance. The result is intended to be used as a key inside a Map.\n   */\n  public serialized(): SerializedInkListItem {\n    // We are simply using a JSON representation as a value-typed key.\n    return JSON.stringify({\n      originName: this.originName,\n      itemName: this.itemName,\n    });\n  }\n\n  /**\n   * Reconstructs a `InkListItem` from the given SerializedInkListItem.\n   */\n  public static fromSerializedKey(key: SerializedInkListItem): InkListItem {\n    let obj = JSON.parse(key);\n    if (!InkListItem.isLikeInkListItem(obj)) return InkListItem.Null;\n\n    let inkListItem = obj as IInkListItem;\n\n    return new InkListItem(inkListItem.originName, inkListItem.itemName);\n  }\n\n  /**\n   * Determines whether the given item is sufficiently `InkListItem`-like\n   * to be used as a template when reconstructing the InkListItem.\n   */\n  private static isLikeInkListItem(item: any) {\n    if (typeof item !== \"object\") return false;\n    if (!item.hasOwnProperty(\"originName\") || !item.hasOwnProperty(\"itemName\"))\n      return false;\n    if (typeof item.originName !== \"string\" && typeof item.originName !== null)\n      return false;\n    if (typeof item.itemName !== \"string\" && typeof item.itemName !== null)\n      return false;\n\n    return true;\n  }\n}\n\nexport class InkList extends Map<SerializedInkListItem, number> {\n  public origins: ListDefinition[] | null = null;\n  public _originNames: string[] | null = [];\n\n  constructor();\n  constructor(otherList: InkList);\n  constructor(singleOriginListName: string, originStory: Story);\n  constructor(singleElement: KeyValuePair<InkListItem, number>);\n  constructor() {\n    // Trying to be smart here, this emulates the constructor inheritance found\n    // in the original code, but only if otherList is an InkList. IIFE FTW.\n    super(\n      (() => {\n        if (arguments[0] instanceof InkList) {\n          return arguments[0];\n        } else {\n          return [];\n        }\n      })()\n    );\n\n    if (arguments[0] instanceof InkList) {\n      let otherList = arguments[0] as InkList;\n\n      this._originNames = otherList.originNames;\n      if (otherList.origins !== null) {\n        this.origins = otherList.origins.slice();\n      }\n    } else if (typeof arguments[0] === \"string\") {\n      let singleOriginListName = arguments[0] as string;\n      let originStory = arguments[1] as Story;\n      this.SetInitialOriginName(singleOriginListName);\n\n      if (originStory.listDefinitions === null) {\n        return throwNullException(\"originStory.listDefinitions\");\n      }\n      let def = originStory.listDefinitions.TryListGetDefinition(\n        singleOriginListName,\n        null\n      );\n      if (def.exists) {\n        // Throwing now, because if the value is `null` it will\n        // eventually throw down the line.\n        if (def.result === null) {\n          return throwNullException(\"def.result\");\n        }\n        this.origins = [def.result];\n      } else {\n        throw new Error(\n          \"InkList origin could not be found in story when constructing new list: \" +\n            singleOriginListName\n        );\n      }\n    } else if (\n      typeof arguments[0] === \"object\" &&\n      arguments[0].hasOwnProperty(\"Key\") &&\n      arguments[0].hasOwnProperty(\"Value\")\n    ) {\n      let singleElement = arguments[0] as KeyValuePair<InkListItem, number>;\n      this.Add(singleElement.Key, singleElement.Value);\n    }\n  }\n\n  public static FromString(myListItem: string, originStory: Story) {\n    let listValue = originStory.listDefinitions?.FindSingleItemListWithName(\n      myListItem\n    );\n    if (listValue) {\n      if (listValue.value === null) {\n        return throwNullException(\"listValue.value\");\n      }\n      return new InkList(listValue.value);\n    } else {\n      throw new Error(\n        \"Could not find the InkListItem from the string '\" +\n          myListItem +\n          \"' to create an InkList because it doesn't exist in the original list definition in ink.\"\n      );\n    }\n  }\n\n  public AddItem(itemOrItemName: InkListItem | string | null) {\n    if (itemOrItemName instanceof InkListItem) {\n      let item = itemOrItemName;\n\n      if (item.originName == null) {\n        this.AddItem(item.itemName);\n        return;\n      }\n\n      if (this.origins === null) return throwNullException(\"this.origins\");\n\n      for (let origin of this.origins) {\n        if (origin.name == item.originName) {\n          let intVal = origin.TryGetValueForItem(item, 0);\n          if (intVal.exists) {\n            this.Add(item, intVal.result);\n            return;\n          } else {\n            throw new Error(\n              \"Could not add the item \" +\n                item +\n                \" to this list because it doesn't exist in the original list definition in ink.\"\n            );\n          }\n        }\n      }\n\n      throw new Error(\n        \"Failed to add item to list because the item was from a new list definition that wasn't previously known to this list. Only items from previously known lists can be used, so that the int value can be found.\"\n      );\n    } else {\n      let itemName = itemOrItemName as string | null;\n\n      let foundListDef: ListDefinition | null = null;\n\n      if (this.origins === null) return throwNullException(\"this.origins\");\n\n      for (let origin of this.origins) {\n        if (itemName === null) return throwNullException(\"itemName\");\n\n        if (origin.ContainsItemWithName(itemName)) {\n          if (foundListDef != null) {\n            throw new Error(\n              \"Could not add the item \" +\n                itemName +\n                \" to this list because it could come from either \" +\n                origin.name +\n                \" or \" +\n                foundListDef.name\n            );\n          } else {\n            foundListDef = origin;\n          }\n        }\n      }\n\n      if (foundListDef == null)\n        throw new Error(\n          \"Could not add the item \" +\n            itemName +\n            \" to this list because it isn't known to any list definitions previously associated with this list.\"\n        );\n\n      let item = new InkListItem(foundListDef.name, itemName);\n      let itemVal = foundListDef.ValueForItem(item);\n      this.Add(item, itemVal);\n    }\n  }\n  public ContainsItemNamed(itemName: string | null) {\n    for (let [key] of this) {\n      let item = InkListItem.fromSerializedKey(key);\n      if (item.itemName == itemName) return true;\n    }\n\n    return false;\n  }\n  public ContainsKey(key: InkListItem) {\n    return this.has(key.serialized());\n  }\n  public Add(key: InkListItem, value: number) {\n    let serializedKey = key.serialized();\n    if (this.has(serializedKey)) {\n      // Throw an exception to match the C# behavior.\n      throw new Error(`The Map already contains an entry for ${key}`);\n    }\n    this.set(serializedKey, value);\n  }\n  public Remove(key: InkListItem) {\n    return this.delete(key.serialized());\n  }\n  get Count() {\n    return this.size;\n  }\n  get originOfMaxItem(): ListDefinition | null {\n    if (this.origins == null) return null;\n\n    let maxOriginName = this.maxItem.Key.originName;\n    let result = null;\n    this.origins.every((origin) => {\n      if (origin.name == maxOriginName) {\n        result = origin;\n        return false;\n      } else return true;\n    });\n\n    return result;\n  }\n  get originNames(): string[] {\n    if (this.Count > 0) {\n      if (this._originNames == null && this.Count > 0) this._originNames = [];\n      else {\n        if (!this._originNames) this._originNames = [];\n        this._originNames.length = 0;\n      }\n\n      for (let [key] of this) {\n        let item = InkListItem.fromSerializedKey(key);\n        if (item.originName === null)\n          return throwNullException(\"item.originName\");\n        this._originNames.push(item.originName);\n      }\n    }\n\n    return this._originNames as string[];\n  }\n  public SetInitialOriginName(initialOriginName: string) {\n    this._originNames = [initialOriginName];\n  }\n  public SetInitialOriginNames(initialOriginNames: string[]) {\n    if (initialOriginNames == null) this._originNames = null;\n    else this._originNames = initialOriginNames.slice(); // store a copy\n  }\n  get maxItem() {\n    let max: KeyValuePair<InkListItem, number> = {\n      Key: InkListItem.Null,\n      Value: 0,\n    };\n    for (let [key, value] of this) {\n      let item = InkListItem.fromSerializedKey(key);\n      if (max.Key.isNull || value > max.Value)\n        max = { Key: item, Value: value };\n    }\n\n    return max;\n  }\n  get minItem() {\n    let min: KeyValuePair<InkListItem, number> = {\n      Key: InkListItem.Null,\n      Value: 0,\n    };\n    for (let [key, value] of this) {\n      let item = InkListItem.fromSerializedKey(key);\n      if (min.Key.isNull || value < min.Value) {\n        min = { Key: item, Value: value };\n      }\n    }\n    return min;\n  }\n  get inverse() {\n    let list = new InkList();\n    if (this.origins != null) {\n      for (let origin of this.origins) {\n        for (let [key, value] of origin.items) {\n          let item = InkListItem.fromSerializedKey(key);\n          if (!this.ContainsKey(item)) list.Add(item, value);\n        }\n      }\n    }\n    return list;\n  }\n  get all() {\n    let list = new InkList();\n    if (this.origins != null) {\n      for (let origin of this.origins) {\n        for (let [key, value] of origin.items) {\n          let item = InkListItem.fromSerializedKey(key);\n          list.set(item.serialized(), value);\n        }\n      }\n    }\n    return list;\n  }\n  public Union(otherList: InkList) {\n    let union = new InkList(this);\n    for (let [key, value] of otherList) {\n      union.set(key, value);\n    }\n    return union;\n  }\n  public Intersect(otherList: InkList) {\n    let intersection = new InkList();\n    for (let [key, value] of this) {\n      if (otherList.has(key)) intersection.set(key, value);\n    }\n\n    return intersection;\n  }\n  public Without(listToRemove: InkList) {\n    let result = new InkList(this);\n    for (let [key] of listToRemove) {\n      result.delete(key);\n    }\n\n    return result;\n  }\n  public Contains(otherList: InkList) {\n    for (let [key] of otherList) {\n      if (!this.has(key)) return false;\n    }\n\n    return true;\n  }\n  public GreaterThan(otherList: InkList) {\n    if (this.Count == 0) return false;\n    if (otherList.Count == 0) return true;\n\n    return this.minItem.Value > otherList.maxItem.Value;\n  }\n  public GreaterThanOrEquals(otherList: InkList) {\n    if (this.Count == 0) return false;\n    if (otherList.Count == 0) return true;\n\n    return (\n      this.minItem.Value >= otherList.minItem.Value &&\n      this.maxItem.Value >= otherList.maxItem.Value\n    );\n  }\n  public LessThan(otherList: InkList) {\n    if (otherList.Count == 0) return false;\n    if (this.Count == 0) return true;\n\n    return this.maxItem.Value < otherList.minItem.Value;\n  }\n  public LessThanOrEquals(otherList: InkList) {\n    if (otherList.Count == 0) return false;\n    if (this.Count == 0) return true;\n\n    return (\n      this.maxItem.Value <= otherList.maxItem.Value &&\n      this.minItem.Value <= otherList.minItem.Value\n    );\n  }\n  public MaxAsList() {\n    if (this.Count > 0) return new InkList(this.maxItem);\n    else return new InkList();\n  }\n  public MinAsList() {\n    if (this.Count > 0) return new InkList(this.minItem);\n    else return new InkList();\n  }\n  public ListWithSubRange(minBound: any, maxBound: any) {\n    if (this.Count == 0) return new InkList();\n\n    let ordered = this.orderedItems;\n\n    let minValue = 0;\n    let maxValue = Number.MAX_SAFE_INTEGER;\n\n    if (Number.isInteger(minBound)) {\n      minValue = minBound;\n    } else {\n      if (minBound instanceof InkList && minBound.Count > 0)\n        minValue = minBound.minItem.Value;\n    }\n\n    if (Number.isInteger(maxBound)) {\n      maxValue = maxBound;\n    } else {\n      if (minBound instanceof InkList && minBound.Count > 0)\n        maxValue = maxBound.maxItem.Value;\n    }\n\n    let subList = new InkList();\n    subList.SetInitialOriginNames(this.originNames);\n    for (let item of ordered) {\n      if (item.Value >= minValue && item.Value <= maxValue) {\n        subList.Add(item.Key, item.Value);\n      }\n    }\n\n    return subList;\n  }\n  public Equals(otherInkList: InkList) {\n    if (otherInkList instanceof InkList === false) return false;\n    if (otherInkList.Count != this.Count) return false;\n\n    for (let [key] of this) {\n      if (!otherInkList.has(key)) return false;\n    }\n\n    return true;\n  }\n  // GetHashCode not implemented\n  get orderedItems() {\n    // List<KeyValuePair<InkListItem, int>>\n    let ordered = new Array<KeyValuePair<InkListItem, number>>();\n\n    for (let [key, value] of this) {\n      let item = InkListItem.fromSerializedKey(key);\n      ordered.push({ Key: item, Value: value });\n    }\n\n    ordered.sort((x, y) => {\n      if (x.Key.originName === null) {\n        return throwNullException(\"x.Key.originName\");\n      }\n      if (y.Key.originName === null) {\n        return throwNullException(\"y.Key.originName\");\n      }\n\n      if (x.Value == y.Value) {\n        return x.Key.originName.localeCompare(y.Key.originName);\n      } else {\n        // TODO: refactor this bit into a numberCompareTo method?\n        if (x.Value < y.Value) return -1;\n        return x.Value > y.Value ? 1 : 0;\n      }\n    });\n\n    return ordered;\n  }\n  public toString() {\n    let ordered = this.orderedItems;\n\n    let sb = new StringBuilder();\n    for (let i = 0; i < ordered.length; i++) {\n      if (i > 0) sb.Append(\", \");\n\n      let item = ordered[i].Key;\n      if (item.itemName === null) return throwNullException(\"item.itemName\");\n      sb.Append(item.itemName);\n    }\n\n    return sb.toString();\n  }\n  // casting a InkList to a Number, for somereason, actually gives a number.\n  // This messes up the type detection when creating a Value from a InkList.\n  // Returning NaN here prevents that.\n  public valueOf() {\n    return NaN;\n  }\n}\n\n/**\n * In the original C# code, `InkListItem` was defined as value type, meaning\n * that two `InkListItem` would be considered equal as long as they held the\n * same values. This doesn't hold true in Javascript, as `InkListItem` is a\n * reference type (Javascript doesn't allow the creation of custom value types).\n *\n * The key equality of Map objects is based on the \"SameValueZero\" algorithm;\n * since `InkListItem` is a value type, two keys will only be considered\n * equal if they are, in fact, the same object. As we are trying to emulate\n * the original behavior as close as possible, this will lead to unforeseen\n * side effects.\n *\n * In order to have a key equality based on value semantics, we'll convert\n * `InkListItem` to a valid string representation and use this representation\n * as a key (strings are value types in Javascript). Rather than using the\n * type `string` directly, we'll alias it to `SerializedInkListItem` and use\n * this type as the key for our Map-based `InkList`.\n *\n * Reducing `InkListItem` to a JSON representation would not be bulletproof\n * in the general case, but for our needs it works well. The major downside of\n * this method is that we will have to to reconstruct the original `InkListItem`\n * every time we'll need to access its properties.\n */\nexport type SerializedInkListItem = string;\n\n/**\n * An interface inherited by `InkListItem`, defining exposed\n * properties. It's mainly used when deserializing a `InkListItem` from its\n * key (`SerializedInkListItem`)\n */\ninterface IInkListItem {\n  readonly originName: string | null;\n  readonly itemName: string | null;\n}\nexport interface KeyValuePair<K, V> {\n  Key: K;\n  Value: V;\n}\n","export class StoryException extends Error {\n  public useEndLineNumber: boolean;\n  public message: string;\n  public name: string;\n\n  constructor(message: string) {\n    super(message);\n    this.useEndLineNumber = false;\n    this.message = message;\n    this.name = \"StoryException\";\n  }\n}\n","/**\n * This interface normalize the `TryGet` behavior found in the original\n * C# project. Any `TryGet` method will return a object conforming to this\n * interface.\n *\n * The original function returns a boolean and has a second parameter called\n * item that is an `out`. Both are needed and we can't just return the item\n * because it'll always be truthy. Instead, we return an object containing\n * whether the result exists (`exists`) and the result itself (`result`).\n *\n * For instance a `TryGet` prototype would look like this:\n```\nTryGetItemWithValue(val: number, item: InkListItem): TryGetResult<InkListItem>{\n```\n *\n * On the other hand, dealing with the result can be done in the following way:\n```\nvar item = item.TryGetItemWithValue(intVal, InkListItem.Null);\nif (item.exists) {\n\tconsole.log(item.result)\n}\n```\n *\n */\nexport interface TryGetResult<T> {\n  result: T;\n  exists: boolean;\n}\n\nexport function tryGetValueFromMap<K, V>(\n  map: Map<K, V> | null,\n  key: K,\n  /* out */ value: V\n): TryGetResult<V> {\n  if (map === null) {\n    return { result: value, exists: false };\n  }\n\n  let val = map.get(key);\n\n  if (typeof val === \"undefined\") {\n    return { result: value, exists: false };\n  } else {\n    return { result: val, exists: true };\n  }\n}\n\nexport function tryParseInt(\n  value: any,\n  /* out */ defaultValue: number = 0\n): TryGetResult<number> {\n  let val = parseInt(value);\n\n  if (!Number.isNaN(val)) {\n    return { result: val, exists: true };\n  } else {\n    return { result: defaultValue, exists: false };\n  }\n}\n\nexport function tryParseFloat(\n  value: any,\n  /* out */ defaultValue: number = 0\n): TryGetResult<number> {\n  let val = parseFloat(value);\n\n  if (!Number.isNaN(val)) {\n    return { result: val, exists: true };\n  } else {\n    return { result: defaultValue, exists: false };\n  }\n}\n","import { InkObject } from \"./Object\";\nimport { Path } from \"./Path\";\nimport { InkList, InkListItem } from \"./InkList\";\nimport { StoryException } from \"./StoryException\";\nimport { asOrNull, asOrThrows } from \"./TypeAssertion\";\nimport { tryParseInt, tryParseFloat } from \"./TryGetResult\";\nimport { throwNullException } from \"./NullException\";\n\nexport abstract class AbstractValue extends InkObject {\n  public abstract get valueType(): ValueType;\n  public abstract get isTruthy(): boolean;\n  public abstract get valueObject(): any;\n\n  public abstract Cast(newType: ValueType): Value<any>;\n\n  public static Create(\n    val: any,\n    preferredNumberType?: ValueType\n  ): Value<any> | null {\n    // This code doesn't exist in upstream and is simply here to enforce\n    // the creation of the proper number value.\n    // If `preferredNumberType` is not provided or if value doesn't match\n    // `preferredNumberType`, this conditional does nothing.\n    if (preferredNumberType) {\n      if (\n        preferredNumberType === (ValueType.Int as ValueType) &&\n        Number.isInteger(Number(val))\n      ) {\n        return new IntValue(Number(val));\n      } else if (\n        preferredNumberType === (ValueType.Float as ValueType) &&\n        !isNaN(val)\n      ) {\n        return new FloatValue(Number(val));\n      }\n    }\n\n    if (typeof val === \"boolean\") {\n      return new BoolValue(Boolean(val));\n    }\n\n    // https://github.com/y-lohse/inkjs/issues/425\n    // Changed condition sequence, because Number('') is\n    // parsed to 0, which made setting string to empty\n    // impossible\n    if (typeof val === \"string\") {\n      return new StringValue(String(val));\n    } else if (Number.isInteger(Number(val))) {\n      return new IntValue(Number(val));\n    } else if (!isNaN(val)) {\n      return new FloatValue(Number(val));\n    } else if (val instanceof Path) {\n      return new DivertTargetValue(asOrThrows(val, Path));\n    } else if (val instanceof InkList) {\n      return new ListValue(asOrThrows(val, InkList));\n    }\n\n    return null;\n  }\n  public Copy() {\n    return asOrThrows(AbstractValue.Create(this.valueObject), InkObject);\n  }\n  public BadCastException(targetType: ValueType) {\n    return new StoryException(\n      \"Can't cast \" +\n        this.valueObject +\n        \" from \" +\n        this.valueType +\n        \" to \" +\n        targetType\n    );\n  }\n}\n\nexport abstract class Value<\n  T extends { toString: () => string }\n> extends AbstractValue {\n  public value: T | null;\n\n  constructor(val: T | null) {\n    super();\n    this.value = val;\n  }\n  public get valueObject() {\n    return this.value;\n  }\n  public toString() {\n    if (this.value === null) return throwNullException(\"Value.value\");\n    return this.value.toString();\n  }\n}\n\nexport class BoolValue extends Value<boolean> {\n  constructor(val: boolean) {\n    super(val || false);\n  }\n  public get isTruthy() {\n    return Boolean(this.value);\n  }\n  public get valueType() {\n    return ValueType.Bool;\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (newType == this.valueType) {\n      return this;\n    }\n\n    if (newType == ValueType.Int) {\n      return new IntValue(this.value ? 1 : 0);\n    }\n\n    if (newType == ValueType.Float) {\n      return new FloatValue(this.value ? 1.0 : 0.0);\n    }\n\n    if (newType == ValueType.String) {\n      return new StringValue(this.value ? \"true\" : \"false\");\n    }\n\n    throw this.BadCastException(newType);\n  }\n\n  public toString() {\n    return this.value ? \"true\" : \"false\";\n  }\n}\n\nexport class IntValue extends Value<number> {\n  constructor(val: number) {\n    super(val || 0);\n  }\n  public get isTruthy() {\n    return this.value != 0;\n  }\n  public get valueType() {\n    return ValueType.Int;\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (newType == this.valueType) {\n      return this;\n    }\n\n    if (newType == ValueType.Bool) {\n      return new BoolValue(this.value === 0 ? false : true);\n    }\n\n    if (newType == ValueType.Float) {\n      return new FloatValue(this.value);\n    }\n\n    if (newType == ValueType.String) {\n      return new StringValue(\"\" + this.value);\n    }\n\n    throw this.BadCastException(newType);\n  }\n}\n\nexport class FloatValue extends Value<number> {\n  constructor(val: number) {\n    super(val || 0.0);\n  }\n  public get isTruthy() {\n    return this.value != 0.0;\n  }\n  public get valueType() {\n    return ValueType.Float;\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (newType == this.valueType) {\n      return this;\n    }\n\n    if (newType == ValueType.Bool) {\n      return new BoolValue(this.value === 0.0 ? false : true);\n    }\n\n    if (newType == ValueType.Int) {\n      return new IntValue(this.value);\n    }\n\n    if (newType == ValueType.String) {\n      return new StringValue(\"\" + this.value);\n    }\n\n    throw this.BadCastException(newType);\n  }\n}\n\nexport class StringValue extends Value<string> {\n  public _isNewline: boolean;\n  public _isInlineWhitespace: boolean;\n\n  constructor(val: string) {\n    super(val || \"\");\n\n    this._isNewline = this.value == \"\\n\";\n    this._isInlineWhitespace = true;\n\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (this.value.length > 0) {\n      this.value.split(\"\").every((c) => {\n        if (c != \" \" && c != \"\\t\") {\n          this._isInlineWhitespace = false;\n          return false;\n        }\n\n        return true;\n      });\n    }\n  }\n  public get valueType() {\n    return ValueType.String;\n  }\n  public get isTruthy() {\n    if (this.value === null) return throwNullException(\"Value.value\");\n    return this.value.length > 0;\n  }\n  public get isNewline() {\n    return this._isNewline;\n  }\n  public get isInlineWhitespace() {\n    return this._isInlineWhitespace;\n  }\n  public get isNonWhitespace() {\n    return !this.isNewline && !this.isInlineWhitespace;\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (newType == this.valueType) {\n      return this;\n    }\n\n    if (newType == ValueType.Int) {\n      let parsedInt = tryParseInt(this.value);\n      if (parsedInt.exists) {\n        return new IntValue(parsedInt.result);\n      } else {\n        throw this.BadCastException(newType);\n      }\n    }\n\n    if (newType == ValueType.Float) {\n      let parsedFloat = tryParseFloat(this.value);\n      if (parsedFloat.exists) {\n        return new FloatValue(parsedFloat.result);\n      } else {\n        throw this.BadCastException(newType);\n      }\n    }\n\n    throw this.BadCastException(newType);\n  }\n}\n\nexport class DivertTargetValue extends Value<Path> {\n  constructor(targetPath: Path | null = null) {\n    super(targetPath);\n  }\n  public get valueType() {\n    return ValueType.DivertTarget;\n  }\n  public get targetPath() {\n    if (this.value === null) return throwNullException(\"Value.value\");\n    return this.value;\n  }\n  public set targetPath(value: Path) {\n    this.value = value;\n  }\n  public get isTruthy(): never {\n    throw new Error(\"Shouldn't be checking the truthiness of a divert target\");\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (newType == this.valueType) return this;\n\n    throw this.BadCastException(newType);\n  }\n  public toString() {\n    return \"DivertTargetValue(\" + this.targetPath + \")\";\n  }\n}\n\nexport class VariablePointerValue extends Value<string> {\n  public _contextIndex: number;\n\n  constructor(variableName: string, contextIndex: number = -1) {\n    super(variableName);\n\n    this._contextIndex = contextIndex;\n  }\n\n  public get contextIndex() {\n    return this._contextIndex;\n  }\n  public set contextIndex(value: number) {\n    this._contextIndex = value;\n  }\n  public get variableName() {\n    if (this.value === null) return throwNullException(\"Value.value\");\n    return this.value;\n  }\n  public set variableName(value: string) {\n    this.value = value;\n  }\n  public get valueType() {\n    return ValueType.VariablePointer;\n  }\n\n  public get isTruthy(): never {\n    throw new Error(\n      \"Shouldn't be checking the truthiness of a variable pointer\"\n    );\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (newType == this.valueType) return this;\n\n    throw this.BadCastException(newType);\n  }\n  public toString() {\n    return \"VariablePointerValue(\" + this.variableName + \")\";\n  }\n  public Copy() {\n    return new VariablePointerValue(this.variableName, this.contextIndex);\n  }\n}\n\nexport class ListValue extends Value<InkList> {\n  public get isTruthy() {\n    if (this.value === null) {\n      return throwNullException(\"this.value\");\n    }\n    return this.value.Count > 0;\n  }\n  public get valueType() {\n    return ValueType.List;\n  }\n  public Cast(newType: ValueType): Value<any> {\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (newType == ValueType.Int) {\n      let max = this.value.maxItem;\n      if (max.Key.isNull) return new IntValue(0);\n      else return new IntValue(max.Value);\n    } else if (newType == ValueType.Float) {\n      let max = this.value.maxItem;\n      if (max.Key.isNull) return new FloatValue(0.0);\n      else return new FloatValue(max.Value);\n    } else if (newType == ValueType.String) {\n      let max = this.value.maxItem;\n      if (max.Key.isNull) return new StringValue(\"\");\n      else {\n        return new StringValue(max.Key.toString());\n      }\n    }\n\n    if (newType == this.valueType) return this;\n\n    throw this.BadCastException(newType);\n  }\n  constructor();\n  constructor(list: InkList);\n  constructor(listOrSingleItem: InkListItem, singleValue: number);\n  constructor(listOrSingleItem?: InkListItem | InkList, singleValue?: number) {\n    super(null);\n\n    if (!listOrSingleItem && !singleValue) {\n      this.value = new InkList();\n    } else if (listOrSingleItem instanceof InkList) {\n      this.value = new InkList(listOrSingleItem);\n    } else if (\n      listOrSingleItem instanceof InkListItem &&\n      typeof singleValue === \"number\"\n    ) {\n      this.value = new InkList({\n        Key: listOrSingleItem,\n        Value: singleValue,\n      });\n    }\n  }\n  public static RetainListOriginsForAssignment(\n    oldValue: InkObject | null,\n    newValue: InkObject\n  ) {\n    let oldList = asOrNull(oldValue, ListValue);\n    let newList = asOrNull(newValue, ListValue);\n\n    if (newList && newList.value === null)\n      return throwNullException(\"newList.value\");\n    if (oldList && oldList.value === null)\n      return throwNullException(\"oldList.value\");\n\n    // When assigning the empty list, try to retain any initial origin names\n    if (oldList && newList && newList.value!.Count == 0)\n      newList.value!.SetInitialOriginNames(oldList.value!.originNames);\n  }\n}\n\nexport enum ValueType {\n  Bool = -1,\n  Int = 0,\n  Float = 1,\n  List = 2,\n  String = 3,\n  DivertTarget = 4,\n  VariablePointer = 5,\n}\n","import { InkObject } from \"./Object\";\nimport { Container } from \"./Container\";\n\nexport class SearchResult {\n  public obj: InkObject | null = null;\n  public approximate: boolean = false;\n\n  get correctObj() {\n    return this.approximate ? null : this.obj;\n  }\n\n  get container() {\n    return this.obj instanceof Container ? this.obj : null;\n  }\n\n  public copy() {\n    let searchResult = new SearchResult();\n    searchResult.obj = this.obj;\n    searchResult.approximate = this.approximate;\n\n    return searchResult;\n  }\n}\n","import { StringValue } from \"./Value\";\nimport { throwNullException } from \"./NullException\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { INamedContent } from \"./INamedContent\";\nimport { InkObject } from \"./Object\";\nimport { SearchResult } from \"./SearchResult\";\nimport { Path } from \"./Path\";\nimport { Debug } from \"./Debug\";\nimport { tryGetValueFromMap } from \"./TryGetResult\";\nimport { asINamedContentOrNull, asOrNull, asOrThrows } from \"./TypeAssertion\";\n\nexport class Container extends InkObject implements INamedContent {\n  public name: string | null = null;\n\n  public _content: InkObject[] = [];\n  public namedContent: Map<string, INamedContent> = new Map();\n\n  public visitsShouldBeCounted: boolean = false;\n  public turnIndexShouldBeCounted: boolean = false;\n  public countingAtStartOnly: boolean = false;\n\n  public _pathToFirstLeafContent: Path | null = null;\n\n  get hasValidName() {\n    return this.name != null && this.name.length > 0;\n  }\n  get content() {\n    return this._content;\n  }\n  set content(value: InkObject[]) {\n    this.AddContent(value);\n  }\n  get namedOnlyContent() {\n    let namedOnlyContentDict: Map<string, InkObject> | null = new Map();\n\n    for (let [key, value] of this.namedContent) {\n      let inkObject = asOrThrows(value, InkObject);\n      namedOnlyContentDict.set(key, inkObject);\n    }\n\n    for (let c of this.content) {\n      let named = asINamedContentOrNull(c);\n      if (named != null && named.hasValidName) {\n        namedOnlyContentDict.delete(named.name!);\n      }\n    }\n\n    if (namedOnlyContentDict.size == 0) namedOnlyContentDict = null;\n\n    return namedOnlyContentDict;\n  }\n  set namedOnlyContent(value: Map<string, InkObject> | null) {\n    let existingNamedOnly = this.namedOnlyContent;\n    if (existingNamedOnly != null) {\n      for (let [key] of existingNamedOnly) {\n        this.namedContent.delete(key);\n      }\n    }\n\n    if (value == null) return;\n\n    for (let [, val] of value) {\n      let named = asINamedContentOrNull(val);\n      if (named != null) this.AddToNamedContentOnly(named);\n    }\n  }\n  get countFlags(): number {\n    let flags: Container.CountFlags = 0;\n    if (this.visitsShouldBeCounted) flags |= Container.CountFlags.Visits;\n    if (this.turnIndexShouldBeCounted) flags |= Container.CountFlags.Turns;\n    if (this.countingAtStartOnly) flags |= Container.CountFlags.CountStartOnly;\n\n    if (flags == Container.CountFlags.CountStartOnly) {\n      flags = 0;\n    }\n\n    return flags;\n  }\n  set countFlags(value: number) {\n    let flag: Container.CountFlags = value;\n    if ((flag & Container.CountFlags.Visits) > 0)\n      this.visitsShouldBeCounted = true;\n    if ((flag & Container.CountFlags.Turns) > 0)\n      this.turnIndexShouldBeCounted = true;\n    if ((flag & Container.CountFlags.CountStartOnly) > 0)\n      this.countingAtStartOnly = true;\n  }\n  get pathToFirstLeafContent() {\n    if (this._pathToFirstLeafContent == null)\n      this._pathToFirstLeafContent = this.path.PathByAppendingPath(\n        this.internalPathToFirstLeafContent\n      );\n\n    return this._pathToFirstLeafContent;\n  }\n  get internalPathToFirstLeafContent() {\n    let components: Path.Component[] = [];\n    let container: Container = this;\n    while (container instanceof Container) {\n      if (container.content.length > 0) {\n        components.push(new Path.Component(0));\n        container = container.content[0] as Container;\n      }\n    }\n    return new Path(components);\n  }\n\n  public AddContent(contentObjOrList: InkObject | InkObject[]) {\n    if (contentObjOrList instanceof Array) {\n      let contentList = contentObjOrList as InkObject[];\n\n      for (let c of contentList) {\n        this.AddContent(c);\n      }\n    } else {\n      let contentObj = contentObjOrList as InkObject;\n\n      this._content.push(contentObj);\n\n      if (contentObj.parent) {\n        throw new Error(\"content is already in \" + contentObj.parent);\n      }\n\n      contentObj.parent = this;\n\n      this.TryAddNamedContent(contentObj);\n    }\n  }\n  public TryAddNamedContent(contentObj: InkObject) {\n    let namedContentObj = asINamedContentOrNull(contentObj);\n    if (namedContentObj != null && namedContentObj.hasValidName) {\n      this.AddToNamedContentOnly(namedContentObj);\n    }\n  }\n  public AddToNamedContentOnly(namedContentObj: INamedContent) {\n    Debug.AssertType(\n      namedContentObj,\n      InkObject,\n      \"Can only add Runtime.Objects to a Runtime.Container\"\n    );\n    let runtimeObj = asOrThrows(namedContentObj, InkObject);\n    runtimeObj.parent = this;\n\n    if (namedContentObj.name === null)\n      return throwNullException(\"namedContentObj.name\");\n    this.namedContent.set(namedContentObj.name!, namedContentObj);\n  }\n  public ContentAtPath(\n    path: Path,\n    partialPathStart: number = 0,\n    partialPathLength: number = -1\n  ) {\n    if (partialPathLength == -1) partialPathLength = path.length;\n\n    let result = new SearchResult();\n    result.approximate = false;\n\n    let currentContainer: Container | null = this;\n    let currentObj: InkObject = this;\n\n    for (let i = partialPathStart; i < partialPathLength; ++i) {\n      let comp = path.GetComponent(i);\n      if (currentContainer == null) {\n        result.approximate = true;\n        break;\n      }\n\n      let foundObj: InkObject | null = currentContainer.ContentWithPathComponent(\n        comp\n      );\n\n      if (foundObj == null) {\n        result.approximate = true;\n        break;\n      }\n\n      currentObj = foundObj;\n      currentContainer = asOrNull(foundObj, Container);\n    }\n\n    result.obj = currentObj;\n\n    return result;\n  }\n  public InsertContent(contentObj: InkObject, index: number) {\n    this.content.splice(index, 0, contentObj);\n\n    if (contentObj.parent) {\n      throw new Error(\"content is already in \" + contentObj.parent);\n    }\n\n    contentObj.parent = this;\n\n    this.TryAddNamedContent(contentObj);\n  }\n  public AddContentsOfContainer(otherContainer: Container) {\n    this.content.push(...otherContainer.content);\n\n    for (let obj of otherContainer.content) {\n      obj.parent = this;\n      this.TryAddNamedContent(obj);\n    }\n  }\n  public ContentWithPathComponent(component: Path.Component): InkObject | null {\n    if (component.isIndex) {\n      if (component.index >= 0 && component.index < this.content.length) {\n        return this.content[component.index];\n      } else {\n        return null;\n      }\n    } else if (component.isParent) {\n      return this.parent;\n    } else {\n      if (component.name === null) {\n        return throwNullException(\"component.name\");\n      }\n      let foundContent = tryGetValueFromMap(\n        this.namedContent,\n        component.name,\n        null\n      );\n      if (foundContent.exists) {\n        return asOrThrows(foundContent.result, InkObject);\n      } else {\n        return null;\n      }\n    }\n  }\n  public BuildStringOfHierarchy(): string;\n  public BuildStringOfHierarchy(\n    sb: StringBuilder,\n    indentation: number,\n    pointedObj: InkObject | null\n  ): string;\n  public BuildStringOfHierarchy() {\n    let sb: StringBuilder;\n    if (arguments.length == 0) {\n      sb = new StringBuilder();\n      this.BuildStringOfHierarchy(sb, 0, null);\n      return sb.toString();\n    }\n\n    sb = arguments[0] as StringBuilder;\n    let indentation = arguments[1] as number;\n    let pointedObj = arguments[2] as InkObject | null;\n\n    function appendIndentation() {\n      const spacesPerIndent = 4; // Truly const in the original code\n      for (let i = 0; i < spacesPerIndent * indentation; ++i) {\n        sb.Append(\" \");\n      }\n    }\n\n    appendIndentation();\n    sb.Append(\"[\");\n\n    if (this.hasValidName) {\n      sb.AppendFormat(\" ({0})\", this.name);\n    }\n\n    if (this == pointedObj) {\n      sb.Append(\"  <---\");\n    }\n\n    sb.AppendLine();\n\n    indentation++;\n\n    for (let i = 0; i < this.content.length; ++i) {\n      let obj = this.content[i];\n\n      if (obj instanceof Container) {\n        let container = obj as Container;\n\n        container.BuildStringOfHierarchy(sb, indentation, pointedObj);\n      } else {\n        appendIndentation();\n        if (obj instanceof StringValue) {\n          sb.Append('\"');\n          sb.Append(obj.toString().replace(\"\\n\", \"\\\\n\"));\n          sb.Append('\"');\n        } else {\n          sb.Append(obj.toString());\n        }\n      }\n\n      if (i != this.content.length - 1) {\n        sb.Append(\",\");\n      }\n\n      if (!(obj instanceof Container) && obj == pointedObj) {\n        sb.Append(\"  <---\");\n      }\n\n      sb.AppendLine();\n    }\n\n    let onlyNamed: Map<string, INamedContent> = new Map();\n\n    for (let [key, value] of this.namedContent) {\n      if (this.content.indexOf(asOrThrows(value, InkObject)) >= 0) {\n        continue;\n      } else {\n        onlyNamed.set(key, value);\n      }\n    }\n\n    if (onlyNamed.size > 0) {\n      appendIndentation();\n      sb.AppendLine(\"-- named: --\");\n\n      for (let [, value] of onlyNamed) {\n        Debug.AssertType(\n          value,\n          Container,\n          \"Can only print out named Containers\"\n        );\n        let container = value as Container;\n        container.BuildStringOfHierarchy(sb, indentation, pointedObj);\n        sb.AppendLine();\n      }\n    }\n\n    indentation--;\n\n    appendIndentation();\n    sb.Append(\"]\");\n  }\n}\n\nexport namespace Container {\n  export enum CountFlags {\n    Visits = 1,\n    Turns = 2,\n    CountStartOnly = 4,\n  }\n}\n","import { InkObject } from \"./Object\";\n\nexport class ControlCommand extends InkObject {\n  private _commandType: ControlCommand.CommandType;\n\n  get commandType(): ControlCommand.CommandType {\n    return this._commandType;\n  }\n\n  constructor(\n    commandType: ControlCommand.CommandType = ControlCommand.CommandType.NotSet\n  ) {\n    super();\n    this._commandType = commandType;\n  }\n\n  public Copy() {\n    return new ControlCommand(this.commandType);\n  }\n  public static EvalStart() {\n    return new ControlCommand(ControlCommand.CommandType.EvalStart);\n  }\n  public static EvalOutput() {\n    return new ControlCommand(ControlCommand.CommandType.EvalOutput);\n  }\n  public static EvalEnd() {\n    return new ControlCommand(ControlCommand.CommandType.EvalEnd);\n  }\n  public static Duplicate() {\n    return new ControlCommand(ControlCommand.CommandType.Duplicate);\n  }\n  public static PopEvaluatedValue() {\n    return new ControlCommand(ControlCommand.CommandType.PopEvaluatedValue);\n  }\n  public static PopFunction() {\n    return new ControlCommand(ControlCommand.CommandType.PopFunction);\n  }\n  public static PopTunnel() {\n    return new ControlCommand(ControlCommand.CommandType.PopTunnel);\n  }\n  public static BeginString() {\n    return new ControlCommand(ControlCommand.CommandType.BeginString);\n  }\n  public static EndString() {\n    return new ControlCommand(ControlCommand.CommandType.EndString);\n  }\n  public static NoOp() {\n    return new ControlCommand(ControlCommand.CommandType.NoOp);\n  }\n  public static ChoiceCount() {\n    return new ControlCommand(ControlCommand.CommandType.ChoiceCount);\n  }\n  public static Turns() {\n    return new ControlCommand(ControlCommand.CommandType.Turns);\n  }\n  public static TurnsSince() {\n    return new ControlCommand(ControlCommand.CommandType.TurnsSince);\n  }\n  public static ReadCount() {\n    return new ControlCommand(ControlCommand.CommandType.ReadCount);\n  }\n  public static Random() {\n    return new ControlCommand(ControlCommand.CommandType.Random);\n  }\n  public static SeedRandom() {\n    return new ControlCommand(ControlCommand.CommandType.SeedRandom);\n  }\n  public static VisitIndex() {\n    return new ControlCommand(ControlCommand.CommandType.VisitIndex);\n  }\n  public static SequenceShuffleIndex() {\n    return new ControlCommand(ControlCommand.CommandType.SequenceShuffleIndex);\n  }\n  public static StartThread() {\n    return new ControlCommand(ControlCommand.CommandType.StartThread);\n  }\n  public static Done() {\n    return new ControlCommand(ControlCommand.CommandType.Done);\n  }\n  public static End() {\n    return new ControlCommand(ControlCommand.CommandType.End);\n  }\n  public static ListFromInt() {\n    return new ControlCommand(ControlCommand.CommandType.ListFromInt);\n  }\n  public static ListRange() {\n    return new ControlCommand(ControlCommand.CommandType.ListRange);\n  }\n  public static ListRandom() {\n    return new ControlCommand(ControlCommand.CommandType.ListRandom);\n  }\n  public toString() {\n    return this.commandType.toString();\n  }\n}\n\nexport namespace ControlCommand {\n  export enum CommandType {\n    NotSet = -1,\n    EvalStart, // 0\n    EvalOutput, // 1\n    EvalEnd, // 2\n    Duplicate, // 3\n    PopEvaluatedValue, // 4\n    PopFunction, // 5\n    PopTunnel, // 6\n    BeginString, // 7\n    EndString, // 8\n    NoOp, // 9\n    ChoiceCount, // 10\n    Turns, // 11\n    TurnsSince, // 12\n    Random, // 13\n    SeedRandom, // 14\n    VisitIndex, // 15\n    SequenceShuffleIndex, // 16\n    StartThread, // 17\n    Done, // 18\n    End, // 19\n    ListFromInt, // 20\n    ListRange, // 21\n    ListRandom, // 22\n    ReadCount, // 23\n\n    TOTAL_VALUES,\n  }\n}\n","import { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { ControlCommand as RuntimeControlCommand } from \"../../../../engine/ControlCommand\";\nimport { ParsedObject } from \"../Object\";\nimport { InkObject as RuntimeObject } from \"../../../../engine/Object\";\n\nexport abstract class Expression extends ParsedObject {\n  public abstract GenerateIntoContainer: (container: RuntimeContainer) => void;\n\n  private _prototypeRuntimeConstantExpression: RuntimeContainer | null = null;\n  public outputWhenComplete: boolean = false;\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject => {\n    const container = new RuntimeContainer();\n\n    // Tell Runtime to start evaluating the following content as an expression\n    container.AddContent(RuntimeControlCommand.EvalStart());\n\n    this.GenerateIntoContainer(container);\n\n    // Tell Runtime to output the result of the expression evaluation to the output stream\n    if (this.outputWhenComplete) {\n      container.AddContent(RuntimeControlCommand.EvalOutput());\n    }\n\n    // Tell Runtime to stop evaluating the content as an expression\n    container.AddContent(RuntimeControlCommand.EvalEnd());\n\n    return container;\n  };\n\n  // When generating the value of a constant expression,\n  // we can't just keep generating the same constant expression into\n  // different places where the constant value is referenced, since then\n  // the same runtime objects would be used in multiple places, which\n  // is impossible since each runtime object should have one parent.\n  // Instead, we generate a prototype of the runtime object(s), then\n  // copy them each time they're used.\n  public readonly GenerateConstantIntoContainer = (\n    container: RuntimeContainer\n  ): void => {\n    if (this._prototypeRuntimeConstantExpression === null) {\n      this._prototypeRuntimeConstantExpression = new RuntimeContainer();\n      this.GenerateIntoContainer(this._prototypeRuntimeConstantExpression);\n    }\n\n    for (const runtimeObj of this._prototypeRuntimeConstantExpression.content) {\n      const copy = runtimeObj.Copy();\n      if (copy) {\n        container.AddContent(copy);\n      }\n    }\n  };\n\n  public readonly toString = () => \"No string value in JavaScript.\";\n}\n","import { InkObject } from \"./Object\";\n\nexport class Void extends InkObject {}\n","import { Value, ValueType, IntValue, ListValue, BoolValue } from \"./Value\";\nimport { StoryException } from \"./StoryException\";\nimport { Void } from \"./Void\";\nimport { Path } from \"./Path\";\nimport { InkList, InkListItem } from \"./InkList\";\nimport { InkObject } from \"./Object\";\nimport { asOrNull, asOrThrows, asBooleanOrThrows } from \"./TypeAssertion\";\nimport { throwNullException } from \"./NullException\";\n\ntype BinaryOp<T> = (left: T, right: T) => any;\ntype UnaryOp<T> = (val: T) => any;\n\nexport class NativeFunctionCall extends InkObject {\n  public static readonly Add: string = \"+\";\n  public static readonly Subtract: string = \"-\";\n  public static readonly Divide: string = \"/\";\n  public static readonly Multiply: string = \"*\";\n  public static readonly Mod: string = \"%\";\n  public static readonly Negate: string = \"_\";\n  public static readonly Equal: string = \"==\";\n  public static readonly Greater: string = \">\";\n  public static readonly Less: string = \"<\";\n  public static readonly GreaterThanOrEquals: string = \">=\";\n  public static readonly LessThanOrEquals: string = \"<=\";\n  public static readonly NotEquals: string = \"!=\";\n  public static readonly Not: string = \"!\";\n  public static readonly And: string = \"&&\";\n  public static readonly Or: string = \"||\";\n  public static readonly Min: string = \"MIN\";\n  public static readonly Max: string = \"MAX\";\n  public static readonly Pow: string = \"POW\";\n  public static readonly Floor: string = \"FLOOR\";\n  public static readonly Ceiling: string = \"CEILING\";\n  public static readonly Int: string = \"INT\";\n  public static readonly Float: string = \"FLOAT\";\n  public static readonly Has: string = \"?\";\n  public static readonly Hasnt: string = \"!?\";\n  public static readonly Intersect: string = \"^\";\n  public static readonly ListMin: string = \"LIST_MIN\";\n  public static readonly ListMax: string = \"LIST_MAX\";\n  public static readonly All: string = \"LIST_ALL\";\n  public static readonly Count: string = \"LIST_COUNT\";\n  public static readonly ValueOfList: string = \"LIST_VALUE\";\n  public static readonly Invert: string = \"LIST_INVERT\";\n\n  public static CallWithName(functionName: string) {\n    return new NativeFunctionCall(functionName);\n  }\n\n  public static CallExistsWithName(functionName: string) {\n    this.GenerateNativeFunctionsIfNecessary();\n    return this._nativeFunctions!.get(functionName);\n  }\n\n  get name() {\n    if (this._name === null)\n      return throwNullException(\"NativeFunctionCall._name\");\n    return this._name;\n  }\n  set name(value: string) {\n    this._name = value;\n    if (!this._isPrototype) {\n      if (NativeFunctionCall._nativeFunctions === null)\n        throwNullException(\"NativeFunctionCall._nativeFunctions\");\n      else\n        this._prototype =\n          NativeFunctionCall._nativeFunctions.get(this._name) || null;\n    }\n  }\n  public _name: string | null = null;\n\n  get numberOfParameters() {\n    if (this._prototype) {\n      return this._prototype.numberOfParameters;\n    } else {\n      return this._numberOfParameters;\n    }\n  }\n  set numberOfParameters(value: number) {\n    this._numberOfParameters = value;\n  }\n  public _numberOfParameters: number = 0;\n\n  public Call(parameters: InkObject[]): InkObject | null {\n    if (this._prototype) {\n      return this._prototype.Call(parameters);\n    }\n\n    if (this.numberOfParameters != parameters.length) {\n      throw new Error(\"Unexpected number of parameters\");\n    }\n\n    let hasList = false;\n    for (let p of parameters) {\n      if (p instanceof Void)\n        throw new StoryException(\n          'Attempting to perform operation on a void value. Did you forget to \"return\" a value from a function you called here?'\n        );\n      if (p instanceof ListValue) hasList = true;\n    }\n\n    if (parameters.length == 2 && hasList) {\n      return this.CallBinaryListOperation(parameters);\n    }\n\n    let coercedParams = this.CoerceValuesToSingleType(parameters);\n    let coercedType = coercedParams[0].valueType;\n\n    if (coercedType == ValueType.Int) {\n      return this.CallType<number>(coercedParams);\n    } else if (coercedType == ValueType.Float) {\n      return this.CallType<number>(coercedParams);\n    } else if (coercedType == ValueType.String) {\n      return this.CallType<string>(coercedParams);\n    } else if (coercedType == ValueType.DivertTarget) {\n      return this.CallType<Path>(coercedParams);\n    } else if (coercedType == ValueType.List) {\n      return this.CallType<InkList>(coercedParams);\n    }\n\n    return null;\n  }\n\n  public CallType<T>(parametersOfSingleType: Array<Value<T>>) {\n    let param1 = asOrThrows(parametersOfSingleType[0], Value);\n    let valType = param1.valueType;\n\n    let val1 = param1 as Value<T>;\n\n    let paramCount = parametersOfSingleType.length;\n\n    if (paramCount == 2 || paramCount == 1) {\n      if (this._operationFuncs === null)\n        return throwNullException(\"NativeFunctionCall._operationFuncs\");\n      let opForTypeObj = this._operationFuncs.get(valType);\n      if (!opForTypeObj) {\n        const key = ValueType[valType];\n        throw new StoryException(\n          \"Cannot perform operation \" + this.name + \" on \" + key\n        );\n      }\n\n      if (paramCount == 2) {\n        let param2 = asOrThrows(parametersOfSingleType[1], Value);\n\n        let val2 = param2 as Value<T>;\n\n        let opForType = opForTypeObj as BinaryOp<T>;\n\n        if (val1.value === null || val2.value === null)\n          return throwNullException(\"NativeFunctionCall.Call BinaryOp values\");\n        let resultVal = opForType(val1.value, val2.value);\n\n        return Value.Create(resultVal);\n      } else {\n        let opForType = opForTypeObj as UnaryOp<T>;\n\n        if (val1.value === null)\n          return throwNullException(\"NativeFunctionCall.Call UnaryOp value\");\n        let resultVal = opForType(val1.value);\n\n        // This code is different from upstream. Since JavaScript treats\n        // integers and floats as the same numbers, it's impossible\n        // to force an number to be either an integer or a float.\n        //\n        // It can be useful to force a specific number type\n        // (especially for divisions), so the result of INT() & FLOAT()\n        // is coerced to the the proper value type.\n        //\n        // Note that we also force all other unary operation to\n        // return the same value type, although this is only\n        // meaningful for numbers. See `Value.Create`.\n        if (this.name === NativeFunctionCall.Int) {\n          return Value.Create(resultVal, ValueType.Int);\n        } else if (this.name === NativeFunctionCall.Float) {\n          return Value.Create(resultVal, ValueType.Float);\n        } else {\n          return Value.Create(resultVal, param1.valueType);\n        }\n      }\n    } else {\n      throw new Error(\n        \"Unexpected number of parameters to NativeFunctionCall: \" +\n          parametersOfSingleType.length\n      );\n    }\n  }\n\n  public CallBinaryListOperation(parameters: InkObject[]) {\n    if (\n      (this.name == \"+\" || this.name == \"-\") &&\n      parameters[0] instanceof ListValue &&\n      parameters[1] instanceof IntValue\n    )\n      return this.CallListIncrementOperation(parameters);\n\n    let v1 = asOrThrows(parameters[0], Value);\n    let v2 = asOrThrows(parameters[1], Value);\n\n    if (\n      (this.name == \"&&\" || this.name == \"||\") &&\n      (v1.valueType != ValueType.List || v2.valueType != ValueType.List)\n    ) {\n      if (this._operationFuncs === null)\n        return throwNullException(\"NativeFunctionCall._operationFuncs\");\n      let op = this._operationFuncs.get(ValueType.Int) as BinaryOp<number>;\n      if (op === null)\n        return throwNullException(\n          \"NativeFunctionCall.CallBinaryListOperation op\"\n        );\n      let result = asBooleanOrThrows(\n        op(v1.isTruthy ? 1 : 0, v2.isTruthy ? 1 : 0)\n      );\n      return new BoolValue(result);\n    }\n\n    if (v1.valueType == ValueType.List && v2.valueType == ValueType.List)\n      return this.CallType<InkList>([v1, v2]);\n\n    throw new StoryException(\n      \"Can not call use \" +\n        this.name +\n        \" operation on \" +\n        ValueType[v1.valueType] +\n        \" and \" +\n        ValueType[v2.valueType]\n    );\n  }\n\n  public CallListIncrementOperation(listIntParams: InkObject[]) {\n    let listVal = asOrThrows(listIntParams[0], ListValue);\n    let intVal = asOrThrows(listIntParams[1], IntValue);\n\n    let resultInkList = new InkList();\n\n    if (listVal.value === null)\n      return throwNullException(\n        \"NativeFunctionCall.CallListIncrementOperation listVal.value\"\n      );\n    for (let [listItemKey, listItemValue] of listVal.value) {\n      let listItem = InkListItem.fromSerializedKey(listItemKey);\n\n      if (this._operationFuncs === null)\n        return throwNullException(\"NativeFunctionCall._operationFuncs\");\n      let intOp = this._operationFuncs.get(ValueType.Int) as BinaryOp<number>;\n\n      if (intVal.value === null)\n        return throwNullException(\n          \"NativeFunctionCall.CallListIncrementOperation intVal.value\"\n        );\n      let targetInt = intOp(listItemValue, intVal.value);\n\n      let itemOrigin = null;\n      if (listVal.value.origins === null)\n        return throwNullException(\n          \"NativeFunctionCall.CallListIncrementOperation listVal.value.origins\"\n        );\n      for (let origin of listVal.value.origins) {\n        if (origin.name == listItem.originName) {\n          itemOrigin = origin;\n          break;\n        }\n      }\n      if (itemOrigin != null) {\n        let incrementedItem = itemOrigin.TryGetItemWithValue(\n          targetInt,\n          InkListItem.Null\n        );\n        if (incrementedItem.exists)\n          resultInkList.Add(incrementedItem.result, targetInt);\n      }\n    }\n\n    return new ListValue(resultInkList);\n  }\n\n  public CoerceValuesToSingleType(parametersIn: InkObject[]) {\n    let valType = ValueType.Int;\n\n    let specialCaseList: null | ListValue = null;\n\n    for (let obj of parametersIn) {\n      let val = asOrThrows(obj, Value);\n      if (val.valueType > valType) {\n        valType = val.valueType;\n      }\n\n      if (val.valueType == ValueType.List) {\n        specialCaseList = asOrNull(val, ListValue);\n      }\n    }\n\n    let parametersOut = [];\n\n    if (ValueType[valType] == ValueType[ValueType.List]) {\n      for (let inkObjectVal of parametersIn) {\n        let val = asOrThrows(inkObjectVal, Value);\n        if (val.valueType == ValueType.List) {\n          parametersOut.push(val);\n        } else if (val.valueType == ValueType.Int) {\n          let intVal = parseInt(val.valueObject);\n\n          specialCaseList = asOrThrows(specialCaseList, ListValue);\n          if (specialCaseList.value === null)\n            return throwNullException(\n              \"NativeFunctionCall.CoerceValuesToSingleType specialCaseList.value\"\n            );\n          let list = specialCaseList.value.originOfMaxItem;\n\n          if (list === null)\n            return throwNullException(\n              \"NativeFunctionCall.CoerceValuesToSingleType list\"\n            );\n          let item = list.TryGetItemWithValue(intVal, InkListItem.Null);\n          if (item.exists) {\n            let castedValue = new ListValue(item.result, intVal);\n            parametersOut.push(castedValue);\n          } else\n            throw new StoryException(\n              \"Could not find List item with the value \" +\n                intVal +\n                \" in \" +\n                list.name\n            );\n        } else {\n          const key = ValueType[val.valueType];\n          throw new StoryException(\n            \"Cannot mix Lists and \" + key + \" values in this operation\"\n          );\n        }\n      }\n    } else {\n      for (let inkObjectVal of parametersIn) {\n        let val = asOrThrows(inkObjectVal, Value);\n        let castedValue = val.Cast(valType);\n        parametersOut.push(castedValue);\n      }\n    }\n\n    return parametersOut;\n  }\n\n  constructor(name: string);\n  constructor(name: string, numberOfParameters: number);\n  constructor();\n  constructor() {\n    super();\n\n    if (arguments.length === 0) {\n      NativeFunctionCall.GenerateNativeFunctionsIfNecessary();\n    } else if (arguments.length === 1) {\n      let name = arguments[0];\n      NativeFunctionCall.GenerateNativeFunctionsIfNecessary();\n      this.name = name;\n    } else if (arguments.length === 2) {\n      let name = arguments[0];\n      let numberOfParameters = arguments[1];\n\n      this._isPrototype = true;\n      this.name = name;\n      this.numberOfParameters = numberOfParameters;\n    }\n  }\n\n  public static Identity<T>(t: T): any {\n    return t;\n  }\n\n  public static GenerateNativeFunctionsIfNecessary() {\n    if (this._nativeFunctions == null) {\n      this._nativeFunctions = new Map();\n\n      // Int operations\n      this.AddIntBinaryOp(this.Add, (x, y) => x + y);\n      this.AddIntBinaryOp(this.Subtract, (x, y) => x - y);\n      this.AddIntBinaryOp(this.Multiply, (x, y) => x * y);\n      this.AddIntBinaryOp(this.Divide, (x, y) => Math.floor(x / y));\n      this.AddIntBinaryOp(this.Mod, (x, y) => x % y);\n      this.AddIntUnaryOp(this.Negate, (x) => -x);\n\n      this.AddIntBinaryOp(this.Equal, (x, y) => x == y);\n      this.AddIntBinaryOp(this.Greater, (x, y) => x > y);\n      this.AddIntBinaryOp(this.Less, (x, y) => x < y);\n      this.AddIntBinaryOp(this.GreaterThanOrEquals, (x, y) => x >= y);\n      this.AddIntBinaryOp(this.LessThanOrEquals, (x, y) => x <= y);\n      this.AddIntBinaryOp(this.NotEquals, (x, y) => x != y);\n      this.AddIntUnaryOp(this.Not, (x) => x == 0);\n\n      this.AddIntBinaryOp(this.And, (x, y) => x != 0 && y != 0);\n      this.AddIntBinaryOp(this.Or, (x, y) => x != 0 || y != 0);\n\n      this.AddIntBinaryOp(this.Max, (x, y) => Math.max(x, y));\n      this.AddIntBinaryOp(this.Min, (x, y) => Math.min(x, y));\n\n      this.AddIntBinaryOp(this.Pow, (x, y) => Math.pow(x, y));\n      this.AddIntUnaryOp(this.Floor, NativeFunctionCall.Identity);\n      this.AddIntUnaryOp(this.Ceiling, NativeFunctionCall.Identity);\n      this.AddIntUnaryOp(this.Int, NativeFunctionCall.Identity);\n      this.AddIntUnaryOp(this.Float, (x) => x);\n\n      // Float operations\n      this.AddFloatBinaryOp(this.Add, (x, y) => x + y);\n      this.AddFloatBinaryOp(this.Subtract, (x, y) => x - y);\n      this.AddFloatBinaryOp(this.Multiply, (x, y) => x * y);\n      this.AddFloatBinaryOp(this.Divide, (x, y) => x / y);\n      this.AddFloatBinaryOp(this.Mod, (x, y) => x % y);\n      this.AddFloatUnaryOp(this.Negate, (x) => -x);\n\n      this.AddFloatBinaryOp(this.Equal, (x, y) => x == y);\n      this.AddFloatBinaryOp(this.Greater, (x, y) => x > y);\n      this.AddFloatBinaryOp(this.Less, (x, y) => x < y);\n      this.AddFloatBinaryOp(this.GreaterThanOrEquals, (x, y) => x >= y);\n      this.AddFloatBinaryOp(this.LessThanOrEquals, (x, y) => x <= y);\n      this.AddFloatBinaryOp(this.NotEquals, (x, y) => x != y);\n      this.AddFloatUnaryOp(this.Not, (x) => x == 0.0);\n\n      this.AddFloatBinaryOp(this.And, (x, y) => x != 0.0 && y != 0.0);\n      this.AddFloatBinaryOp(this.Or, (x, y) => x != 0.0 || y != 0.0);\n\n      this.AddFloatBinaryOp(this.Max, (x, y) => Math.max(x, y));\n      this.AddFloatBinaryOp(this.Min, (x, y) => Math.min(x, y));\n\n      this.AddFloatBinaryOp(this.Pow, (x, y) => Math.pow(x, y));\n      this.AddFloatUnaryOp(this.Floor, (x) => Math.floor(x));\n      this.AddFloatUnaryOp(this.Ceiling, (x) => Math.ceil(x));\n      this.AddFloatUnaryOp(this.Int, (x) => Math.floor(x));\n      this.AddFloatUnaryOp(this.Float, NativeFunctionCall.Identity);\n\n      // String operations\n      this.AddStringBinaryOp(this.Add, (x, y) => x + y); // concat\n      this.AddStringBinaryOp(this.Equal, (x, y) => x === y);\n      this.AddStringBinaryOp(this.NotEquals, (x, y) => !(x === y));\n      this.AddStringBinaryOp(this.Has, (x, y) => x.includes(y));\n      this.AddStringBinaryOp(this.Hasnt, (x, y) => !x.includes(y));\n\n      this.AddListBinaryOp(this.Add, (x, y) => x.Union(y));\n      this.AddListBinaryOp(this.Subtract, (x, y) => x.Without(y));\n      this.AddListBinaryOp(this.Has, (x, y) => x.Contains(y));\n      this.AddListBinaryOp(this.Hasnt, (x, y) => !x.Contains(y));\n      this.AddListBinaryOp(this.Intersect, (x, y) => x.Intersect(y));\n\n      this.AddListBinaryOp(this.Equal, (x, y) => x.Equals(y));\n      this.AddListBinaryOp(this.Greater, (x, y) => x.GreaterThan(y));\n      this.AddListBinaryOp(this.Less, (x, y) => x.LessThan(y));\n      this.AddListBinaryOp(this.GreaterThanOrEquals, (x, y) =>\n        x.GreaterThanOrEquals(y)\n      );\n      this.AddListBinaryOp(this.LessThanOrEquals, (x, y) =>\n        x.LessThanOrEquals(y)\n      );\n      this.AddListBinaryOp(this.NotEquals, (x, y) => !x.Equals(y));\n\n      this.AddListBinaryOp(this.And, (x, y) => x.Count > 0 && y.Count > 0);\n      this.AddListBinaryOp(this.Or, (x, y) => x.Count > 0 || y.Count > 0);\n\n      this.AddListUnaryOp(this.Not, (x) => (x.Count == 0 ? 1 : 0));\n\n      this.AddListUnaryOp(this.Invert, (x) => x.inverse);\n      this.AddListUnaryOp(this.All, (x) => x.all);\n      this.AddListUnaryOp(this.ListMin, (x) => x.MinAsList());\n      this.AddListUnaryOp(this.ListMax, (x) => x.MaxAsList());\n      this.AddListUnaryOp(this.Count, (x) => x.Count);\n      this.AddListUnaryOp(this.ValueOfList, (x) => x.maxItem.Value);\n\n      let divertTargetsEqual = (d1: Path, d2: Path) => d1.Equals(d2);\n      let divertTargetsNotEqual = (d1: Path, d2: Path) => !d1.Equals(d2);\n      this.AddOpToNativeFunc(\n        this.Equal,\n        2,\n        ValueType.DivertTarget,\n        divertTargetsEqual\n      );\n      this.AddOpToNativeFunc(\n        this.NotEquals,\n        2,\n        ValueType.DivertTarget,\n        divertTargetsNotEqual\n      );\n    }\n  }\n\n  public AddOpFuncForType(\n    valType: ValueType,\n    op: UnaryOp<number | InkList> | BinaryOp<number | string | InkList | Path>\n  ): void {\n    if (this._operationFuncs == null) {\n      this._operationFuncs = new Map();\n    }\n\n    this._operationFuncs.set(valType, op);\n  }\n\n  public static AddOpToNativeFunc(\n    name: string,\n    args: number,\n    valType: ValueType,\n    op: UnaryOp<any> | BinaryOp<any>\n  ): void {\n    if (this._nativeFunctions === null)\n      return throwNullException(\"NativeFunctionCall._nativeFunctions\");\n    let nativeFunc = this._nativeFunctions.get(name);\n    if (!nativeFunc) {\n      nativeFunc = new NativeFunctionCall(name, args);\n      this._nativeFunctions.set(name, nativeFunc);\n    }\n\n    nativeFunc.AddOpFuncForType(valType, op);\n  }\n\n  public static AddIntBinaryOp(name: string, op: BinaryOp<number>) {\n    this.AddOpToNativeFunc(name, 2, ValueType.Int, op);\n  }\n  public static AddIntUnaryOp(name: string, op: UnaryOp<number>) {\n    this.AddOpToNativeFunc(name, 1, ValueType.Int, op);\n  }\n\n  public static AddFloatBinaryOp(name: string, op: BinaryOp<number>) {\n    this.AddOpToNativeFunc(name, 2, ValueType.Float, op);\n  }\n  public static AddFloatUnaryOp(name: string, op: UnaryOp<number>) {\n    this.AddOpToNativeFunc(name, 1, ValueType.Float, op);\n  }\n\n  public static AddStringBinaryOp(name: string, op: BinaryOp<string>) {\n    this.AddOpToNativeFunc(name, 2, ValueType.String, op);\n  }\n\n  public static AddListBinaryOp(name: string, op: BinaryOp<InkList>) {\n    this.AddOpToNativeFunc(name, 2, ValueType.List, op);\n  }\n  public static AddListUnaryOp(name: string, op: UnaryOp<InkList>) {\n    this.AddOpToNativeFunc(name, 1, ValueType.List, op);\n  }\n\n  public toString() {\n    return 'Native \"' + this.name + '\"';\n  }\n\n  public _prototype: NativeFunctionCall | null = null;\n  public _isPrototype: boolean = false;\n  public _operationFuncs: Map<\n    ValueType,\n    BinaryOp<any> | UnaryOp<any>\n  > | null = null;\n  public static _nativeFunctions: Map<string, NativeFunctionCall> | null = null;\n}\n","import { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { Expression } from \"./Expression\";\nimport { BoolValue, FloatValue, IntValue } from \"../../../../engine/Value\";\n\nexport class NumberExpression extends Expression {\n  public value: number | boolean;\n  public subtype: \"int\" | \"float\" | \"bool\";\n\n  constructor(value: number | boolean, subtype: \"int\" | \"float\" | \"bool\") {\n    super();\n\n    if (\n      (typeof value === \"number\" && !Number.isNaN(value)) ||\n      typeof value == \"boolean\"\n    ) {\n      this.value = value;\n      this.subtype = subtype;\n    } else {\n      throw new Error(\"Unexpected object type in NumberExpression.\");\n    }\n  }\n\n  public isInt = (): boolean => this.subtype == \"int\";\n\n  public isFloat = (): boolean => this.subtype == \"float\";\n\n  public isBool = (): boolean => this.subtype == \"bool\";\n\n  public readonly GenerateIntoContainer = (\n    container: RuntimeContainer\n  ): void => {\n    if (this.isInt()) {\n      container.AddContent(new IntValue(this.value as number));\n    } else if (this.isFloat()) {\n      container.AddContent(new FloatValue(this.value as number));\n    } else if (this.isBool()) {\n      container.AddContent(new BoolValue(this.value as boolean));\n    }\n  };\n\n  public readonly toString = (): string => String(this.value);\n}\n","import { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { Expression } from \"./Expression\";\nimport { NativeFunctionCall } from \"../../../../engine/NativeFunctionCall\";\nimport { NumberExpression } from \"./NumberExpression\";\nimport { asOrNull } from \"../../../../engine/TypeAssertion\";\n\nexport class UnaryExpression extends Expression {\n  get nativeNameForOp(): string {\n    // Replace \"-\" with \"_\" to make it unique (compared to subtraction)\n    if (this.op === \"-\") {\n      return \"_\";\n    } else if (this.op === \"not\") {\n      return \"!\";\n    }\n\n    return this.op;\n  }\n\n  public innerExpression: Expression;\n\n  // Attempt to flatten inner expression immediately\n  // e.g. convert (-(5)) into (-5)\n  public static readonly WithInner = (\n    inner: Expression,\n    op: string\n  ): Expression => {\n    const innerNumber = asOrNull(inner, NumberExpression);\n\n    if (innerNumber) {\n      if (op === \"-\") {\n        if (innerNumber.isInt()) {\n          return new NumberExpression(-innerNumber.value, \"int\");\n        } else if (innerNumber.isFloat()) {\n          return new NumberExpression(-innerNumber.value, \"float\");\n        }\n      } else if (op == \"!\" || op == \"not\") {\n        if (innerNumber.isInt()) {\n          return new NumberExpression(innerNumber.value == 0, \"bool\");\n        } else if (innerNumber.isFloat()) {\n          return new NumberExpression(innerNumber.value == 0.0, \"bool\");\n        } else if (innerNumber.isBool()) {\n          return new NumberExpression(!innerNumber.value, \"bool\");\n        }\n      }\n\n      throw new Error(\"Unexpected operation or number type\");\n    }\n\n    // Normal fallback\n    const unary = new UnaryExpression(inner, op);\n\n    return unary;\n  };\n\n  constructor(inner: Expression, public readonly op: string) {\n    super();\n\n    this.innerExpression = this.AddContent(inner) as Expression;\n  }\n\n  public readonly GenerateIntoContainer = (container: RuntimeContainer) => {\n    this.innerExpression.GenerateIntoContainer(container);\n    container.AddContent(NativeFunctionCall.CallWithName(this.nativeNameForOp));\n  };\n\n  public readonly toString = (): string =>\n    this.nativeNameForOp + this.innerExpression;\n}\n","import { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { Expression } from \"./Expression\";\nimport { NativeFunctionCall } from \"../../../../engine/NativeFunctionCall\";\nimport { Story } from \"../Story\";\nimport { UnaryExpression } from \"./UnaryExpression\";\nimport { asOrNull } from \"../../../../engine/TypeAssertion\";\n\nexport class BinaryExpression extends Expression {\n  public readonly leftExpression: Expression;\n  public readonly rightExpression: Expression;\n\n  constructor(left: Expression, right: Expression, public opName: string) {\n    super();\n\n    this.leftExpression = this.AddContent(left) as Expression;\n    this.rightExpression = this.AddContent(right) as Expression;\n\n    this.opName = opName;\n  }\n\n  public readonly GenerateIntoContainer = (container: RuntimeContainer) => {\n    this.leftExpression.GenerateIntoContainer(container);\n    this.rightExpression.GenerateIntoContainer(container);\n    this.opName = this.NativeNameForOp(this.opName);\n    container.AddContent(NativeFunctionCall.CallWithName(this.opName));\n  };\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n\n    // Check for the following case:\n    //\n    //    (not A) ? B\n    //\n    // Since this easy to accidentally do:\n    //\n    //    not A ? B\n    //\n    // when you intend:\n    //\n    //    not (A ? B)\n    if (this.NativeNameForOp(this.opName) === \"?\") {\n      const leftUnary = asOrNull(this.leftExpression, UnaryExpression);\n      if (\n        leftUnary !== null &&\n        (leftUnary.op === \"not\" || leftUnary.op === \"!\")\n      ) {\n        this.Error(\n          `Using 'not' or '!' here negates '${leftUnary.innerExpression}' rather than the result of the '?' or 'has' operator. You need to add parentheses around the (A ? B) expression.`\n        );\n      }\n    }\n  }\n\n  public readonly NativeNameForOp = (opName: string): string => {\n    if (opName === \"and\") {\n      return \"&&\";\n    } else if (opName === \"or\") {\n      return \"||\";\n    } else if (opName === \"mod\") {\n      return \"%\";\n    } else if (opName === \"has\") {\n      return \"?\";\n    } else if (opName === \"hasnt\") {\n      return \"!?\";\n    }\n\n    return opName;\n  };\n\n  public readonly toString = (): string =>\n    `(${this.leftExpression} ${this.opName} ${this.rightExpression})`;\n}\n","export class CharacterSet {\n  public static readonly FromRange = (\n    start: string,\n    end: string\n  ): CharacterSet => new CharacterSet().AddRange(start, end);\n\n  public set: Set<string> = new Set<string>();\n\n  constructor(arg?: string | string[] | CharacterSet) {\n    if (arg) {\n      this.AddCharacters(arg);\n    }\n  }\n\n  public readonly Add = (arg: string) => this.set.add(arg);\n\n  public readonly AddRange = (start: string, end: string): CharacterSet => {\n    for (let c = start.charCodeAt(0); c <= end.charCodeAt(0); ++c) {\n      this.Add(String.fromCharCode(c));\n    }\n\n    return this;\n  };\n\n  public readonly AddCharacters = (\n    chars: string | string[] | CharacterSet\n  ): CharacterSet => {\n    if (typeof chars === \"string\" || Array.isArray(chars)) {\n      for (const c of chars) {\n        this.Add(c);\n      }\n    } else {\n      for (const c of chars.set) {\n        this.Add(c);\n      }\n    }\n\n    return this;\n  };\n}\n","import { CharacterSet } from \"./CharacterSet\";\n\n/// <summary>\n/// A class representing a character range. Allows for lazy-loading a corresponding <see cref=\"CharacterSet\">character set</see>.\n/// </summary>\nexport class CharacterRange {\n  public static Define = (\n    start: string,\n    end: string,\n    excludes: string[] | CharacterSet = []\n  ): CharacterRange => new CharacterRange(start, end, excludes);\n\n  private _correspondingCharSet: CharacterSet = new CharacterSet();\n  private _excludes = new Set<string>();\n\n  constructor(\n    private _start: string,\n    private _end: string,\n    excludes: string[] | CharacterSet = []\n  ) {\n    if (excludes instanceof CharacterSet) {\n      this._excludes = excludes.set;\n    } else {\n      for (const item of excludes) {\n        this._excludes.add(item);\n      }\n    }\n  }\n\n  get start(): string {\n    return this._start;\n  }\n\n  get end(): string {\n    return this._end;\n  }\n\n  /// <summary>\n  /// Returns a <see cref=\"CharacterSet\">character set</see> instance corresponding to the character range\n  /// represented by the current instance.\n  /// </summary>\n  /// <remarks>\n  /// The internal character set is created once and cached in memory.\n  /// </remarks>\n  /// <returns>The char set.</returns>\n  public readonly ToCharacterSet = (): CharacterSet => {\n    if (this._correspondingCharSet.set.size === 0) {\n      for (\n        let ii = this.start.charCodeAt(0), c = String.fromCharCode(ii);\n        ii <= this.end.charCodeAt(0);\n        ii += 1\n      ) {\n        if (!this._excludes.has(c)) {\n          this._correspondingCharSet.AddCharacters(c);\n        }\n      }\n    }\n\n    return this._correspondingCharSet;\n  };\n}\n","export enum PushPopType {\n  Tunnel = 0,\n  Function = 1,\n  FunctionEvaluationFromGame = 2,\n}\n","import { InkObject } from \"./Object\";\nimport { Path } from \"./Path\";\nimport { Container } from \"./Container\";\nimport { throwNullException } from \"./NullException\";\n\nexport class ChoicePoint extends InkObject {\n  public _pathOnChoice: Path | null = null;\n  public hasCondition: boolean = false;\n  public hasStartContent: boolean = false;\n  public hasChoiceOnlyContent: boolean = false;\n  public isInvisibleDefault: boolean = false;\n  public onceOnly: boolean = true;\n\n  constructor(onceOnly: boolean = true) {\n    super();\n    this.onceOnly = onceOnly;\n  }\n  get pathOnChoice(): Path | null {\n    if (this._pathOnChoice != null && this._pathOnChoice.isRelative) {\n      let choiceTargetObj = this.choiceTarget;\n      if (choiceTargetObj) {\n        this._pathOnChoice = choiceTargetObj.path;\n      }\n    }\n    return this._pathOnChoice;\n  }\n  set pathOnChoice(value: Path | null) {\n    this._pathOnChoice = value;\n  }\n  get choiceTarget(): Container | null {\n    if (this._pathOnChoice === null)\n      return throwNullException(\"ChoicePoint._pathOnChoice\");\n    return this.ResolvePath(this._pathOnChoice).container;\n  }\n  get pathStringOnChoice(): string {\n    if (this.pathOnChoice === null)\n      return throwNullException(\"ChoicePoint.pathOnChoice\");\n    return this.CompactPathString(this.pathOnChoice);\n  }\n  set pathStringOnChoice(value: string) {\n    this.pathOnChoice = new Path(value);\n  }\n  get flags(): number {\n    let flags = 0;\n    if (this.hasCondition) flags |= 1;\n    if (this.hasStartContent) flags |= 2;\n    if (this.hasChoiceOnlyContent) flags |= 4;\n    if (this.isInvisibleDefault) flags |= 8;\n    if (this.onceOnly) flags |= 16;\n    return flags;\n  }\n  set flags(value: number) {\n    this.hasCondition = (value & 1) > 0;\n    this.hasStartContent = (value & 2) > 0;\n    this.hasChoiceOnlyContent = (value & 4) > 0;\n    this.isInvisibleDefault = (value & 8) > 0;\n    this.onceOnly = (value & 16) > 0;\n  }\n  public toString(): string {\n    if (this.pathOnChoice === null)\n      return throwNullException(\"ChoicePoint.pathOnChoice\");\n    // int? targetLineNum = DebugLineNumberOfPath (pathOnChoice);\n    let targetLineNum = null;\n    let targetString = this.pathOnChoice.toString();\n\n    if (targetLineNum != null) {\n      targetString = \" line \" + targetLineNum + \"(\" + targetString + \")\";\n    }\n\n    return \"Choice: -> \" + targetString;\n  }\n}\n","export enum SymbolType {\n  Arg = 0,\n  Knot = 1,\n  List = 2,\n  ListItem = 3,\n  SubFlowAndWeave = 4,\n  Temp = 5,\n  Var = 6,\n}\n","import { Path } from \"./Path\";\nimport { Container } from \"./Container\";\nimport { InkObject } from \"./Object\";\n\nexport class Pointer {\n  public container: Container | null = null;\n  public index: number = -1;\n\n  constructor();\n  constructor(container: Container | null, index: number);\n  constructor() {\n    if (arguments.length === 2) {\n      this.container = arguments[0];\n      this.index = arguments[1];\n    }\n  }\n\n  public Resolve(): InkObject | null {\n    if (this.index < 0) return this.container;\n    if (this.container == null) return null;\n    if (this.container.content.length == 0) return this.container;\n    if (this.index >= this.container.content.length) return null;\n\n    return this.container.content[this.index];\n  }\n\n  get isNull(): boolean {\n    return this.container == null;\n  }\n\n  get path(): Path | null {\n    if (this.isNull) return null;\n\n    if (this.index >= 0)\n      return this.container!.path.PathByAppendingComponent(\n        new Path.Component(this.index)\n      );\n    else return this.container!.path;\n  }\n\n  public toString(): string {\n    if (!this.container) return \"Ink Pointer (null)\";\n\n    return (\n      \"Ink Pointer -> \" +\n      this.container.path.toString() +\n      \" -- index \" +\n      this.index\n    );\n  }\n\n  // This method does not exist in the original C# code, but is here to maintain the\n  // value semantics of Pointer.\n  public copy(): Pointer {\n    return new Pointer(this.container, this.index);\n  }\n\n  public static StartOf(container: Container | null): Pointer {\n    return new Pointer(container, 0);\n  }\n\n  public static get Null(): Pointer {\n    return new Pointer(null, -1);\n  }\n}\n","import { Path } from \"./Path\";\nimport { PushPopType } from \"./PushPop\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { InkObject } from \"./Object\";\nimport { Pointer } from \"./Pointer\";\nimport { Container } from \"./Container\";\nimport { throwNullException } from \"./NullException\";\n\nexport class Divert extends InkObject {\n  get targetPath() {\n    if (this._targetPath != null && this._targetPath.isRelative) {\n      let targetObj = this.targetPointer.Resolve();\n      if (targetObj) {\n        this._targetPath = targetObj.path;\n      }\n    }\n\n    return this._targetPath;\n  }\n  set targetPath(value: Path | null) {\n    this._targetPath = value;\n    this._targetPointer = Pointer.Null;\n  }\n\n  public _targetPath: Path | null = null;\n\n  get targetPointer() {\n    if (this._targetPointer.isNull) {\n      let targetObj = this.ResolvePath(this._targetPath).obj;\n\n      if (this._targetPath === null)\n        return throwNullException(\"this._targetPath\");\n      if (this._targetPath.lastComponent === null)\n        return throwNullException(\"this._targetPath.lastComponent\");\n\n      if (this._targetPath.lastComponent.isIndex) {\n        if (targetObj === null) return throwNullException(\"targetObj\");\n        this._targetPointer.container =\n          targetObj.parent instanceof Container ? targetObj.parent : null;\n        this._targetPointer.index = this._targetPath.lastComponent.index;\n      } else {\n        this._targetPointer = Pointer.StartOf(\n          targetObj instanceof Container ? targetObj : null\n        );\n      }\n    }\n\n    return this._targetPointer.copy();\n  }\n\n  public _targetPointer: Pointer = Pointer.Null;\n\n  get targetPathString() {\n    if (this.targetPath == null) return null;\n\n    return this.CompactPathString(this.targetPath);\n  }\n  set targetPathString(value: string | null) {\n    if (value == null) {\n      this.targetPath = null;\n    } else {\n      this.targetPath = new Path(value);\n    }\n  }\n\n  public variableDivertName: string | null = null;\n  get hasVariableTarget() {\n    return this.variableDivertName != null;\n  }\n\n  public pushesToStack: boolean = false;\n  public stackPushType: PushPopType = 0;\n\n  public isExternal: boolean = false;\n  public externalArgs: number = 0;\n\n  public isConditional: boolean = false;\n\n  constructor(stackPushType?: PushPopType) {\n    super();\n    this.pushesToStack = false;\n\n    if (typeof stackPushType !== \"undefined\") {\n      this.pushesToStack = true;\n      this.stackPushType = stackPushType;\n    }\n  }\n\n  public Equals(obj: Divert | null) {\n    let otherDivert = obj;\n    if (otherDivert instanceof Divert) {\n      if (this.hasVariableTarget == otherDivert.hasVariableTarget) {\n        if (this.hasVariableTarget) {\n          return this.variableDivertName == otherDivert.variableDivertName;\n        } else {\n          if (this.targetPath === null)\n            return throwNullException(\"this.targetPath\");\n          return this.targetPath.Equals(otherDivert.targetPath);\n        }\n      }\n    }\n    return false;\n  }\n\n  public toString() {\n    if (this.hasVariableTarget) {\n      return \"Divert(variable: \" + this.variableDivertName + \")\";\n    } else if (this.targetPath == null) {\n      return \"Divert(null)\";\n    } else {\n      let sb = new StringBuilder();\n\n      let targetStr = this.targetPath.toString();\n      // int? targetLineNum = DebugLineNumberOfPath (targetPath);\n      let targetLineNum = null;\n      if (targetLineNum != null) {\n        targetStr = \"line \" + targetLineNum;\n      }\n\n      sb.Append(\"Divert\");\n\n      if (this.isConditional) sb.Append(\"?\");\n\n      if (this.pushesToStack) {\n        if (this.stackPushType == PushPopType.Function) {\n          sb.Append(\" function\");\n        } else {\n          sb.Append(\" tunnel\");\n        }\n      }\n\n      sb.Append(\" -> \");\n      sb.Append(this.targetPathString);\n\n      sb.Append(\" (\");\n      sb.Append(targetStr);\n      sb.Append(\")\");\n\n      return sb.toString();\n    }\n  }\n}\n","import { InkObject } from \"./Object\";\n\nexport class VariableAssignment extends InkObject {\n  public readonly variableName: string | null;\n  public readonly isNewDeclaration: boolean;\n  public isGlobal: boolean;\n\n  constructor(variableName: string | null, isNewDeclaration: boolean) {\n    super();\n    this.variableName = variableName || null;\n    this.isNewDeclaration = !!isNewDeclaration;\n    this.isGlobal = false;\n  }\n\n  public toString(): string {\n    return \"VarAssign to \" + this.variableName;\n  }\n}\n","import { ChoicePoint } from \"../../../engine/ChoicePoint\";\nimport { Container as RuntimeContainer } from \"../../../engine/Container\";\nimport { ContentList } from \"./ContentList\";\nimport { ControlCommand as RuntimeControlCommand } from \"../../../engine/ControlCommand\";\nimport { Divert as RuntimeDivert } from \"../../../engine/Divert\";\nimport { DivertTargetValue } from \"../../../engine/Value\";\nimport { INamedContent } from \"../../../engine/INamedContent\";\nimport { IWeavePoint } from \"./IWeavePoint\";\nimport { ParsedObject } from \"./Object\";\nimport { InkObject as RuntimeObject } from \"../../../engine/Object\";\nimport { Path as RuntimePath } from \"../../../engine/Path\";\nimport { Story } from \"./Story\";\nimport { SymbolType } from \"./SymbolType\";\nimport { VariableAssignment as RuntimeVariableAssignment } from \"../../../engine/VariableAssignment\";\nimport { Expression } from \"./Expression/Expression\";\nimport { Identifier } from \"./Identifier\";\n\nexport class Choice extends ParsedObject implements IWeavePoint, INamedContent {\n  private _condition: Expression | null = null;\n  private _innerContentContainer: RuntimeContainer | null = null;\n  private _outerContainer: RuntimeContainer | null = null;\n  private _runtimeChoice: ChoicePoint | null = null;\n  get runtimeChoice(): ChoicePoint {\n    if (!this._runtimeChoice) {\n      throw new Error();\n    }\n\n    return this._runtimeChoice;\n  }\n\n  private _returnToR1: DivertTargetValue | null = null;\n  private _returnToR2: DivertTargetValue | null = null;\n  private _r1Label: RuntimeContainer | null = null;\n  private _r2Label: RuntimeContainer | null = null;\n  private _divertToStartContentOuter: RuntimeDivert | null = null;\n  private _divertToStartContentInner: RuntimeDivert | null = null;\n  private _startContentRuntimeContainer: RuntimeContainer | null = null;\n\n  public startContent: ContentList;\n  public choiceOnlyContent: ContentList;\n  public innerContent: ContentList;\n  public identifier?: Identifier;\n  get name() {\n    return this.identifier?.name || null;\n  }\n  public onceOnly: boolean;\n  public isInvisibleDefault: boolean = false;\n  public indentationDepth: number;\n  public hasWeaveStyleInlineBrackets: boolean = false;\n\n  get condition() {\n    return this._condition;\n  }\n\n  set condition(value) {\n    this._condition = value;\n    if (value) {\n      this.AddContent(value as ParsedObject);\n    }\n  }\n\n  // Required for IWeavePoint interface\n  // Choice's target container. Used by weave to append any extra\n  // nested weave content into.\n  get runtimeContainer() {\n    return this._innerContentContainer;\n  }\n\n  get innerContentContainer() {\n    return this._innerContentContainer;\n  }\n\n  get containerForCounting() {\n    return this._innerContentContainer;\n  }\n\n  // Override runtimePath to point to the Choice's target content (after it's chosen),\n  // as opposed to the default implementation which would point to the choice itself\n  // (or it's outer container), which is what runtimeObject is.\n  get runtimePath(): RuntimePath {\n    if (!this.innerContentContainer || !this.innerContentContainer.path) {\n      throw new Error();\n    }\n\n    return this.innerContentContainer.path;\n  }\n\n  constructor(\n    startContent: ContentList,\n    choiceOnlyContent: ContentList,\n    innerContent: ContentList\n  ) {\n    super();\n\n    this.startContent = startContent;\n    this.choiceOnlyContent = choiceOnlyContent;\n    this.innerContent = innerContent;\n    this.indentationDepth = 1;\n\n    if (startContent) {\n      this.AddContent(this.startContent);\n    }\n\n    if (choiceOnlyContent) {\n      this.AddContent(this.choiceOnlyContent);\n    }\n\n    if (innerContent) {\n      this.AddContent(this.innerContent);\n    }\n\n    this.onceOnly = true; // default\n  }\n\n  get typeName(): string {\n    return \"Choice\";\n  }\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject => {\n    this._outerContainer = new RuntimeContainer();\n\n    // Content names for different types of choice:\n    //  * start content [choice only content] inner content\n    //  * start content   -> divert\n    //  * start content\n    //  * [choice only content]\n\n    // Hmm, this structure has become slightly insane!\n    //\n    // [\n    //     EvalStart\n    //     assign $r = $r1   -- return target = return label 1\n    //     BeginString\n    //     -> s\n    //     [(r1)]            -- return label 1 (after start content)\n    //     EndString\n    //     BeginString\n    //     ... choice only content\n    //     EndEval\n    //     Condition expression\n    //     choice: -> \"c-0\"\n    //     (s) = [\n    //         start content\n    //         -> r          -- goto return label 1 or 2\n    //     ]\n    //  ]\n    //\n    //  in parent's container: (the inner content for the choice)\n    //\n    //  (c-0) = [\n    //      EvalStart\n    //      assign $r = $r2   -- return target = return label 2\n    //      EndEval\n    //      -> s\n    //      [(r2)]            -- return label 1 (after start content)\n    //      inner content\n    //  ]\n    //\n\n    this._runtimeChoice = new ChoicePoint(this.onceOnly);\n    this._runtimeChoice.isInvisibleDefault = this.isInvisibleDefault;\n\n    if (this.startContent || this.choiceOnlyContent || this.condition) {\n      this._outerContainer.AddContent(RuntimeControlCommand.EvalStart());\n    }\n\n    // Start content is put into a named container that's referenced both\n    // when displaying the choice initially, and when generating the text\n    // when the choice is chosen.\n    if (this.startContent) {\n      // Generate start content and return\n      //  - We can't use a function since it uses a call stack element, which would\n      //    put temporary values out of scope. Instead we manually divert around.\n      //  - $r is a variable divert target contains the return point\n      this._returnToR1 = new DivertTargetValue();\n      this._outerContainer.AddContent(this._returnToR1);\n\n      const varAssign = new RuntimeVariableAssignment(\"$r\", true);\n      this._outerContainer.AddContent(varAssign);\n\n      // Mark the start of the choice text generation, so that the runtime\n      // knows where to rewind to to extract the content from the output stream.\n      this._outerContainer.AddContent(RuntimeControlCommand.BeginString());\n\n      this._divertToStartContentOuter = new RuntimeDivert();\n      this._outerContainer.AddContent(this._divertToStartContentOuter);\n\n      // Start content itself in a named container\n      this._startContentRuntimeContainer = this.startContent.GenerateRuntimeObject() as RuntimeContainer;\n      this._startContentRuntimeContainer.name = \"s\";\n\n      // Effectively, the \"return\" statement - return to the point specified by $r\n      const varDivert = new RuntimeDivert();\n      varDivert.variableDivertName = \"$r\";\n      this._startContentRuntimeContainer.AddContent(varDivert);\n\n      // Add the container\n      this._outerContainer.AddToNamedContentOnly(\n        this._startContentRuntimeContainer\n      );\n\n      // This is the label to return to\n      this._r1Label = new RuntimeContainer();\n      this._r1Label.name = \"$r1\";\n      this._outerContainer.AddContent(this._r1Label);\n\n      this._outerContainer.AddContent(RuntimeControlCommand.EndString());\n\n      this._runtimeChoice.hasStartContent = true;\n    }\n\n    // Choice only content - mark the start, then generate it directly into the outer container\n    if (this.choiceOnlyContent) {\n      this._outerContainer.AddContent(RuntimeControlCommand.BeginString());\n\n      const choiceOnlyRuntimeContent = this.choiceOnlyContent.GenerateRuntimeObject() as RuntimeContainer;\n      this._outerContainer.AddContentsOfContainer(choiceOnlyRuntimeContent);\n\n      this._outerContainer.AddContent(RuntimeControlCommand.EndString());\n\n      this._runtimeChoice.hasChoiceOnlyContent = true;\n    }\n\n    // Generate any condition for this choice\n    if (this.condition) {\n      this.condition.GenerateIntoContainer(this._outerContainer);\n      this._runtimeChoice.hasCondition = true;\n    }\n\n    if (this.startContent || this.choiceOnlyContent || this.condition) {\n      this._outerContainer.AddContent(RuntimeControlCommand.EvalEnd());\n    }\n\n    // Add choice itself\n    this._outerContainer.AddContent(this._runtimeChoice);\n\n    // Container that choice points to for when it's chosen\n    this._innerContentContainer = new RuntimeContainer();\n\n    // Repeat start content by diverting to its container\n    if (this.startContent) {\n      // Set the return point when jumping back into the start content\n      //  - In this case, it's the $r2 point, within the choice content \"c\".\n      this._returnToR2 = new DivertTargetValue();\n      this._innerContentContainer.AddContent(RuntimeControlCommand.EvalStart());\n      this._innerContentContainer.AddContent(this._returnToR2);\n      this._innerContentContainer.AddContent(RuntimeControlCommand.EvalEnd());\n      const varAssign = new RuntimeVariableAssignment(\"$r\", true);\n      this._innerContentContainer.AddContent(varAssign);\n\n      // Main divert into start content\n      this._divertToStartContentInner = new RuntimeDivert();\n      this._innerContentContainer.AddContent(this._divertToStartContentInner);\n\n      // Define label to return to\n      this._r2Label = new RuntimeContainer();\n      this._r2Label.name = \"$r2\";\n      this._innerContentContainer.AddContent(this._r2Label);\n    }\n\n    // Choice's own inner content\n    if (this.innerContent) {\n      const innerChoiceOnlyContent = this.innerContent.GenerateRuntimeObject() as RuntimeContainer;\n      this._innerContentContainer.AddContentsOfContainer(\n        innerChoiceOnlyContent\n      );\n    }\n\n    if (this.story.countAllVisits) {\n      this._innerContentContainer.visitsShouldBeCounted = true;\n    }\n\n    this._innerContentContainer.countingAtStartOnly = true;\n\n    return this._outerContainer;\n  };\n\n  public ResolveReferences(context: Story): void {\n    // Weave style choice - target own content container\n    if (this._innerContentContainer) {\n      this.runtimeChoice.pathOnChoice = this._innerContentContainer.path;\n\n      if (this.onceOnly) {\n        this._innerContentContainer.visitsShouldBeCounted = true;\n      }\n    }\n\n    if (this._returnToR1) {\n      if (!this._r1Label) {\n        throw new Error();\n      }\n\n      this._returnToR1.targetPath = this._r1Label.path;\n    }\n\n    if (this._returnToR2) {\n      if (!this._r2Label) {\n        throw new Error();\n      }\n\n      this._returnToR2.targetPath = this._r2Label.path;\n    }\n\n    if (this._divertToStartContentOuter) {\n      if (!this._startContentRuntimeContainer) {\n        throw new Error();\n      }\n\n      this._divertToStartContentOuter.targetPath = this._startContentRuntimeContainer.path;\n    }\n\n    if (this._divertToStartContentInner) {\n      if (!this._startContentRuntimeContainer) {\n        throw new Error();\n      }\n\n      this._divertToStartContentInner.targetPath = this._startContentRuntimeContainer.path;\n    }\n\n    super.ResolveReferences(context);\n\n    if (this.identifier && (this.identifier?.name || \"\").length > 0) {\n      context.CheckForNamingCollisions(\n        this as ParsedObject,\n        this.identifier,\n        SymbolType.SubFlowAndWeave\n      );\n    }\n  }\n\n  public readonly toString = () => {\n    if (this.choiceOnlyContent !== null) {\n      return `* ${this.startContent}[${this.choiceOnlyContent}]...`;\n    }\n\n    return `* ${this.startContent}...`;\n  };\n}\n","export class StringParserElement {\n  public static _uniqueIdCounter: number = 1000;\n\n  public characterIndex: number = 0;\n  public characterInLineIndex: number = 0;\n  public lineIndex: number = 0;\n  public reportedErrorInScope: boolean = false;\n  public uniqueId: number = 0;\n  public customFlags: number = 0;\n\n  public readonly CopyFrom = (fromElement: StringParserElement): void => {\n    StringParserElement._uniqueIdCounter++;\n    this.uniqueId = StringParserElement._uniqueIdCounter;\n    this.characterIndex = fromElement.characterIndex;\n    this.characterInLineIndex = fromElement.characterInLineIndex;\n    this.lineIndex = fromElement.lineIndex;\n    this.customFlags = fromElement.customFlags;\n    this.reportedErrorInScope = false;\n  };\n\n  // Squash is used when succeeding from a rule,\n  // so only the state information we wanted to carry forward is\n  // retained. e.g. characterIndex and lineIndex are global,\n  // however uniqueId is specific to the individual rule,\n  // and likewise, custom flags are designed for the temporary\n  // state of the individual rule too.\n  public readonly SquashFrom = (fromElement: StringParserElement): void => {\n    this.characterIndex = fromElement.characterIndex;\n    this.characterInLineIndex = fromElement.characterInLineIndex;\n    this.lineIndex = fromElement.lineIndex;\n    this.reportedErrorInScope = fromElement.reportedErrorInScope;\n  };\n}\n","import { StringParserElement } from \"./StringParserElement\";\n\nexport class StringParserState {\n  private _stack: StringParserElement[] = [];\n  private _numElements: number = 0;\n\n  get currentElement(): StringParserElement {\n    return this._stack[this._numElements - 1];\n  }\n\n  get lineIndex(): number {\n    return this.currentElement.lineIndex;\n  }\n\n  set lineIndex(value: number) {\n    this.currentElement.lineIndex = value;\n  }\n\n  get characterIndex(): number {\n    return this.currentElement.characterIndex;\n  }\n\n  set characterIndex(value: number) {\n    this.currentElement.characterIndex = value;\n  }\n\n  get characterInLineIndex(): number {\n    return this.currentElement.characterInLineIndex;\n  }\n\n  set characterInLineIndex(value: number) {\n    this.currentElement.characterInLineIndex = value;\n  }\n\n  get customFlags(): number {\n    return this.currentElement.customFlags;\n  }\n\n  set customFlags(value: number) {\n    this.currentElement.customFlags = value;\n  }\n\n  get errorReportedAlreadyInScope(): boolean {\n    return this.currentElement.reportedErrorInScope;\n  }\n\n  get stackHeight(): number {\n    return this._numElements;\n  }\n\n  constructor() {\n    const kExpectedMaxStackDepth = 200;\n    for (let i = 0; i < kExpectedMaxStackDepth; i++) {\n      this._stack[i] = new StringParserElement();\n    }\n    this._numElements = 1;\n  }\n\n  public readonly StringParserState = (): void => {\n    const kExpectedMaxStackDepth: number = 200;\n    this._stack = new Array(kExpectedMaxStackDepth);\n\n    for (let ii = 0; ii < kExpectedMaxStackDepth; ++ii) {\n      this._stack[ii] = new StringParserElement();\n    }\n\n    this._numElements = 1;\n  };\n\n  public readonly Push = (): number => {\n    if (this._numElements >= this._stack.length && this._numElements > 0) {\n      throw new Error(\"Stack overflow in parser state.\");\n    }\n\n    const prevElement = this._stack[this._numElements - 1];\n    const newElement = this._stack[this._numElements];\n    this._numElements++;\n\n    newElement.CopyFrom(prevElement);\n\n    return newElement.uniqueId;\n  };\n\n  public readonly Pop = (expectedRuleId: number): void => {\n    if (this._numElements == 1) {\n      throw new Error(\n        \"Attempting to remove final stack element is illegal! Mismatched Begin/Succceed/Fail?\"\n      );\n    }\n\n    if (this.currentElement.uniqueId != expectedRuleId) {\n      throw new Error(\n        \"Mismatched rule IDs while Poping - do you have mismatched Begin/Succeed/Fail?\"\n      );\n    }\n\n    // Restore state\n    this._numElements -= 1;\n  };\n\n  public Peek = (expectedRuleId: number) => {\n    if (this.currentElement.uniqueId != expectedRuleId) {\n      throw new Error(\n        \"Mismatched rule IDs while Peeking - do you have mismatched Begin/Succeed/Fail?\"\n      );\n    }\n\n    return this._stack[this._numElements - 1];\n  };\n\n  public readonly PeekPenultimate = (): StringParserElement | null => {\n    if (this._numElements >= 2) {\n      return this._stack[this._numElements - 2];\n    }\n\n    return null;\n  };\n\n  // Reduce stack height while maintaining currentElement\n  // Remove second last element: i.e. \"squash last two elements together\"\n  // Used when succeeding from a rule (and ONLY when succeeding, since\n  // the state of the top element is retained).\n  public readonly Squash = (): void => {\n    if (this._numElements < 2) {\n      throw new Error(\n        \"Attempting to remove final stack element is illegal! Mismatched Begin/Succceed/Fail?\"\n      );\n    }\n\n    const penultimateEl = this._stack[this._numElements - 2];\n    const lastEl = this._stack[this._numElements - 1];\n\n    penultimateEl.SquashFrom(lastEl);\n\n    this._numElements -= 1;\n  };\n\n  public readonly NoteErrorReported = (): void => {\n    for (const el of this._stack) {\n      el.reportedErrorInScope = true;\n    }\n  };\n}\n","import { CharacterSet } from \"../CharacterSet\";\nimport { ParsedObject } from \"../ParsedHierarchy/Object\";\nimport { StringParserState } from \"./StringParserState\";\nimport { StringParserElement } from \"./StringParserElement\";\n\nexport const ParseSuccess = Symbol(\"ParseSuccessStruct\");\n\nexport type ParseRule = () => ParseRuleReturn;\n\nexport type ParseRuleReturn =\n  | object\n  | string\n  | null\n  | number\n  | typeof StringParser[\"ParseSuccess\"];\n\nexport type SpecificParseRule<T extends ParseRule> = T;\n\nexport abstract class StringParser {\n  public ParseRule: ParseRule | null = null;\n\n  public static readonly ParseSuccess: typeof ParseSuccess = ParseSuccess;\n  public static readonly numbersCharacterSet = new CharacterSet(\"0123456789\");\n\n  private _chars: string[];\n\n  public errorHandler:\n    | null\n    | ((\n        message: string,\n        index: number,\n        lineIndex?: number,\n        isWarning?: boolean\n      ) => void) = null;\n  public state: StringParserState;\n  public hadError: boolean = false;\n\n  constructor(str: string) {\n    const strPreProc = this.PreProcessInputString(str);\n    this.state = new StringParserState();\n\n    if (str) {\n      this._chars = strPreProc.split(\"\");\n    } else {\n      this._chars = [];\n    }\n\n    this.inputString = strPreProc;\n  }\n\n  get currentCharacter(): string {\n    if (this.index >= 0 && this.remainingLength > 0) {\n      return this._chars[this.index];\n    }\n\n    return \"0\";\n  }\n\n  // Don't do anything by default, but provide ability for subclasses\n  // to manipulate the string before it's used as input (converted to a char array)\n  public PreProcessInputString(str: string): string {\n    return str;\n  }\n\n  //--------------------------------\n  // Parse state\n  //--------------------------------\n\n  public readonly BeginRule = (): number => this.state.Push();\n\n  public readonly FailRule = (expectedRuleId: number): ParseRuleReturn => {\n    this.state.Pop(expectedRuleId);\n    return null;\n  };\n\n  public readonly CancelRule = (expectedRuleId: number): void => {\n    this.state.Pop(expectedRuleId);\n  };\n\n  public readonly SucceedRule = (\n    expectedRuleId: number,\n    result: ParseRuleReturn = null\n  ): ParseRuleReturn => {\n    // Get state at point where this rule stared evaluating\n    const stateAtSucceedRule = this.state.Peek(expectedRuleId);\n    const stateAtBeginRule = this.state.PeekPenultimate();\n\n    // Allow subclass to receive callback\n    if (this.RuleDidSucceed) {\n      this.RuleDidSucceed(result, stateAtBeginRule, stateAtSucceedRule);\n    }\n\n    // Flatten state stack so that we maintain the same values,\n    // but remove one level in the stack.\n    this.state.Squash();\n\n    let finalResult: ParseRuleReturn = result;\n    if (finalResult === null) {\n      finalResult = StringParser.ParseSuccess;\n    }\n\n    return finalResult;\n  };\n\n  public RuleDidSucceed?: (\n    result: ParseRuleReturn,\n    startState: StringParserElement | null,\n    endState: StringParserElement\n  ) => void;\n\n  public readonly Expect = (\n    rule: ParseRule,\n    message: string | null = null,\n    recoveryRule: ParseRule | null = null\n  ): ParseRuleReturn => {\n    let result: ParseRuleReturn = this.ParseObject(rule);\n    if (result === null) {\n      if (message === null) {\n        message = rule.name;\n      }\n\n      let butSaw: string;\n      const lineRemainder: string = this.LineRemainder();\n      if (lineRemainder === null || lineRemainder.length === 0) {\n        butSaw = \"end of line\";\n      } else {\n        butSaw = `'${lineRemainder}'`;\n      }\n\n      this.Error(`Expected ${message} but saw ${butSaw}`);\n\n      if (recoveryRule !== null) {\n        result = recoveryRule();\n      }\n    }\n\n    return result;\n  };\n\n  public Error = (message: string, isWarning: boolean = false): void => {\n    this.ErrorOnLine(message, this.lineIndex + 1, isWarning);\n  };\n\n  public readonly ErrorWithParsedObject = (\n    message: string,\n    result: ParsedObject,\n    isWarning: boolean = false\n  ): void => {\n    this.ErrorOnLine(\n      message,\n      result.debugMetadata ? result.debugMetadata.startLineNumber : -1,\n      isWarning\n    );\n  };\n\n  public readonly ErrorOnLine = (\n    message: string,\n    lineNumber: number,\n    isWarning: boolean\n  ): void => {\n    if (!this.state.errorReportedAlreadyInScope) {\n      const errorType = isWarning ? \"Warning\" : \"Error\";\n\n      if (!this.errorHandler) {\n        throw new Error(`${errorType} on line ${lineNumber}: ${message}`);\n      } else {\n        this.errorHandler(message, this.index, lineNumber - 1, isWarning);\n      }\n\n      this.state.NoteErrorReported();\n    }\n\n    if (!isWarning) {\n      this.hadError = true;\n    }\n  };\n\n  public readonly Warning = (message: string): void =>\n    this.Error(message, true);\n\n  get endOfInput(): boolean {\n    return this.index >= this._chars.length;\n  }\n\n  get remainingString(): string {\n    return this._chars\n      .slice(this.index, this.index + this.remainingLength)\n      .join(\"\");\n  }\n\n  public readonly LineRemainder = (): string =>\n    this.Peek(() => this.ParseUntilCharactersFromString(\"\\n\\r\")) as string;\n\n  get remainingLength() {\n    return this._chars.length - this.index;\n  }\n\n  public inputString: string;\n\n  get lineIndex() {\n    return this.state.lineIndex;\n  }\n\n  set lineIndex(value: number) {\n    this.state.lineIndex = value;\n  }\n\n  set characterInLineIndex(value: number) {\n    this.state.characterInLineIndex = value;\n  }\n\n  get characterInLineIndex() {\n    return this.state.characterInLineIndex;\n  }\n\n  get index(): number {\n    // If we want subclass parsers to be able to set the index directly,\n    // then we would need to know what the lineIndex of the new\n    // index would be - would we have to step through manually\n    // counting the newlines to do so?\n    return this.state.characterIndex;\n  }\n\n  set index(value: number) {\n    this.state.characterIndex = value;\n  }\n\n  public readonly SetFlag = (flag: number, trueOrFalse: boolean): void => {\n    if (trueOrFalse) {\n      this.state.customFlags |= flag;\n    } else {\n      this.state.customFlags &= ~flag;\n    }\n  };\n\n  public readonly GetFlag = (flag: number): boolean =>\n    Boolean(this.state.customFlags & flag);\n\n  //--------------------------------\n  // Structuring\n  //--------------------------------\n\n  public ParseObject = (rule: ParseRule): ParseRuleReturn => {\n    const ruleId: number = this.BeginRule();\n    const stackHeightBefore = this.state.stackHeight;\n    const result = rule();\n\n    if (stackHeightBefore !== this.state.stackHeight) {\n      throw new Error(\"Mismatched Begin/Fail/Succeed rules\");\n    }\n\n    if (result === null) {\n      return this.FailRule(ruleId);\n    }\n\n    this.SucceedRule(ruleId, result);\n\n    return result;\n  };\n\n  public readonly Parse = <T extends ParseRule>(\n    rule: SpecificParseRule<T>\n  ): ParseRuleReturn => {\n    const ruleId: number = this.BeginRule();\n\n    const result: ParseRuleReturn = rule();\n    if (result === null) {\n      this.FailRule(ruleId);\n      return null;\n    }\n\n    this.SucceedRule(ruleId, result);\n\n    return result;\n  };\n\n  public readonly OneOf = (array: ParseRule[]): ParseRuleReturn => {\n    for (const rule of array) {\n      const result = this.ParseObject(rule);\n      if (result !== null) {\n        return result;\n      }\n    }\n\n    return null;\n  };\n\n  public readonly OneOrMore = (rule: ParseRule): ParseRuleReturn[] | null => {\n    const results: ParseRuleReturn[] = [];\n    let result: ParseRuleReturn = null;\n\n    do {\n      result = this.ParseObject(rule);\n      if (result !== null) {\n        results.push(result);\n      }\n    } while (result !== null);\n\n    if (results.length > 0) {\n      return results;\n    }\n\n    return null;\n  };\n\n  public readonly Optional = (rule: ParseRule): ParseRule => () =>\n    this.ParseObject(rule) || StringParser.ParseSuccess;\n\n  // Return ParseSuccess instead the real result so that it gets excluded\n  // from result arrays (e.g. Interleave)\n  public readonly Exclude = (rule: ParseRule): ParseRule => () =>\n    this.ParseObject(rule) && StringParser.ParseSuccess;\n\n  // Combination of both of the above\n  public readonly OptionalExclude = (rule: ParseRule): ParseRule => () => {\n    this.ParseObject(rule);\n    return StringParser.ParseSuccess;\n  };\n\n  // Convenience method for creating more readable ParseString rules that can be combined\n  // in other structuring rules (like OneOf etc)\n  // e.g. OneOf(String(\"one\"), String(\"two\"))\n  public readonly String = (str: string): ParseRule => () =>\n    this.ParseString(str);\n\n  private readonly TryAddResultToList = <T>(\n    result: ParseRuleReturn,\n    list: T[],\n    flatten: boolean = true\n  ): void => {\n    if (result === StringParser.ParseSuccess) {\n      return;\n    }\n\n    if (flatten && Array.isArray(result)) {\n      const resultCollection = result as ParseRuleReturn[];\n      if (resultCollection !== null) {\n        for (const obj of resultCollection) {\n          list.push(obj as any);\n        }\n\n        return;\n      }\n    }\n\n    list.push(result as any);\n  };\n\n  public readonly Interleave = <T>(\n    ruleA: ParseRule,\n    ruleB: ParseRule,\n    untilTerminator: ParseRule | null = null,\n    flatten: boolean = true\n  ): T[] => {\n    const ruleId: number = this.BeginRule();\n    const results: T[] = [];\n\n    // First outer padding\n    const firstA = this.ParseObject(ruleA);\n    if (firstA === null) {\n      return this.FailRule(ruleId) as any;\n    } else {\n      this.TryAddResultToList(firstA, results, flatten);\n    }\n\n    let lastMainResult: ParseRuleReturn | null = null;\n    let outerResult: ParseRuleReturn | null = null;\n    do {\n      // \"until\" condition hit?\n      if (untilTerminator !== null && this.Peek(untilTerminator) !== null) {\n        break;\n      }\n\n      // Main inner\n      lastMainResult = this.ParseObject(ruleB);\n      if (lastMainResult === null) {\n        break;\n      } else {\n        this.TryAddResultToList(lastMainResult, results, flatten);\n      }\n\n      // Outer result (i.e. last A in ABA)\n      outerResult = null;\n      if (lastMainResult !== null) {\n        outerResult = this.ParseObject(ruleA);\n\n        if (outerResult === null) {\n          break;\n        } else {\n          this.TryAddResultToList(outerResult, results, flatten);\n        }\n      }\n\n      // Stop if there are no results, or if both are the placeholder \"ParseSuccess\" (i.e. Optional success rather than a true value)\n    } while (\n      (lastMainResult !== null || outerResult !== null) &&\n      !(\n        (lastMainResult as any) === StringParser.ParseSuccess &&\n        outerResult == StringParser.ParseSuccess\n      ) &&\n      this.remainingLength > 0\n    );\n\n    if (results.length === 0) {\n      return this.FailRule(ruleId) as T[];\n    }\n\n    return this.SucceedRule(ruleId, results) as T[];\n  };\n\n  //--------------------------------\n  // Basic string parsing\n  //--------------------------------\n\n  public readonly ParseString = (str: string): string | null => {\n    if (str.length > this.remainingLength) {\n      return null;\n    }\n\n    const ruleId: number = this.BeginRule();\n\n    // Optimisation from profiling:\n    // Store in temporary local variables\n    // since they're properties that would have to access\n    // the rule stack every time otherwise.\n    let i: number = this.index;\n    let cli: number = this.characterInLineIndex;\n    let li: number = this.lineIndex;\n\n    let success: boolean = true;\n    for (let tempIdx = 0; tempIdx < str.length; tempIdx += 1) {\n      const c = str[tempIdx];\n\n      if (this._chars[i] !== c) {\n        success = false;\n        break;\n      }\n      if (c === \"\\n\") {\n        li++;\n        cli = -1;\n      }\n\n      i++;\n      cli++;\n    }\n\n    this.index = i;\n    this.characterInLineIndex = cli;\n    this.lineIndex = li;\n\n    if (success) {\n      return this.SucceedRule(ruleId, str) as any;\n    }\n\n    return this.FailRule(ruleId) as any;\n  };\n\n  public readonly ParseSingleCharacter = (): string => {\n    if (this.remainingLength > 0) {\n      const c = this._chars[this.index];\n      if (c === \"\\n\") {\n        this.lineIndex += 1;\n        this.characterInLineIndex = -1;\n      }\n\n      this.index += 1;\n      this.characterInLineIndex += 1;\n\n      return c;\n    }\n\n    return \"0\";\n  };\n\n  public readonly ParseUntilCharactersFromString = (\n    str: string,\n    maxCount: number = -1\n  ): string | null => this.ParseCharactersFromString(str, false, maxCount);\n\n  public readonly ParseUntilCharactersFromCharSet = (\n    charSet: CharacterSet,\n    maxCount: number = -1\n  ): string | null => this.ParseCharactersFromCharSet(charSet, false, maxCount);\n\n  public readonly ParseCharactersFromString = (\n    str: string,\n    maxCountOrShouldIncludeStrChars: boolean | number = -1,\n    maxCount: number = -1\n  ): string | null => {\n    const charSet = new CharacterSet(str);\n    if (typeof maxCountOrShouldIncludeStrChars === \"number\") {\n      return this.ParseCharactersFromCharSet(\n        charSet,\n        true,\n        maxCountOrShouldIncludeStrChars\n      );\n    }\n\n    return this.ParseCharactersFromCharSet(\n      charSet,\n      maxCountOrShouldIncludeStrChars,\n      maxCount\n    );\n  };\n\n  public readonly ParseCharactersFromCharSet = (\n    charSet: CharacterSet,\n    shouldIncludeChars: boolean = true,\n    maxCount: number = -1\n  ): string | null => {\n    if (maxCount === -1) {\n      maxCount = Number.MAX_SAFE_INTEGER;\n    }\n\n    const startIndex: number = this.index;\n\n    // Optimisation from profiling:\n    // Store in temporary local variables\n    // since they're properties that would have to access\n    // the rule stack every time otherwise.\n    let ii: number = this.index;\n    let cli: number = this.characterInLineIndex;\n    let li: number = this.lineIndex;\n    let count: number = 0;\n    while (\n      ii < this._chars.length &&\n      charSet.set.has(this._chars[ii]) === shouldIncludeChars &&\n      count < maxCount\n    ) {\n      if (this._chars[ii] === \"\\n\") {\n        li += 1;\n        cli = -1;\n      }\n\n      ii += 1;\n      cli += 1;\n      count += 1;\n    }\n\n    this.index = ii;\n    this.characterInLineIndex = cli;\n    this.lineIndex = li;\n\n    const lastCharIndex: number = this.index;\n    if (lastCharIndex > startIndex) {\n      return this._chars.slice(startIndex, this.index).join(\"\");\n    }\n\n    return null;\n  };\n\n  public readonly Peek = (rule: ParseRule): ParseRuleReturn => {\n    const ruleId: number = this.BeginRule();\n    const result: ParseRuleReturn = rule();\n    this.CancelRule(ruleId);\n\n    return result;\n  };\n\n  public ParseUntil(\n    stopRule: ParseRule,\n    pauseCharacters: CharacterSet | null = null,\n    endCharacters: CharacterSet | null = null\n  ): string {\n    const ruleId: number = this.BeginRule();\n    const pauseAndEnd: CharacterSet = new CharacterSet();\n    if (pauseCharacters !== null) {\n      pauseAndEnd.set = new Set([\n        ...pauseAndEnd.set.values(),\n        ...pauseCharacters.set.values(),\n      ]);\n    }\n\n    if (endCharacters !== null) {\n      pauseAndEnd.set = new Set([\n        ...pauseAndEnd.set.values(),\n        ...endCharacters.set.values(),\n      ]);\n    }\n\n    let parsedString = \"\";\n    let ruleResultAtPause: ParseRuleReturn | null = null;\n\n    // Keep attempting to parse strings up to the pause (and end) points.\n    //  - At each of the pause points, attempt to parse according to the rule\n    //  - When the end point is reached (or EOF), we're done\n    do {\n      // TODO: Perhaps if no pause or end characters are passed, we should check *every* character for stopRule?\n      const partialParsedString:\n        | string\n        | null = this.ParseUntilCharactersFromCharSet(pauseAndEnd);\n\n      if (partialParsedString) {\n        parsedString += partialParsedString;\n      }\n\n      // Attempt to run the parse rule at this pause point\n      ruleResultAtPause = this.Peek(stopRule);\n\n      // Rule completed - we're done\n      if (ruleResultAtPause !== null) {\n        break;\n      } else {\n        if (this.endOfInput) {\n          break;\n        }\n\n        // Reached a pause point, but rule failed. Step past and continue parsing string\n        const pauseCharacter: string = this.currentCharacter;\n        if (\n          pauseCharacters !== null &&\n          pauseCharacters.set.has(pauseCharacter)\n        ) {\n          parsedString += pauseCharacter;\n          if (pauseCharacter === \"\\n\") {\n            this.lineIndex += 1;\n            this.characterInLineIndex = -1;\n          }\n\n          this.index += 1;\n          this.characterInLineIndex += 1;\n\n          continue;\n        } else {\n          break;\n        }\n      }\n    } while (true);\n\n    if (parsedString.length > 0) {\n      return this.SucceedRule(ruleId, String(parsedString)) as string;\n    }\n\n    return this.FailRule(ruleId) as string;\n  }\n\n  // No need to Begin/End rule since we never parse a newline, so keeping oldIndex is good enough\n  public readonly ParseInt = (): number | null => {\n    const oldIndex: number = this.index;\n    const oldCharacterInLineIndex: number = this.characterInLineIndex;\n    const negative: boolean = this.ParseString(\"-\") !== null;\n\n    // Optional whitespace\n    this.ParseCharactersFromString(\" \\t\");\n\n    const parsedString = this.ParseCharactersFromCharSet(\n      StringParser.numbersCharacterSet\n    );\n    if (parsedString === null) {\n      // Roll back and fail\n      this.index = oldIndex;\n      this.characterInLineIndex = oldCharacterInLineIndex;\n\n      return null;\n    }\n\n    let parsedInt: number;\n    if (!Number.isNaN(Number(parsedString))) {\n      parsedInt = Number(parsedString);\n      return negative ? -parsedInt : parsedInt;\n    }\n\n    this.Error(\n      \"Failed to read integer value: \" +\n        parsedString +\n        \". Perhaps it's out of the range of acceptable numbers ink supports? (\" +\n        Number.MIN_SAFE_INTEGER +\n        \" to \" +\n        Number.MAX_SAFE_INTEGER +\n        \")\"\n    );\n\n    return null;\n  };\n\n  // No need to Begin/End rule since we never parse a newline, so keeping oldIndex is good enough\n  public readonly ParseFloat = (): number | null => {\n    const oldIndex: number = this.index;\n    const oldCharacterInLineIndex: number = this.characterInLineIndex;\n\n    const leadingInt: number | null = this.ParseInt();\n    if (leadingInt !== null) {\n      if (this.ParseString(\".\") !== null) {\n        const afterDecimalPointStr = this.ParseCharactersFromCharSet(\n          StringParser.numbersCharacterSet\n        );\n\n        return Number(`${leadingInt}.${afterDecimalPointStr}`);\n      }\n    }\n\n    // Roll back and fail\n    this.index = oldIndex;\n    this.characterInLineIndex = oldCharacterInLineIndex;\n\n    return null;\n  };\n\n  public readonly ParseNewline = (): string => {\n    const ruleId: number = this.BeginRule();\n\n    // Optional \\r, definite \\n to support Windows (\\r\\n) and Mac/Unix (\\n)\n    // 2nd May 2016: Always collapse \\r\\n to just \\n\n    this.ParseString(\"\\r\");\n\n    if (this.ParseString(\"\\n\") === null) {\n      return this.FailRule(ruleId) as string;\n    }\n\n    return this.SucceedRule(ruleId, \"\\n\") as string;\n  };\n}\n","export enum FlowLevel {\n  Story, // 0\n  Knot, // 1\n  Stitch, // 2\n  // not actually a FlowBase, but used for diverts\n  WeavePoint, // 3\n}\n","import { CharacterSet } from \"./CharacterSet\";\nimport { StringParser } from \"./StringParser/StringParser\";\n\n/// <summary>\n/// Pre-pass before main ink parser runs. It actually performs two main tasks:\n///  - comment elimination to simplify the parse rules in the main parser\n///  - Conversion of Windows line endings (\\r\\n) to the simpler Unix style (\\n), so\n///    we don't have to worry about them later.\n/// </summary>\nexport class CommentEliminator extends StringParser {\n  public _commentOrNewlineStartCharacter = new CharacterSet(\"/\\r\\n\");\n  public _commentBlockEndCharacter = new CharacterSet(\"*\");\n  public _newlineCharacters = new CharacterSet(\"\\n\\r\");\n\n  public readonly Process = (): string => {\n    // Make both comments and non-comments optional to handle trivial empty file case (or *only* comments)\n    const stringList: string[] = this.Interleave<string>(\n      this.Optional(this.CommentsAndNewlines),\n      this.Optional(this.MainInk)\n    );\n\n    if (stringList !== null) {\n      return stringList.join(\"\");\n    } else {\n      return \"\";\n    }\n  };\n\n  public readonly MainInk = () =>\n    this.ParseUntil(\n      this.CommentsAndNewlines,\n      this._commentOrNewlineStartCharacter,\n      null\n    );\n\n  public readonly CommentsAndNewlines = () => {\n    let newLines: string[] = this.Interleave<string>(\n      this.Optional(this.ParseNewline),\n      this.Optional(this.ParseSingleComment)\n    );\n\n    if (newLines !== null) {\n      return newLines.join(\"\");\n    }\n\n    return null;\n  };\n\n  // Valid comments always return either an empty string or pure newlines,\n  // which we want to keep so that line numbers stay the same\n  public readonly ParseSingleComment = () =>\n    this.OneOf([this.EndOfLineComment, this.BlockComment]);\n\n  public readonly EndOfLineComment = () => {\n    if (this.ParseString(\"//\") === null) {\n      return null;\n    }\n\n    this.ParseUntilCharactersFromCharSet(this._newlineCharacters);\n\n    return \"\";\n  };\n\n  public readonly BlockComment = () => {\n    if (this.ParseString(\"/*\") === null) {\n      return null;\n    }\n\n    const startLineIndex: number = this.lineIndex;\n    const commentResult = this.ParseUntil(\n      this.String(\"*/\"),\n      this._commentBlockEndCharacter,\n      null\n    );\n\n    if (!this.endOfInput) {\n      this.ParseString(\"*/\");\n    }\n\n    // Count the number of lines that were inside the block, and replicate them as newlines\n    // so that the line indexing still works from the original source\n    if (commentResult != null) {\n      return \"\\n\".repeat(this.lineIndex - startLineIndex);\n    }\n\n    // No comment at all\n    return null;\n  };\n\n  public PreProcessInputString(str: string): string {\n    return str;\n  }\n}\n","import { ConditionalSingleBranch } from \"./ConditionalSingleBranch\";\nimport { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { ControlCommand as RuntimeControlCommand } from \"../../../../engine/ControlCommand\";\nimport { Expression } from \"../Expression/Expression\";\nimport { ParsedObject } from \"../Object\";\nimport { InkObject as RuntimeObject } from \"../../../../engine/Object\";\nimport { Story } from \"../Story\";\n\nexport class Conditional extends ParsedObject {\n  private _reJoinTarget: RuntimeControlCommand | null = null;\n\n  constructor(\n    public initialCondition: Expression,\n    public branches: ConditionalSingleBranch[]\n  ) {\n    super();\n\n    if (this.initialCondition) {\n      this.AddContent(this.initialCondition);\n    }\n\n    if (this.branches !== null) {\n      this.AddContent(this.branches);\n    }\n  }\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject => {\n    const container = new RuntimeContainer();\n\n    // Initial condition\n    if (this.initialCondition) {\n      container.AddContent(this.initialCondition.runtimeObject);\n    }\n\n    // Individual branches\n    for (const branch of this.branches) {\n      const branchContainer = branch.runtimeObject;\n      container.AddContent(branchContainer);\n    }\n\n    // If it's a switch-like conditional, each branch\n    // will have a \"duplicate\" operation for the original\n    // switched value. If there's no final else clause\n    // and we fall all the way through, we need to clean up.\n    // (An else clause doesn't dup but it *does* pop)\n    if (\n      this.initialCondition !== null &&\n      this.branches[0].ownExpression !== null &&\n      !this.branches[this.branches.length - 1].isElse\n    ) {\n      container.AddContent(RuntimeControlCommand.PopEvaluatedValue());\n    }\n\n    // Target for branches to rejoin to\n    this._reJoinTarget = RuntimeControlCommand.NoOp();\n    container.AddContent(this._reJoinTarget);\n\n    return container;\n  };\n\n  public ResolveReferences(context: Story): void {\n    const pathToReJoin = this._reJoinTarget!.path;\n\n    for (const branch of this.branches) {\n      if (!branch.returnDivert) {\n        throw new Error();\n      }\n\n      branch.returnDivert.targetPath = pathToReJoin;\n    }\n\n    super.ResolveReferences(context);\n  }\n}\n","﻿import { ParsedObject } from \"./Object\";\nimport { InkObject as RuntimeObject } from \"../../../engine/Object\";\nimport { StringValue } from \"../../../engine/Value\";\n\nexport class Text extends ParsedObject {\n  constructor(public text: string) {\n    super();\n  }\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject =>\n    new StringValue(this.text);\n\n  public readonly toString = (): string => this.text;\n}\n","import { Expression } from \"../Expression/Expression\";\nimport { ParsedObject } from \"../Object\";\nimport { InkObject as RuntimeObject } from \"../../../../engine/Object\";\nimport { Story } from \"../Story\";\nimport { SymbolType } from \"../SymbolType\";\nimport { Identifier } from \"../Identifier\";\n\nexport class ConstantDeclaration extends ParsedObject {\n  get constantName(): string | undefined {\n    return this.constantIdentifier?.name;\n  }\n  public constantIdentifier: Identifier;\n\n  private _expression: Expression | null = null;\n\n  get expression(): Expression {\n    if (!this._expression) {\n      throw new Error();\n    }\n\n    return this._expression;\n  }\n\n  constructor(name: Identifier, assignedExpression: Expression) {\n    super();\n\n    this.constantIdentifier = name;\n\n    // Defensive programming in case parsing of assignedExpression failed\n    if (assignedExpression) {\n      this._expression = this.AddContent(assignedExpression) as Expression;\n    }\n  }\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject | null => {\n    // Global declarations don't generate actual procedural\n    // runtime objects, but instead add a global variable to the story itself.\n    // The story then initialises them all in one go at the start of the game.\n    return null;\n  };\n\n  public ResolveReferences(context: Story) {\n    super.ResolveReferences(context);\n    context.CheckForNamingCollisions(\n      this,\n      this.constantIdentifier,\n      SymbolType.Var\n    );\n  }\n\n  get typeName() {\n    return \"Constant\";\n  }\n}\n","import { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { INamedContent } from \"../../../../engine/INamedContent\";\nimport { IWeavePoint } from \"../IWeavePoint\";\nimport { ParsedObject } from \"../Object\";\nimport { InkObject as RuntimeObject } from \"../../../../engine/Object\";\nimport { Story } from \"../Story\";\nimport { SymbolType } from \"../SymbolType\";\nimport { Identifier } from \"../Identifier\";\n\nexport class Gather extends ParsedObject implements INamedContent, IWeavePoint {\n  get name(): string | null {\n    return this.identifier?.name || null;\n  }\n  public identifier?: Identifier;\n\n  get runtimeContainer(): RuntimeContainer {\n    return this.runtimeObject as RuntimeContainer;\n  }\n\n  constructor(\n    identifier: Identifier | null,\n    public readonly indentationDepth: number\n  ) {\n    super();\n\n    if (identifier) this.identifier = identifier;\n  }\n\n  get typeName(): string {\n    return \"Gather\";\n  }\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject => {\n    const container = new RuntimeContainer();\n    container.name = this.name;\n\n    if (this.story.countAllVisits) {\n      container.visitsShouldBeCounted = true;\n    }\n\n    container.countingAtStartOnly = true;\n\n    // A gather can have null content, e.g. it's just purely a line with \"-\"\n    if (this.content) {\n      for (const c of this.content) {\n        container.AddContent(c.runtimeObject);\n      }\n    }\n\n    return container;\n  };\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n\n    if (this.identifier && (this.identifier.name || \"\").length > 0) {\n      context.CheckForNamingCollisions(\n        this,\n        this.identifier,\n        SymbolType.SubFlowAndWeave\n      );\n    }\n  }\n\n  public readonly toString = (): string =>\n    `- ${this.identifier?.name ? \"(\" + this.identifier?.name + \")\" : \"gather\"}`;\n}\n","import { asOrNull, filterUndef } from \"../../../engine/TypeAssertion\";\nimport { FlowBase } from \"./Flow/FlowBase\";\nimport { FlowLevel } from \"./Flow/FlowLevel\";\nimport { Identifier } from \"./Identifier\";\nimport { ParsedObject } from \"./Object\";\nimport { Weave } from \"./Weave\";\n\nexport class Path {\n  private _baseTargetLevel: FlowLevel | null;\n  private components: Identifier[] | null;\n\n  get baseTargetLevel() {\n    if (this.baseLevelIsAmbiguous) {\n      return FlowLevel.Story;\n    }\n\n    return this._baseTargetLevel;\n  }\n\n  get baseLevelIsAmbiguous(): boolean {\n    return !this._baseTargetLevel;\n  }\n\n  get firstComponent(): string | null {\n    if (this.components == null || !this.components.length) {\n      return null;\n    }\n\n    return this.components[0].name;\n  }\n\n  get numberOfComponents(): number {\n    return this.components ? this.components.length : 0;\n  }\n\n  private _dotSeparatedComponents: string | null = null;\n\n  get dotSeparatedComponents(): string {\n    if (this._dotSeparatedComponents == null) {\n      this._dotSeparatedComponents = (this.components ? this.components : [])\n        .map((c) => c.name)\n        .filter(filterUndef)\n        .join(\".\");\n    }\n    return this._dotSeparatedComponents;\n  }\n\n  constructor(\n    argOne: FlowLevel | Identifier[] | Identifier,\n    argTwo?: Identifier[]\n  ) {\n    if (Object.values(FlowLevel).includes(argOne as FlowLevel)) {\n      this._baseTargetLevel = argOne as FlowLevel;\n      this.components = argTwo || [];\n    } else if (Array.isArray(argOne)) {\n      this._baseTargetLevel = null;\n      this.components = argOne || [];\n    } else {\n      this._baseTargetLevel = null;\n      this.components = [argOne as Identifier];\n    }\n  }\n\n  public readonly toString = (): string => {\n    if (this.components === null || this.components.length === 0) {\n      if (this.baseTargetLevel === FlowLevel.WeavePoint) {\n        return \"-> <next gather point>\";\n      }\n\n      return \"<invalid Path>\";\n    }\n\n    return `-> ${this.dotSeparatedComponents}`;\n  };\n\n  public readonly ResolveFromContext = (\n    context: ParsedObject\n  ): ParsedObject | null => {\n    if (this.components == null || this.components.length == 0) {\n      return null;\n    }\n\n    // Find base target of path from current context. e.g.\n    //   ==> BASE.sub.sub\n    let baseTargetObject = this.ResolveBaseTarget(context);\n    if (baseTargetObject === null) {\n      return null;\n    }\n\n    // Given base of path, resolve final target by working deeper into hierarchy\n    //  e.g. ==> base.mid.FINAL\n    if (this.components.length > 1) {\n      return this.ResolveTailComponents(baseTargetObject);\n    }\n\n    return baseTargetObject;\n  };\n\n  // Find the root object from the base, i.e. root from:\n  //    root.sub1.sub2\n  public readonly ResolveBaseTarget = (\n    originalContext: ParsedObject\n  ): ParsedObject | null => {\n    const firstComp = this.firstComponent;\n\n    // Work up the ancestry to find the node that has the named object\n    let ancestorContext: ParsedObject | null = originalContext;\n    while (ancestorContext) {\n      // Only allow deep search when searching deeper from original context.\n      // Don't allow search upward *then* downward, since that's searching *everywhere*!\n      // Allowed examples:\n      //  - From an inner gather of a stitch, you should search up to find a knot called 'x'\n      //    at the root of a story, but not a stitch called 'x' in that knot.\n      //  - However, from within a knot, you should be able to find a gather/choice\n      //    anywhere called 'x'\n      // (that latter example is quite loose, but we allow it)\n      const deepSearch: boolean = ancestorContext === originalContext;\n\n      const foundBase = this.GetChildFromContext(\n        ancestorContext,\n        firstComp,\n        null,\n        deepSearch\n      );\n\n      if (foundBase) {\n        return foundBase;\n      }\n\n      ancestorContext = ancestorContext.parent;\n    }\n\n    return null;\n  };\n\n  // Find the final child from path given root, i.e.:\n  //   root.sub.finalChild\n  public readonly ResolveTailComponents = (\n    rootTarget: ParsedObject\n  ): ParsedObject | null => {\n    let foundComponent: ParsedObject | null = rootTarget;\n\n    if (!this.components) return null;\n\n    for (let ii = 1; ii < this.components.length; ++ii) {\n      const compName = this.components[ii].name;\n\n      let minimumExpectedLevel: FlowLevel;\n      let foundFlow = asOrNull(foundComponent, FlowBase);\n      if (foundFlow !== null) {\n        minimumExpectedLevel = (foundFlow.flowLevel + 1) as FlowLevel;\n      } else {\n        minimumExpectedLevel = FlowLevel.WeavePoint;\n      }\n\n      foundComponent = this.GetChildFromContext(\n        foundComponent,\n        compName,\n        minimumExpectedLevel\n      );\n\n      if (foundComponent === null) {\n        break;\n      }\n    }\n\n    return foundComponent;\n  };\n\n  // See whether \"context\" contains a child with a given name at a given flow level\n  // Can either be a named knot/stitch (a FlowBase) or a weave point within a Weave (Choice or Gather)\n  // This function also ignores any other object types that are neither FlowBase nor Weave.\n  // Called from both ResolveBase (force deep) and ResolveTail for the individual components.\n  public readonly GetChildFromContext = (\n    context: ParsedObject,\n    childName: string | null,\n    minimumLevel: FlowLevel | null,\n    forceDeepSearch: boolean = false\n  ): ParsedObject | null => {\n    // null childLevel means that we don't know where to find it\n    const ambiguousChildLevel: boolean = minimumLevel === null;\n\n    // Search for WeavePoint within Weave\n    const weaveContext = asOrNull(context, Weave);\n    if (\n      childName &&\n      weaveContext !== null &&\n      (ambiguousChildLevel || minimumLevel === FlowLevel.WeavePoint)\n    ) {\n      return weaveContext.WeavePointNamed(childName) as ParsedObject;\n    }\n\n    // Search for content within Flow (either a sub-Flow or a WeavePoint)\n    let flowContext = asOrNull(context, FlowBase);\n    if (childName && flowContext !== null) {\n      // When searching within a Knot, allow a deep searches so that\n      // named weave points (choices and gathers) can be found within any stitch\n      // Otherwise, we just search within the immediate object.\n      const shouldDeepSearch =\n        forceDeepSearch || flowContext.flowLevel === FlowLevel.Knot;\n\n      return flowContext.ContentWithNameAtLevel(\n        childName,\n        minimumLevel,\n        shouldDeepSearch\n      );\n    }\n\n    return null;\n  };\n}\n","import { Expression } from \"./Expression/Expression\";\nimport { ParsedObject } from \"./Object\";\nimport { Container as RuntimeContainer } from \"../../../engine/Container\";\nimport { ControlCommand as RuntimeControlCommand } from \"../../../engine/ControlCommand\";\nimport { InkObject as RuntimeObject } from \"../../../engine/Object\";\nimport { Void } from \"../../../engine/Void\";\n\nexport class ReturnType extends ParsedObject {\n  public returnedExpression: Expression | null = null;\n\n  constructor(returnedExpression: Expression | null = null) {\n    super();\n\n    if (returnedExpression) {\n      this.returnedExpression = this.AddContent(\n        returnedExpression\n      ) as Expression;\n    }\n  }\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject => {\n    const container = new RuntimeContainer();\n\n    if (this.returnedExpression) {\n      // Evaluate expression\n      container.AddContent(this.returnedExpression.runtimeObject);\n    } else {\n      // Return Runtime.Void when there's no expression to evaluate\n      // (This evaluation will just add the Void object to the evaluation stack)\n      container.AddContent(RuntimeControlCommand.EvalStart());\n      container.AddContent(new Void());\n      container.AddContent(RuntimeControlCommand.EvalEnd());\n    }\n\n    // Then pop the call stack\n    // (the evaluated expression will leave the return value on the evaluation stack)\n    container.AddContent(RuntimeControlCommand.PopFunction());\n\n    return container;\n  };\n}\n","// import { FlowBase } from './FlowBase';\n\nexport function ClosestFlowBase(obj: any): any | null {\n  let ancestor = obj.parent;\n  while (ancestor) {\n    if (ancestor.hasOwnProperty(\"iamFlowbase\") && ancestor.iamFlowbase()) {\n      return ancestor as any;\n    }\n\n    ancestor = ancestor.parent;\n  }\n\n  return null;\n}\n","import { DebugMetadata } from \"../../../engine/DebugMetadata\";\n\nexport class Identifier {\n  public name: string;\n  public debugMetadata: DebugMetadata | null = null;\n\n  constructor(name: string) {\n    this.name = name;\n  }\n\n  public static Done(): Identifier {\n    return new Identifier(\"DONE\");\n  }\n\n  public readonly toString = (): string => this.name || \"undefined identifer\";\n}\n","import { Argument } from \"../Argument\";\nimport { Choice } from \"../Choice\";\nimport { Divert } from \"../Divert/Divert\";\nimport { DivertTarget } from \"../Divert/DivertTarget\";\nimport { FlowLevel } from \"./FlowLevel\";\nimport { Gather } from \"../Gather/Gather\";\nimport { INamedContent } from \"../../../../engine/INamedContent\";\n// import { Knot } from '../Knot';\nimport { ParsedObject } from \"../Object\";\nimport { Path } from \"../Path\";\nimport { ReturnType } from \"../ReturnType\";\nimport { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { Divert as RuntimeDivert } from \"../../../../engine/Divert\";\nimport { InkObject as RuntimeObject } from \"../../../../engine/Object\";\nimport { VariableAssignment as RuntimeVariableAssignment } from \"../../../../engine/VariableAssignment\";\n//import { Story } from '../Story';\nimport { SymbolType } from \"../SymbolType\";\nimport { VariableAssignment } from \"../Variable/VariableAssignment\";\nimport { Weave } from \"../Weave\";\nimport { ClosestFlowBase } from \"./ClosestFlowBase\";\nimport { Identifier } from \"../Identifier\";\nimport { asOrNull } from \"../../../../engine/TypeAssertion\";\n\ntype VariableResolveResult = {\n  found: boolean;\n  isGlobal: boolean;\n  isArgument: boolean;\n  isTemporary: boolean;\n  ownerFlow: FlowBase;\n};\n\n// Base class for Knots and Stitches\nexport abstract class FlowBase extends ParsedObject implements INamedContent {\n  public abstract readonly flowLevel: FlowLevel;\n\n  public _rootWeave: Weave | null = null;\n  public _subFlowsByName: Map<string, FlowBase> = new Map();\n  public _startingSubFlowDivert: RuntimeDivert | null = null;\n  public _startingSubFlowRuntime: RuntimeObject | null = null;\n  public _firstChildFlow: FlowBase | null = null;\n  public variableDeclarations: Map<string, VariableAssignment> = new Map();\n\n  get hasParameters() {\n    return this.args !== null && this.args.length > 0;\n  }\n\n  get subFlowsByName() {\n    return this._subFlowsByName;\n  }\n\n  get typeName(): string {\n    if (this.isFunction) {\n      return \"Function\";\n    }\n\n    return String(this.flowLevel);\n  }\n\n  get name(): string | null {\n    return this.identifier?.name || null;\n  }\n\n  public identifier: Identifier | null = null;\n  public args: Argument[] | null = null;\n\n  constructor(\n    identifier: Identifier | null,\n    topLevelObjects: ParsedObject[] | null = null,\n    args: Argument[] | null = null,\n    public readonly isFunction: boolean = false,\n    isIncludedStory: boolean = false\n  ) {\n    super();\n\n    this.identifier = identifier;\n    this.args = args;\n\n    if (topLevelObjects === null) {\n      topLevelObjects = [];\n    }\n\n    // Used by story to add includes\n    this.PreProcessTopLevelObjects(topLevelObjects);\n\n    topLevelObjects = this.SplitWeaveAndSubFlowContent(\n      topLevelObjects,\n      this.GetType() == \"Story\" && !isIncludedStory\n    );\n\n    this.AddContent(topLevelObjects);\n  }\n\n  public iamFlowbase = () => true;\n\n  public readonly SplitWeaveAndSubFlowContent = (\n    contentObjs: ParsedObject[],\n    isRootStory: boolean\n  ): ParsedObject[] => {\n    const weaveObjs: ParsedObject[] = [];\n    const subFlowObjs: ParsedObject[] = [];\n\n    this._subFlowsByName = new Map();\n\n    for (const obj of contentObjs) {\n      const subFlow = asOrNull(obj, FlowBase);\n      if (subFlow) {\n        if (this._firstChildFlow === null) {\n          this._firstChildFlow = subFlow;\n        }\n\n        subFlowObjs.push(obj);\n        if (subFlow.identifier?.name) {\n          this._subFlowsByName.set(subFlow.identifier?.name, subFlow);\n        }\n      } else {\n        weaveObjs.push(obj);\n      }\n    }\n\n    // Implicit final gather in top level story for ending without warning that you run out of content\n    if (isRootStory) {\n      weaveObjs.push(\n        new Gather(null, 1),\n        new Divert(new Path(Identifier.Done()))\n      );\n    }\n\n    const finalContent: ParsedObject[] = [];\n\n    if (weaveObjs.length > 0) {\n      this._rootWeave = new Weave(weaveObjs, 0);\n      finalContent.push(this._rootWeave);\n    }\n\n    if (subFlowObjs.length > 0) {\n      finalContent.push(...subFlowObjs);\n    }\n    return finalContent;\n  };\n\n  public PreProcessTopLevelObjects(_: ParsedObject[]): void {\n    // empty by default, used by Story to process included file references\n  }\n\n  public VariableResolveResult?: VariableResolveResult | null | undefined;\n\n  public ResolveVariableWithName = (\n    varName: string,\n    fromNode: ParsedObject\n  ): VariableResolveResult => {\n    const result: VariableResolveResult = {} as any;\n\n    // Search in the stitch / knot that owns the node first\n    const ownerFlow = fromNode === null ? this : ClosestFlowBase(fromNode);\n\n    if (ownerFlow) {\n      // Argument\n      if (ownerFlow.args !== null) {\n        for (const arg of ownerFlow.args) {\n          if (arg.identifier?.name === varName) {\n            result.found = true;\n            result.isArgument = true;\n            result.ownerFlow = ownerFlow;\n            return result;\n          }\n        }\n      }\n\n      // Temp\n      if (\n        ownerFlow !== this.story &&\n        ownerFlow.variableDeclarations.has(varName)\n      ) {\n        result.found = true;\n        result.ownerFlow = ownerFlow;\n        result.isTemporary = true;\n\n        return result;\n      }\n    }\n\n    // Global\n    if (this.story.variableDeclarations.has(varName)) {\n      result.found = true;\n      result.ownerFlow = this.story;\n      result.isGlobal = true;\n\n      return result;\n    }\n\n    result.found = false;\n\n    return result;\n  };\n\n  public AddNewVariableDeclaration = (varDecl: VariableAssignment): void => {\n    const varName = varDecl.variableName;\n    if (this.variableDeclarations.has(varName)) {\n      const varab = this.variableDeclarations.get(varName)!;\n      let prevDeclError = \"\";\n      const debugMetadata = varab.debugMetadata;\n      if (debugMetadata) {\n        prevDeclError = ` (${varab.debugMetadata})`;\n      }\n\n      this.Error(\n        `found declaration variable '${varName}' that was already declared${prevDeclError}`,\n        varDecl,\n        false\n      );\n\n      return;\n    }\n\n    this.variableDeclarations.set(varDecl.variableName, varDecl);\n  };\n\n  public ResolveWeavePointNaming = (): void => {\n    // Find all weave points and organise them by name ready for\n    // diverting. Also detect naming collisions.\n    if (this._rootWeave) {\n      this._rootWeave.ResolveWeavePointNaming();\n    }\n\n    for (const [, value] of this._subFlowsByName) {\n      if (value.hasOwnProperty(\"ResolveWeavePointNaming\")) {\n        value.ResolveWeavePointNaming();\n      }\n    }\n  };\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject => {\n    let foundReturn: ReturnType | null = null;\n    if (this.isFunction) {\n      this.CheckForDisallowedFunctionFlowControl();\n    } else if (\n      this.flowLevel === FlowLevel.Knot ||\n      this.flowLevel === FlowLevel.Stitch\n    ) {\n      // Non-functon: Make sure knots and stitches don't attempt to use Return statement\n      foundReturn = this.Find(ReturnType)();\n\n      if (foundReturn !== null) {\n        this.Error(\n          `Return statements can only be used in knots that are declared as functions: == function ${this.identifier} ==`,\n          foundReturn\n        );\n      }\n    }\n\n    const container = new RuntimeContainer();\n    container.name = this.identifier?.name as string;\n\n    if (this.story.countAllVisits) {\n      container.visitsShouldBeCounted = true;\n    }\n\n    this.GenerateArgumentVariableAssignments(container);\n\n    // Run through content defined for this knot/stitch:\n    //  - First of all, any initial content before a sub-stitch\n    //    or any weave content is added to the main content container\n    //  - The first inner knot/stitch is automatically entered, while\n    //    the others are only accessible by an explicit divert\n    //       - The exception to this rule is if the knot/stitch takes\n    //         parameters, in which case it can't be auto-entered.\n    //  - Any Choices and Gathers (i.e. IWeavePoint) found are\n    //    processsed by GenerateFlowContent.\n    let contentIdx: number = 0;\n    while (this.content !== null && contentIdx < this.content.length) {\n      const obj: ParsedObject = this.content[contentIdx];\n\n      // Inner knots and stitches\n      if (obj instanceof FlowBase) {\n        const childFlow: FlowBase = obj;\n        const childFlowRuntime = childFlow.runtimeObject;\n\n        // First inner stitch - automatically step into it\n        // 20/09/2016 - let's not auto step into knots\n        if (\n          contentIdx === 0 &&\n          !childFlow.hasParameters &&\n          this.flowLevel === FlowLevel.Knot\n        ) {\n          this._startingSubFlowDivert = new RuntimeDivert();\n          container.AddContent(this._startingSubFlowDivert);\n          this._startingSubFlowRuntime = childFlowRuntime;\n        }\n\n        // Check for duplicate knots/stitches with same name\n        const namedChild = childFlowRuntime as RuntimeObject & INamedContent;\n        const existingChild: INamedContent | null =\n          container.namedContent.get(namedChild.name!) || null;\n\n        if (existingChild) {\n          const errorMsg = `${this.GetType()} already contains flow named '${\n            namedChild.name\n          }' (at ${((existingChild as any) as RuntimeObject).debugMetadata})`;\n          this.Error(errorMsg, childFlow);\n        }\n\n        container.AddToNamedContentOnly(namedChild);\n      } else if (obj) {\n        // Other content (including entire Weaves that were grouped in the constructor)\n        // At the time of writing, all FlowBases have a maximum of one piece of \"other content\"\n        // and it's always the root Weave\n        container.AddContent(obj.runtimeObject);\n      }\n\n      contentIdx += 1;\n    }\n\n    // CHECK FOR FINAL LOOSE ENDS!\n    // Notes:\n    //  - Functions don't need to terminate - they just implicitly return\n    //  - If return statement was found, don't continue finding warnings for missing control flow,\n    // since it's likely that a return statement has been used instead of a ->-> or something,\n    // or the writer failed to mark the knot as a function.\n    //  - _rootWeave may be null if it's a knot that only has stitches\n    if (\n      this.flowLevel !== FlowLevel.Story &&\n      !this.isFunction &&\n      this._rootWeave !== null &&\n      foundReturn === null\n    ) {\n      this._rootWeave.ValidateTermination(this.WarningInTermination);\n    }\n\n    return container;\n  };\n\n  public readonly GenerateArgumentVariableAssignments = (\n    container: RuntimeContainer\n  ): void => {\n    if (this.args === null || this.args.length === 0) {\n      return;\n    }\n\n    // Assign parameters in reverse since they'll be popped off the evaluation stack\n    // No need to generate EvalStart and EvalEnd since there's nothing being pushed\n    // back onto the evaluation stack.\n    for (let ii = this.args.length - 1; ii >= 0; --ii) {\n      const paramName = this.args[ii].identifier?.name || null;\n      const assign = new RuntimeVariableAssignment(paramName, true);\n      container.AddContent(assign);\n    }\n  };\n\n  public readonly ContentWithNameAtLevel = (\n    name: string,\n    level: FlowLevel | null = null,\n    deepSearch: boolean = false\n  ): ParsedObject | null => {\n    // Referencing self?\n    if (level === this.flowLevel || level === null) {\n      if (name === this.identifier?.name) {\n        return this;\n      }\n    }\n\n    if (level === FlowLevel.WeavePoint || level === null) {\n      let weavePointResult: ParsedObject | null = null;\n\n      if (this._rootWeave) {\n        weavePointResult = this._rootWeave.WeavePointNamed(\n          name\n        ) as ParsedObject;\n        if (weavePointResult) {\n          return weavePointResult;\n        }\n      }\n\n      // Stop now if we only wanted a result if it's a weave point?\n      if (level === FlowLevel.WeavePoint) {\n        return deepSearch ? this.DeepSearchForAnyLevelContent(name) : null;\n      }\n    }\n\n    // If this flow would be incapable of containing the requested level, early out\n    // (e.g. asking for a Knot from a Stitch)\n    if (level !== null && level < this.flowLevel) {\n      return null;\n    }\n\n    let subFlow: FlowBase | null = this._subFlowsByName.get(name) || null;\n\n    if (subFlow && (level === null || level === subFlow.flowLevel)) {\n      return subFlow;\n    }\n\n    return deepSearch ? this.DeepSearchForAnyLevelContent(name) : null;\n  };\n\n  public readonly DeepSearchForAnyLevelContent = (name: string) => {\n    const weaveResultSelf = this.ContentWithNameAtLevel(\n      name,\n      FlowLevel.WeavePoint,\n      false\n    );\n\n    if (weaveResultSelf) {\n      return weaveResultSelf;\n    }\n\n    for (const [, value] of this._subFlowsByName) {\n      const deepResult = value.ContentWithNameAtLevel(name, null, true);\n\n      if (deepResult) {\n        return deepResult;\n      }\n    }\n\n    return null;\n  };\n\n  public ResolveReferences(context: any): void {\n    if (this._startingSubFlowDivert) {\n      if (!this._startingSubFlowRuntime) {\n        throw new Error();\n      }\n\n      this._startingSubFlowDivert.targetPath = this._startingSubFlowRuntime.path;\n    }\n\n    super.ResolveReferences(context);\n\n    // Check validity of parameter names\n    if (this.args !== null) {\n      for (const arg of this.args) {\n        context.CheckForNamingCollisions(\n          this,\n          arg.identifier,\n          SymbolType.Arg,\n          \"argument\"\n        );\n      }\n\n      // Separately, check for duplicate arugment names, since they aren't Parsed.Objects,\n      // so have to be checked independently.\n      for (let ii = 0; ii < this.args.length; ii += 1) {\n        for (let jj = ii + 1; jj < this.args.length; jj += 1) {\n          if (\n            this.args[ii].identifier?.name == this.args[jj].identifier?.name\n          ) {\n            this.Error(\n              `Multiple arguments with the same name: '${this.args[ii].identifier}'`\n            );\n          }\n        }\n      }\n    }\n\n    // Check naming collisions for knots and stitches\n    if (this.flowLevel !== FlowLevel.Story) {\n      // Weave points aren't FlowBases, so this will only be knot or stitch\n      const symbolType =\n        this.flowLevel === FlowLevel.Knot\n          ? SymbolType.Knot\n          : SymbolType.SubFlowAndWeave;\n\n      context.CheckForNamingCollisions(this, this.identifier, symbolType);\n    }\n  }\n\n  public readonly CheckForDisallowedFunctionFlowControl = (): void => {\n    // if (!(this instanceof Knot)) { // cannont use Knot here because of circular dependancy\n    if (this.flowLevel !== FlowLevel.Knot) {\n      this.Error(\n        \"Functions cannot be stitches - i.e. they should be defined as '== function myFunc ==' rather than internal to another knot.\"\n      );\n    }\n\n    // Not allowed sub-flows\n    for (const [key, value] of this._subFlowsByName) {\n      this.Error(\n        `Functions may not contain stitches, but saw '${key}' within the function '${this.identifier}'`,\n        value\n      );\n    }\n\n    if (!this._rootWeave) {\n      throw new Error();\n    }\n\n    const allDiverts = this._rootWeave.FindAll<Divert>(Divert)();\n    for (const divert of allDiverts) {\n      if (!divert.isFunctionCall && !(divert.parent instanceof DivertTarget)) {\n        this.Error(\n          `Functions may not contain diverts, but saw '${divert}'`,\n          divert\n        );\n      }\n    }\n\n    const allChoices = this._rootWeave.FindAll<Choice>(Choice)();\n    for (const choice of allChoices) {\n      this.Error(\n        `Functions may not contain choices, but saw '${choice}'`,\n        choice\n      );\n    }\n  };\n\n  public readonly WarningInTermination = (terminatingObject: ParsedObject) => {\n    let message: string =\n      \"Apparent loose end exists where the flow runs out. Do you need a '-> DONE' statement, choice or divert?\";\n    if (terminatingObject.parent === this._rootWeave && this._firstChildFlow) {\n      message = `${message} Note that if you intend to enter '${this._firstChildFlow.identifier}' next, you need to divert to it explicitly.`;\n    }\n\n    const terminatingDivert = asOrNull(terminatingObject, Divert);\n    if (terminatingDivert && terminatingDivert.isTunnel) {\n      message += ` When final tunnel to '${terminatingDivert.target} ->' returns it won't have anywhere to go.`;\n    }\n\n    this.Warning(message, terminatingObject);\n  };\n\n  public readonly toString = (): string =>\n    `${this.typeName} '${this.identifier}'`;\n}\n","import { Container as RuntimeContainer } from \"../../../engine/Container\";\nimport { ParsedObject } from \"./Object\";\nimport { InkObject as RuntimeObject } from \"../../../engine/Object\";\nimport { Text } from \"./Text\";\nimport { asOrNull } from \"../../../engine/TypeAssertion\";\n\nexport class ContentList extends ParsedObject {\n  public dontFlatten: boolean = false;\n\n  get runtimeContainer(): RuntimeContainer {\n    return this.runtimeObject as RuntimeContainer;\n  }\n\n  constructor(objects?: ParsedObject[], ...moreObjects: ParsedObject[]) {\n    super();\n\n    if (objects) {\n      this.AddContent(objects);\n    }\n\n    if (moreObjects) {\n      this.AddContent(moreObjects);\n    }\n  }\n\n  public readonly TrimTrailingWhitespace = (): void => {\n    for (let ii = this.content.length - 1; ii >= 0; --ii) {\n      const text = asOrNull(this.content[ii], Text);\n      if (text === null) {\n        break;\n      }\n\n      text.text = text.text.replace(new RegExp(/[ \\t]/g), \"\");\n      if (text.text.length === 0) {\n        this.content.splice(ii, 1);\n      } else {\n        break;\n      }\n    }\n  };\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject => {\n    const container = new RuntimeContainer();\n    if (this.content !== null) {\n      for (const obj of this.content) {\n        const contentObjRuntime = obj.runtimeObject;\n\n        // Some objects (e.g. author warnings) don't generate runtime objects\n        if (contentObjRuntime) {\n          container.AddContent(contentObjRuntime);\n        }\n      }\n    }\n\n    if (this.dontFlatten) {\n      this.story.DontFlattenContainer(container);\n    }\n\n    return container;\n  };\n\n  public toString = (): string => `ContentList(${this.content.join(\", \")})`;\n}\n","import { InkObject } from \"./Object\";\nimport { Path } from \"./Path\";\n\nexport class VariableReference extends InkObject {\n  public name: string | null;\n  public pathForCount: Path | null = null;\n\n  get containerForCount() {\n    if (this.pathForCount === null) return null;\n    return this.ResolvePath(this.pathForCount).container;\n  }\n  get pathStringForCount() {\n    if (this.pathForCount === null) return null;\n\n    return this.CompactPathString(this.pathForCount);\n  }\n  set pathStringForCount(value: string | null) {\n    if (value === null) this.pathForCount = null;\n    else this.pathForCount = new Path(value);\n  }\n\n  constructor(name: string | null = null) {\n    super();\n    this.name = name;\n  }\n\n  public toString() {\n    if (this.name != null) {\n      return \"var(\" + this.name + \")\";\n    } else {\n      let pathStr = this.pathStringForCount;\n      return \"read_count(\" + pathStr + \")\";\n    }\n  }\n}\n","import { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { ContentList } from \"../ContentList\";\nimport { Expression } from \"../Expression/Expression\";\nimport { FlowBase } from \"../Flow/FlowBase\";\nimport { ParsedObject } from \"../Object\";\nimport { Path } from \"../Path\";\nimport { Story } from \"../Story\";\nimport { VariableReference as RuntimeVariableReference } from \"../../../../engine/VariableReference\";\nimport { Weave } from \"../Weave\";\nimport { Identifier } from \"../Identifier\";\nimport { asOrNull, filterUndef } from \"../../../../engine/TypeAssertion\";\n\nexport class VariableReference extends Expression {\n  private _runtimeVarRef: RuntimeVariableReference | null = null;\n\n  // - Normal variables have a single item in their \"path\"\n  // - Knot/stitch names for read counts are actual dot-separated paths\n  //   (though this isn't actually used at time of writing)\n  // - List names are dot separated: listName.itemName (or just itemName)\n  get name() {\n    return this.path.join(\".\");\n  }\n\n  get path(): string[] {\n    return this.pathIdentifiers.map((id) => id.name!).filter(filterUndef);\n  }\n\n  get identifier(): Identifier | null {\n    if (!this.pathIdentifiers || this.pathIdentifiers.length == 0) {\n      return null;\n    }\n    const name = this.path.join(\".\");\n    const id = new Identifier(name);\n\n    return id;\n  }\n\n  // Only known after GenerateIntoContainer has run\n  public isConstantReference: boolean = false;\n  public isListItemReference: boolean = false;\n\n  get runtimeVarRef() {\n    return this._runtimeVarRef;\n  }\n\n  constructor(public readonly pathIdentifiers: Identifier[]) {\n    super();\n  }\n\n  public readonly GenerateIntoContainer = (\n    container: RuntimeContainer\n  ): void => {\n    let constantValue: Expression | null | undefined = this.story.constants.get(\n      this.name\n    );\n\n    // If it's a constant reference, just generate the literal expression value\n    // It's okay to access the constants at code generation time, since the\n    // first thing the ExportRuntime function does it search for all the constants\n    // in the story hierarchy, so they're all available.\n    if (constantValue) {\n      constantValue.GenerateConstantIntoContainer(container);\n      this.isConstantReference = true;\n\n      return;\n    }\n\n    this._runtimeVarRef = new RuntimeVariableReference(this.name);\n\n    // List item reference?\n    // Path might be to a list (listName.listItemName or just listItemName)\n    if (this.path.length === 1 || this.path.length === 2) {\n      let listItemName: string = \"\";\n      let listName: string = \"\";\n\n      if (this.path.length === 1) {\n        listItemName = this.path[0];\n      } else {\n        listName = this.path[0];\n        listItemName = this.path[1];\n      }\n\n      const listItem = this.story.ResolveListItem(listName, listItemName, this);\n\n      if (listItem) {\n        this.isListItemReference = true;\n      }\n    }\n\n    container.AddContent(this._runtimeVarRef);\n  };\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n\n    // Work is already done if it's a constant or list item reference\n    if (this.isConstantReference || this.isListItemReference) {\n      return;\n    }\n\n    // Is it a read count?\n    const parsedPath = new Path(this.pathIdentifiers);\n    const targetForCount: ParsedObject | null = parsedPath.ResolveFromContext(\n      this\n    );\n    if (targetForCount) {\n      if (!targetForCount.containerForCounting) {\n        throw new Error();\n      }\n\n      targetForCount.containerForCounting.visitsShouldBeCounted = true;\n\n      // If this is an argument to a function that wants a variable to be\n      // passed by reference, then the Parsed.Divert will have generated a\n      // Runtime.VariablePointerValue instead of allowing this object\n      // to generate its RuntimeVariableReference. This only happens under\n      // error condition since we shouldn't be passing a read count by\n      // reference, but we don't want it to crash!\n      if (this._runtimeVarRef === null) {\n        return;\n      }\n\n      this._runtimeVarRef.pathForCount = targetForCount.runtimePath;\n      this._runtimeVarRef.name = null;\n\n      // Check for very specific writer error: getting read count and\n      // printing it as content rather than as a piece of logic\n      // e.g. Writing {myFunc} instead of {myFunc()}\n      let targetFlow = asOrNull(targetForCount, FlowBase);\n      if (targetFlow && targetFlow.isFunction) {\n        // Is parent context content rather than logic?\n        if (\n          parent instanceof Weave ||\n          parent instanceof ContentList ||\n          parent instanceof FlowBase\n        ) {\n          this.Warning(\n            `'${targetFlow.identifier}' being used as read count rather than being called as function. Perhaps you intended to write ${targetFlow.identifier}()`\n          );\n        }\n      }\n\n      return;\n    }\n\n    // Couldn't find this multi-part path at all, whether as a divert\n    // target or as a list item reference.\n    if (this.path.length > 1) {\n      let errorMsg = `Could not find target for read count: ${parsedPath}`;\n      if (this.path.length <= 2) {\n        errorMsg += `, or couldn't find list item with the name ${this.path.join(\n          \",\"\n        )}`;\n      }\n\n      this.Error(errorMsg);\n\n      return;\n    }\n\n    if (!context.ResolveVariableWithName(this.name, this).found) {\n      this.Error(`Unresolved variable: ${this}`, this);\n    }\n  }\n\n  public readonly toString = (): string => `{${this.path.join(\".\")}}`;\n}\n","﻿import { Container as RuntimeContainer } from \"../../../engine/Container\";\nimport { ControlCommand as RuntimeControlCommand } from \"../../../engine/ControlCommand\";\nimport { Divert } from \"./Divert/Divert\";\nimport { Divert as RuntimeDivert } from \"../../../engine/Divert\";\nimport { DivertTarget } from \"./Divert/DivertTarget\";\nimport { Expression } from \"./Expression/Expression\";\nimport { InkList as RuntimeInkList } from \"../../../engine/InkList\";\nimport { ListValue } from \"../../../engine/Value\";\nimport { NativeFunctionCall } from \"../../../engine/NativeFunctionCall\";\nimport { NumberExpression } from \"./Expression/NumberExpression\";\nimport { Path } from \"./Path\";\nimport { Story } from \"./Story\";\nimport { StringValue } from \"../../../engine/Value\";\nimport { VariableReference } from \"./Variable/VariableReference\";\nimport { Identifier } from \"./Identifier\";\nimport { asOrNull } from \"../../../engine/TypeAssertion\";\n\nexport class FunctionCall extends Expression {\n  public static readonly IsBuiltIn = (name: string): boolean => {\n    if (NativeFunctionCall.CallExistsWithName(name)) {\n      return true;\n    }\n\n    return (\n      name === \"CHOICE_COUNT\" ||\n      name === \"TURNS_SINCE\" ||\n      name === \"TURNS\" ||\n      name === \"RANDOM\" ||\n      name === \"SEED_RANDOM\" ||\n      name === \"LIST_VALUE\" ||\n      name === \"LIST_RANDOM\" ||\n      name === \"READ_COUNT\"\n    );\n  };\n\n  private _proxyDivert: Divert;\n  get proxyDivert(): Divert {\n    return this._proxyDivert;\n  }\n  private _divertTargetToCount: DivertTarget | null = null;\n  private _variableReferenceToCount: VariableReference | null = null;\n\n  get name(): string {\n    return (this._proxyDivert.target as Path).firstComponent || \"\";\n  }\n\n  get args(): Expression[] {\n    return this._proxyDivert.args;\n  }\n\n  get runtimeDivert(): RuntimeDivert {\n    return this._proxyDivert.runtimeDivert;\n  }\n\n  get isChoiceCount(): boolean {\n    return this.name === \"CHOICE_COUNT\";\n  }\n\n  get isTurns(): boolean {\n    return this.name === \"TURNS\";\n  }\n\n  get isTurnsSince(): boolean {\n    return this.name === \"TURNS_SINCE\";\n  }\n\n  get isRandom(): boolean {\n    return this.name === \"RANDOM\";\n  }\n\n  get isSeedRandom(): boolean {\n    return this.name === \"SEED_RANDOM\";\n  }\n\n  get isListRange(): boolean {\n    return this.name === \"LIST_RANGE\";\n  }\n\n  get isListRandom(): boolean {\n    return this.name === \"LIST_RANDOM\";\n  }\n\n  get isReadCount(): boolean {\n    return this.name === \"READ_COUNT\";\n  }\n\n  public shouldPopReturnedValue: boolean = false;\n\n  constructor(functionName: Identifier, args: Expression[]) {\n    super();\n\n    this._proxyDivert = new Divert(new Path(functionName), args);\n    this._proxyDivert.isFunctionCall = true;\n    this.AddContent(this._proxyDivert);\n  }\n\n  public readonly GenerateIntoContainer = (\n    container: RuntimeContainer\n  ): void => {\n    const foundList = this.story.ResolveList(this.name);\n\n    let usingProxyDivert: boolean = false;\n\n    if (this.isChoiceCount) {\n      if (this.args.length > 0) {\n        this.Error(\"The CHOICE_COUNT() function shouldn't take any arguments\");\n      }\n\n      container.AddContent(RuntimeControlCommand.ChoiceCount());\n    } else if (this.isTurns) {\n      if (this.args.length > 0) {\n        this.Error(\"The TURNS() function shouldn't take any arguments\");\n      }\n\n      container.AddContent(RuntimeControlCommand.Turns());\n    } else if (this.isTurnsSince || this.isReadCount) {\n      const divertTarget = asOrNull(this.args[0], DivertTarget);\n      const variableDivertTarget = asOrNull(this.args[0], VariableReference);\n\n      if (\n        this.args.length !== 1 ||\n        (divertTarget === null && variableDivertTarget === null)\n      ) {\n        this.Error(\n          `The ${this.name}() function should take one argument: a divert target to the target knot, stitch, gather or choice you want to check. e.g. TURNS_SINCE(-> myKnot)`\n        );\n        return;\n      }\n\n      if (divertTarget) {\n        this._divertTargetToCount = divertTarget;\n        this.AddContent(this._divertTargetToCount);\n\n        this._divertTargetToCount.GenerateIntoContainer(container);\n      } else if (variableDivertTarget) {\n        this._variableReferenceToCount = variableDivertTarget;\n        this.AddContent(this._variableReferenceToCount);\n\n        this._variableReferenceToCount.GenerateIntoContainer(container);\n      }\n\n      if (this.isTurnsSince) {\n        container.AddContent(RuntimeControlCommand.TurnsSince());\n      } else {\n        container.AddContent(RuntimeControlCommand.ReadCount());\n      }\n    } else if (this.isRandom) {\n      if (this.args.length !== 2) {\n        this.Error(\n          \"RANDOM should take 2 parameters: a minimum and a maximum integer\"\n        );\n      }\n\n      // We can type check single values, but not complex expressions\n      for (let ii = 0; ii < this.args.length; ii += 1) {\n        const num = asOrNull(this.args[ii], NumberExpression);\n        if (num && !num.isInt()) {\n          const paramName: string = ii === 0 ? \"minimum\" : \"maximum\";\n          this.Error(`RANDOM's ${paramName} parameter should be an integer`);\n        }\n\n        this.args[ii].GenerateIntoContainer(container);\n      }\n\n      container.AddContent(RuntimeControlCommand.Random());\n    } else if (this.isSeedRandom) {\n      if (this.args.length !== 1) {\n        this.Error(\"SEED_RANDOM should take 1 parameter - an integer seed\");\n      }\n\n      const num = asOrNull(this.args[0], NumberExpression);\n      if (num && !num.isInt()) {\n        this.Error(\"SEED_RANDOM's parameter should be an integer seed\");\n      }\n\n      this.args[0].GenerateIntoContainer(container);\n\n      container.AddContent(RuntimeControlCommand.SeedRandom());\n    } else if (this.isListRange) {\n      if (this.args.length !== 3) {\n        this.Error(\n          \"LIST_RANGE should take 3 parameters - a list, a min and a max\"\n        );\n      }\n\n      for (let ii = 0; ii < this.args.length; ii += 1) {\n        this.args[ii].GenerateIntoContainer(container);\n      }\n\n      container.AddContent(RuntimeControlCommand.ListRange());\n    } else if (this.isListRandom) {\n      if (this.args.length !== 1) {\n        this.Error(\"LIST_RANDOM should take 1 parameter - a list\");\n      }\n\n      this.args[0].GenerateIntoContainer(container);\n\n      container.AddContent(RuntimeControlCommand.ListRandom());\n    } else if (NativeFunctionCall.CallExistsWithName(this.name)) {\n      const nativeCall = NativeFunctionCall.CallWithName(this.name);\n      if (nativeCall.numberOfParameters !== this.args.length) {\n        let msg = `${name} should take ${nativeCall.numberOfParameters} parameter`;\n        if (nativeCall.numberOfParameters > 1) {\n          msg += \"s\";\n        }\n\n        this.Error(msg);\n      }\n\n      for (let ii = 0; ii < this.args.length; ii += 1) {\n        this.args[ii].GenerateIntoContainer(container);\n      }\n\n      container.AddContent(NativeFunctionCall.CallWithName(this.name));\n    } else if (foundList !== null) {\n      if (this.args.length > 1) {\n        this.Error(\n          \"Can currently only construct a list from one integer (or an empty list from a given list definition)\"\n        );\n      }\n\n      // List item from given int\n      if (this.args.length === 1) {\n        container.AddContent(new StringValue(this.name));\n        this.args[0].GenerateIntoContainer(container);\n        container.AddContent(RuntimeControlCommand.ListFromInt());\n      } else {\n        // Empty list with given origin.\n        const list = new RuntimeInkList();\n        list.SetInitialOriginName(this.name);\n        container.AddContent(new ListValue(list));\n      }\n    } else {\n      // Normal function call\n      container.AddContent(this._proxyDivert.runtimeObject);\n      usingProxyDivert = true;\n    }\n\n    // Don't attempt to resolve as a divert if we're not doing a normal function call\n    if (!usingProxyDivert) {\n      this.content.splice(this.content.indexOf(this._proxyDivert), 1);\n    }\n\n    // Function calls that are used alone on a tilda-based line:\n    //  ~ func()\n    // Should tidy up any returned value from the evaluation stack,\n    // since it's unused.\n    if (this.shouldPopReturnedValue) {\n      container.AddContent(RuntimeControlCommand.PopEvaluatedValue());\n    }\n  };\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n\n    // If we aren't using the proxy divert after all (e.g. if\n    // it's a native function call), but we still have arguments,\n    // we need to make sure they get resolved since the proxy divert\n    // is no longer in the content array.\n    if (!this.content.includes(this._proxyDivert) && this.args !== null) {\n      for (const arg of this.args) {\n        arg.ResolveReferences(context);\n      }\n    }\n\n    if (this._divertTargetToCount) {\n      const divert = this._divertTargetToCount.divert;\n      const attemptingTurnCountOfVariableTarget =\n        divert.runtimeDivert.variableDivertName != null;\n\n      if (attemptingTurnCountOfVariableTarget) {\n        this.Error(\n          `When getting the TURNS_SINCE() of a variable target, remove the '->' - i.e. it should just be TURNS_SINCE(${divert.runtimeDivert.variableDivertName})`\n        );\n\n        return;\n      }\n\n      const targetObject = divert.targetContent;\n      if (targetObject === null) {\n        if (!attemptingTurnCountOfVariableTarget) {\n          this.Error(\n            `Failed to find target for TURNS_SINCE: '${divert.target}'`\n          );\n        }\n      } else {\n        if (!targetObject.containerForCounting) {\n          throw new Error();\n        }\n\n        targetObject.containerForCounting.turnIndexShouldBeCounted = true;\n      }\n    } else if (this._variableReferenceToCount) {\n      const runtimeVarRef = this._variableReferenceToCount.runtimeVarRef;\n      if (!runtimeVarRef) {\n        throw new Error();\n      }\n\n      if (runtimeVarRef.pathForCount !== null) {\n        this.Error(\n          `Should be '${name}'(-> '${this._variableReferenceToCount.name}). Usage without the '->' only makes sense for variable targets.`\n        );\n      }\n    }\n  }\n\n  public readonly toString = (): string => {\n    const strArgs = this.args.join(\", \");\n    return `${this.name}(${strArgs})`;\n  };\n}\n","export enum SequenceType {\n  Stopping = 1, // default\n  Cycle = 2,\n  Shuffle = 4,\n  Once = 8,\n}\n","import { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { Expression } from \"./Expression\";\nimport { NativeFunctionCall } from \"../../../../engine/NativeFunctionCall\";\n\nexport class MultipleConditionExpression extends Expression {\n  get subExpressions(): Expression[] {\n    return this.content as Expression[];\n  }\n\n  constructor(conditionExpressions: Expression[]) {\n    super();\n\n    this.AddContent(conditionExpressions);\n  }\n\n  public readonly GenerateIntoContainer = (\n    container: RuntimeContainer\n  ): void => {\n    //    A && B && C && D\n    // => (((A B &&) C &&) D &&) etc\n    let isFirst: boolean = true;\n    for (const conditionExpr of this.subExpressions) {\n      conditionExpr.GenerateIntoContainer(container);\n\n      if (!isFirst) {\n        container.AddContent(NativeFunctionCall.CallWithName(\"&&\"));\n      }\n\n      isFirst = false;\n    }\n  };\n}\n","﻿import { BinaryExpression } from \"../Expression/BinaryExpression\";\nimport { Choice } from \"../Choice\";\nimport { Conditional } from \"../Conditional/Conditional\";\nimport { ConditionalSingleBranch } from \"../Conditional/ConditionalSingleBranch\";\nimport { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { ParsedObject } from \"../Object\";\nimport { Divert } from \"./Divert\";\nimport { Divert as RuntimeDivert } from \"../../../../engine/Divert\";\nimport { DivertTargetValue } from \"../../../../engine/Value\";\nimport { Expression } from \"../Expression/Expression\";\nimport { FlowBase } from \"../Flow/FlowBase\";\nimport { FunctionCall } from \"../FunctionCall\";\nimport { MultipleConditionExpression } from \"../Expression/MultipleConditionExpression\";\nimport { Story } from \"../Story\";\nimport { VariableReference } from \"../Variable/VariableReference\";\nimport { asOrNull } from \"../../../../engine/TypeAssertion\";\n\nexport class DivertTarget extends Expression {\n  private _runtimeDivert: RuntimeDivert | null = null;\n  get runtimeDivert(): RuntimeDivert {\n    if (!this._runtimeDivert) {\n      throw new Error();\n    }\n\n    return this._runtimeDivert;\n  }\n\n  private _runtimeDivertTargetValue: DivertTargetValue | null = null;\n  get runtimeDivertTargetValue(): DivertTargetValue {\n    if (!this._runtimeDivertTargetValue) {\n      throw new Error();\n    }\n\n    return this._runtimeDivertTargetValue;\n  }\n\n  public divert: Divert;\n\n  constructor(divert: Divert) {\n    super();\n\n    this.divert = this.AddContent(divert) as Divert;\n  }\n\n  public readonly GenerateIntoContainer = (\n    container: RuntimeContainer\n  ): void => {\n    this.divert.GenerateRuntimeObject();\n\n    this._runtimeDivert = this.divert.runtimeDivert as RuntimeDivert;\n    this._runtimeDivertTargetValue = new DivertTargetValue();\n\n    container.AddContent(this.runtimeDivertTargetValue);\n  };\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n\n    if (this.divert.isDone || this.divert.isEnd) {\n      this.Error(\n        `Can't use -> DONE or -> END as variable divert targets`,\n        this\n      );\n\n      return;\n    }\n\n    let usageContext: ParsedObject | null = this;\n    while (usageContext && usageContext instanceof Expression) {\n      let badUsage: boolean = false;\n      let foundUsage: boolean = false;\n\n      const usageParent: any = (usageContext as Expression).parent;\n      if (usageParent instanceof BinaryExpression) {\n        // Only allowed to compare for equality\n\n        const binaryExprParent = usageParent;\n        if (\n          binaryExprParent.opName !== \"==\" &&\n          binaryExprParent.opName !== \"!=\"\n        ) {\n          badUsage = true;\n        } else {\n          if (\n            !(\n              binaryExprParent.leftExpression instanceof DivertTarget ||\n              binaryExprParent.leftExpression instanceof VariableReference\n            )\n          ) {\n            badUsage = true;\n          } else if (\n            !(\n              binaryExprParent.rightExpression instanceof DivertTarget ||\n              binaryExprParent.rightExpression instanceof VariableReference\n            )\n          ) {\n            badUsage = true;\n          }\n        }\n\n        foundUsage = true;\n      } else if (usageParent instanceof FunctionCall) {\n        const funcCall = usageParent;\n        if (!funcCall.isTurnsSince && !funcCall.isReadCount) {\n          badUsage = true;\n        }\n\n        foundUsage = true;\n      } else if (usageParent instanceof Expression) {\n        badUsage = true;\n        foundUsage = true;\n      } else if (usageParent instanceof MultipleConditionExpression) {\n        badUsage = true;\n        foundUsage = true;\n      } else if (\n        usageParent instanceof Choice &&\n        (usageParent as Choice).condition === usageContext\n      ) {\n        badUsage = true;\n        foundUsage = true;\n      } else if (\n        usageParent instanceof Conditional ||\n        usageParent instanceof ConditionalSingleBranch\n      ) {\n        badUsage = true;\n        foundUsage = true;\n      }\n\n      if (badUsage) {\n        this.Error(\n          `Can't use a divert target like that. Did you intend to call '${this.divert.target}' as a function: likeThis(), or check the read count: likeThis, with no arrows?`,\n          this\n        );\n      }\n\n      if (foundUsage) {\n        break;\n      }\n\n      usageContext = usageParent;\n    }\n\n    // Example ink for this case:\n    //\n    //     VAR x = -> blah\n    //\n    // ...which means that \"blah\" is expected to be a literal stitch target rather\n    // than a variable name. We can't really intelligently recover from this (e.g. if blah happens to\n    // contain a divert target itself) since really we should be generating a variable reference\n    // rather than a concrete DivertTarget, so we list it as an error.\n    if (this.runtimeDivert.hasVariableTarget) {\n      if (!this.divert.target) {\n        throw new Error();\n      }\n\n      this.Error(\n        `Since '${this.divert.target.dotSeparatedComponents}' is a variable, it shouldn't be preceded by '->' here.`\n      );\n    }\n\n    // Main resolve\n    this.runtimeDivert.targetPath &&\n      (this.runtimeDivertTargetValue.targetPath = this.runtimeDivert.targetPath);\n\n    // Tell hard coded (yet variable) divert targets that they also need to be counted\n    // TODO: Only detect DivertTargets that are values rather than being used directly for\n    // read or turn counts. Should be able to detect this by looking for other uses of containerForCounting\n    let targetContent = this.divert.targetContent;\n    if (targetContent !== null) {\n      let target = targetContent.containerForCounting;\n      if (target !== null) {\n        // Purpose is known: used directly in TURNS_SINCE(-> divTarg)\n        const parentFunc = asOrNull(this.parent, FunctionCall);\n        if (parentFunc && parentFunc.isTurnsSince) {\n          target.turnIndexShouldBeCounted = true;\n        } else {\n          // Unknown purpose, count everything\n          target.visitsShouldBeCounted = true;\n          target.turnIndexShouldBeCounted = true;\n        }\n      }\n\n      // Unfortunately not possible:\n      // https://github.com/inkle/ink/issues/538\n      //\n      // VAR func = -> double\n      //\n      // === function double(ref x)\n      //    ~ x = x * 2\n      //\n      // Because when generating the parameters for a function\n      // to be called, it needs to know ahead of time when\n      // compiling whether to pass a variable reference or value.\n      //\n      let targetFlow = asOrNull(targetContent, FlowBase);\n      if (targetFlow != null && targetFlow.args !== null) {\n        for (const arg of targetFlow.args) {\n          if (arg.isByReference) {\n            this.Error(\n              `Can't store a divert target to a knot or function that has by-reference arguments ('${targetFlow.identifier}' has 'ref ${arg.identifier}').`\n            );\n          }\n        }\n      }\n    }\n  }\n\n  // Equals override necessary in order to check for CONST multiple definition equality\n  public readonly Equals = (obj: ParsedObject): boolean => {\n    const otherDivTarget = asOrNull(obj, DivertTarget);\n    if (\n      !otherDivTarget ||\n      !this.divert.target ||\n      !otherDivTarget.divert.target\n    ) {\n      return false;\n    }\n\n    const targetStr = this.divert.target.dotSeparatedComponents;\n    const otherTargetStr = otherDivTarget.divert.target.dotSeparatedComponents;\n\n    return targetStr === otherTargetStr;\n  };\n}\n","import { Argument } from \"../Argument\";\nimport { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { ControlCommand as RuntimeControlCommand } from \"../../../../engine/ControlCommand\";\nimport { Divert as RuntimeDivert } from \"../../../../engine/Divert\";\nimport { DivertTarget } from \"./DivertTarget\";\nimport { Expression } from \"../Expression/Expression\";\nimport { FlowBase } from \"../Flow/FlowBase\";\nimport { FunctionCall } from \"../FunctionCall\";\nimport { ParsedObject } from \"../Object\";\nimport { Path } from \"../Path\";\nimport { Path as RuntimePath } from \"../../../../engine/Path\";\nimport { PushPopType } from \"../../../../engine/PushPop\";\nimport { Story } from \"../Story\";\nimport { VariablePointerValue } from \"../../../../engine/Value\";\nimport { VariableReference } from \"../Variable/VariableReference\";\nimport { ClosestFlowBase } from \"../Flow/ClosestFlowBase\";\nimport { asOrNull } from \"../../../../engine/TypeAssertion\";\n\nexport class Divert extends ParsedObject {\n  public readonly args: Expression[] = [];\n\n  public readonly target: Path | null = null;\n  public targetContent: ParsedObject | null = null;\n  private _runtimeDivert: RuntimeDivert | null = null;\n  get runtimeDivert(): RuntimeDivert {\n    if (!this._runtimeDivert) {\n      throw new Error();\n    }\n\n    return this._runtimeDivert;\n  }\n\n  set runtimeDivert(value: RuntimeDivert) {\n    this._runtimeDivert = value;\n  }\n\n  public isFunctionCall: boolean = false;\n  public isEmpty: boolean = false;\n  public isTunnel: boolean = false;\n  public isThread: boolean = false;\n\n  get isEnd(): boolean {\n    return Boolean(this.target && this.target.dotSeparatedComponents === \"END\");\n  }\n\n  get isDone(): boolean {\n    return Boolean(\n      this.target && this.target.dotSeparatedComponents === \"DONE\"\n    );\n  }\n\n  constructor(target?: Path | null | undefined, args?: Expression[]) {\n    super();\n\n    if (target) {\n      this.target = target;\n    }\n\n    if (args) {\n      this.args = args;\n      this.AddContent(args);\n    }\n  }\n\n  get typeName(): string {\n    return \"Divert\";\n  }\n\n  public readonly GenerateRuntimeObject = () => {\n    // End = end flow immediately\n    // Done = return from thread or instruct the flow that it's safe to exit\n    if (this.isEnd) {\n      return RuntimeControlCommand.End();\n    } else if (this.isDone) {\n      return RuntimeControlCommand.Done();\n    }\n\n    this.runtimeDivert = new RuntimeDivert();\n\n    // Normally we resolve the target content during the\n    // Resolve phase, since we expect all runtime objects to\n    // be available in order to find the final runtime path for\n    // the destination. However, we need to resolve the target\n    // (albeit without the runtime target) early so that\n    // we can get information about the arguments - whether\n    // they're by reference - since it affects the code we\n    // generate here.\n    this.ResolveTargetContent();\n\n    this.CheckArgumentValidity();\n\n    // Passing arguments to the knot\n    const requiresArgCodeGen = this.args !== null && this.args.length > 0;\n    if (\n      requiresArgCodeGen ||\n      this.isFunctionCall ||\n      this.isTunnel ||\n      this.isThread\n    ) {\n      const container = new RuntimeContainer();\n\n      // Generate code for argument evaluation\n      // This argument generation is coded defensively - it should\n      // attempt to generate the code for all the parameters, even if\n      // they don't match the expected arguments. This is so that the\n      // parameter objects themselves are generated correctly and don't\n      // get into a state of attempting to resolve references etc\n      // without being generated.\n      if (requiresArgCodeGen) {\n        // Function calls already in an evaluation context\n        if (!this.isFunctionCall) {\n          container.AddContent(RuntimeControlCommand.EvalStart());\n        }\n\n        let targetArguments: Argument[] | null = null;\n        if (this.targetContent) {\n          targetArguments = (this.targetContent as FlowBase).args;\n        }\n\n        for (let ii = 0; ii < this.args.length; ++ii) {\n          const argToPass: Expression = this.args[ii];\n          let argExpected: Argument | null = null;\n          if (targetArguments && ii < targetArguments.length) {\n            argExpected = targetArguments[ii];\n          }\n\n          // Pass by reference: argument needs to be a variable reference\n          if (argExpected && argExpected.isByReference) {\n            const varRef = asOrNull(argToPass, VariableReference);\n            if (!varRef) {\n              this.Error(\n                `Expected variable name to pass by reference to 'ref ${argExpected.identifier}' but saw ${argToPass}`\n              );\n\n              break;\n            }\n\n            // Check that we're not attempting to pass a read count by reference\n            const targetPath = new Path(varRef.pathIdentifiers);\n            const targetForCount: ParsedObject | null = targetPath.ResolveFromContext(\n              this\n            );\n            if (targetForCount) {\n              this.Error(\n                `can't pass a read count by reference. '${\n                  targetPath.dotSeparatedComponents\n                }' is a knot/stitch/label, but '${\n                  this.target!.dotSeparatedComponents\n                }' requires the name of a VAR to be passed.`\n              );\n\n              break;\n            }\n\n            const varPointer = new VariablePointerValue(varRef.name);\n            container.AddContent(varPointer);\n          } else {\n            // Normal value being passed: evaluate it as normal\n            argToPass.GenerateIntoContainer(container);\n          }\n        }\n\n        // Function calls were already in an evaluation context\n        if (!this.isFunctionCall) {\n          container.AddContent(RuntimeControlCommand.EvalEnd());\n        }\n      }\n\n      // Starting a thread? A bit like a push to the call stack below... but not.\n      // It sort of puts the call stack on a thread stack (argh!) - forks the full flow.\n      if (this.isThread) {\n        container.AddContent(RuntimeControlCommand.StartThread());\n      } else if (this.isFunctionCall || this.isTunnel) {\n        // If this divert is a function call, tunnel, we push to the call stack\n        // so we can return again\n        this.runtimeDivert.pushesToStack = true;\n        this.runtimeDivert.stackPushType = this.isFunctionCall\n          ? PushPopType.Function\n          : PushPopType.Tunnel;\n      }\n\n      // Jump into the \"function\" (knot/stitch)\n      container.AddContent(this.runtimeDivert);\n\n      return container;\n    }\n\n    // Simple divert\n    return this.runtimeDivert;\n  };\n\n  // When the divert is to a target that's actually a variable name\n  // rather than an explicit knot/stitch name, try interpretting it\n  // as such by getting the variable name.\n  public readonly PathAsVariableName = () =>\n    this.target ? this.target.firstComponent : null;\n\n  public readonly ResolveTargetContent = (): void => {\n    if (this.isEmpty || this.isEnd) {\n      return;\n    }\n\n    if (this.targetContent === null) {\n      // Is target of this divert a variable name that will be de-referenced\n      // at runtime? If so, there won't be any further reference resolution\n      // we can do at this point.\n      let variableTargetName = this.PathAsVariableName();\n      if (variableTargetName !== null) {\n        const flowBaseScope = asOrNull(ClosestFlowBase(this), FlowBase);\n        if (flowBaseScope) {\n          const resolveResult = flowBaseScope.ResolveVariableWithName(\n            variableTargetName,\n            this\n          );\n\n          if (resolveResult.found) {\n            // Make sure that the flow was typed correctly, given that we know that this\n            // is meant to be a divert target\n            if (\n              resolveResult.isArgument &&\n              resolveResult.ownerFlow &&\n              resolveResult.ownerFlow.args\n            ) {\n              let argument = resolveResult.ownerFlow.args.find(\n                (a) => a.identifier?.name == variableTargetName\n              );\n\n              if (argument && !argument.isDivertTarget) {\n                this.Error(\n                  `Since '${argument.identifier}' is used as a variable divert target (on ${this.debugMetadata}), it should be marked as: -> ${argument.identifier}`,\n                  resolveResult.ownerFlow\n                );\n              }\n            }\n\n            this.runtimeDivert.variableDivertName = variableTargetName;\n            return;\n          }\n        }\n      }\n\n      if (!this.target) {\n        throw new Error();\n      }\n\n      this.targetContent = this.target.ResolveFromContext(this);\n    }\n  };\n\n  public ResolveReferences(context: Story): void {\n    if (this.isEmpty || this.isEnd || this.isDone) {\n      return;\n    } else if (!this.runtimeDivert) {\n      throw new Error();\n    }\n\n    if (this.targetContent) {\n      this.runtimeDivert.targetPath = this.targetContent.runtimePath;\n    }\n\n    // Resolve children (the arguments)\n    super.ResolveReferences(context);\n\n    // May be null if it's a built in function (e.g. TURNS_SINCE)\n    // or if it's a variable target.\n    let targetFlow = asOrNull(this.targetContent, FlowBase);\n    if (targetFlow) {\n      if (!targetFlow.isFunction && this.isFunctionCall) {\n        super.Error(\n          `${targetFlow.identifier} hasn't been marked as a function, but it's being called as one. Do you need to delcare the knot as '== function ${targetFlow.identifier} =='?`\n        );\n      } else if (\n        targetFlow.isFunction &&\n        !this.isFunctionCall &&\n        !(this.parent instanceof DivertTarget)\n      ) {\n        super.Error(\n          targetFlow.identifier +\n            \" can't be diverted to. It can only be called as a function since it's been marked as such: '\" +\n            targetFlow.identifier +\n            \"(...)'\"\n        );\n      }\n    }\n\n    // Check validity of target content\n    const targetWasFound = this.targetContent !== null;\n    let isBuiltIn: boolean = false;\n    let isExternal: boolean = false;\n\n    if (!this.target) {\n      throw new Error();\n    } else if (this.target.numberOfComponents === 1) {\n      if (!this.target.firstComponent) {\n        throw new Error();\n      }\n\n      // BuiltIn means TURNS_SINCE, CHOICE_COUNT, RANDOM or SEED_RANDOM\n      isBuiltIn = FunctionCall.IsBuiltIn(this.target.firstComponent);\n\n      // Client-bound function?\n      isExternal = context.IsExternal(this.target.firstComponent);\n\n      if (isBuiltIn || isExternal) {\n        if (!this.isFunctionCall) {\n          super.Error(\n            `${this.target.firstComponent} must be called as a function: ~ ${this.target.firstComponent}()`\n          );\n        }\n\n        if (isExternal) {\n          this.runtimeDivert.isExternal = true;\n          if (this.args !== null) {\n            this.runtimeDivert.externalArgs = this.args.length;\n          }\n\n          this.runtimeDivert.pushesToStack = false;\n          this.runtimeDivert.targetPath = new RuntimePath(\n            this.target.firstComponent\n          );\n\n          this.CheckExternalArgumentValidity(context);\n        }\n\n        return;\n      }\n    }\n\n    // Variable target?\n    if (this.runtimeDivert.variableDivertName != null) {\n      return;\n    }\n\n    if (!targetWasFound && !isBuiltIn && !isExternal) {\n      this.Error(`target not found: '${this.target}'`);\n    }\n  }\n\n  // Returns false if there's an error\n  public readonly CheckArgumentValidity = (): void => {\n    if (this.isEmpty) {\n      return;\n    }\n\n    // Argument passing: Check for errors in number of arguments\n    let numArgs = 0;\n    if (this.args !== null && this.args.length > 0) {\n      numArgs = this.args.length;\n    }\n\n    // Missing content?\n    // Can't check arguments properly. It'll be due to some\n    // other error though, so although there's a problem and\n    // we report false, we don't need to report a specific error.\n    // It may also be because it's a valid call to an external\n    // function, that we check at the resolve stage.\n    if (this.targetContent === null) {\n      return;\n    }\n\n    const targetFlow = asOrNull(this.targetContent, FlowBase);\n\n    // No error, crikey!\n    if (numArgs === 0 && (targetFlow === null || !targetFlow.hasParameters)) {\n      return;\n    } else if (targetFlow === null && numArgs > 0) {\n      this.Error(\n        \"target needs to be a knot or stitch in order to pass arguments\"\n      );\n      return;\n    } else if (\n      targetFlow !== null &&\n      (targetFlow.args === null || (!targetFlow.args && numArgs > 0))\n    ) {\n      this.Error(`target (${targetFlow.name}) doesn't take parameters`);\n      return;\n    } else if (this.parent instanceof DivertTarget) {\n      if (numArgs > 0) {\n        this.Error(`can't store arguments in a divert target variable`);\n      }\n\n      return;\n    }\n\n    const paramCount = targetFlow!.args!.length;\n    if (paramCount !== numArgs) {\n      let butClause: string;\n      if (numArgs === 0) {\n        butClause = \"but there weren't any passed to it\";\n      } else if (numArgs < paramCount) {\n        butClause = `but only got ${numArgs}`;\n      } else {\n        butClause = `but got ${numArgs}`;\n      }\n\n      this.Error(\n        `to '${\n          targetFlow!.identifier\n        }' requires ${paramCount} arguments, ${butClause}`\n      );\n\n      return;\n    }\n\n    // Light type-checking for divert target arguments\n    for (let ii = 0; ii < paramCount; ++ii) {\n      const flowArg: Argument = targetFlow!.args![ii];\n      const divArgExpr: Expression = this.args[ii];\n\n      // Expecting a divert target as an argument, let's do some basic type checking\n      if (flowArg.isDivertTarget) {\n        // Not passing a divert target or any kind of variable reference?\n        let varRef = asOrNull(divArgExpr, VariableReference);\n        if (!(divArgExpr instanceof DivertTarget) && varRef === null) {\n          this.Error(\n            `Target '${\n              targetFlow!.identifier\n            }' expects a divert target for the parameter named -> ${\n              flowArg.identifier\n            } but saw ${divArgExpr}`,\n            divArgExpr\n          );\n        } else if (varRef) {\n          // Passing 'a' instead of '-> a'?\n          // i.e. read count instead of divert target\n          // Unfortunately have to manually resolve here since we're still in code gen\n          const knotCountPath = new Path(varRef.pathIdentifiers);\n          const targetForCount: ParsedObject | null = knotCountPath.ResolveFromContext(\n            varRef\n          );\n          if (targetForCount) {\n            this.Error(\n              `Passing read count of '${knotCountPath.dotSeparatedComponents}' instead of a divert target. You probably meant '${knotCountPath}'`\n            );\n          }\n        }\n      }\n    }\n\n    if (targetFlow === null) {\n      this.Error(\n        \"Can't call as a function or with arguments unless it's a knot or stitch\"\n      );\n      return;\n    }\n\n    return;\n  };\n\n  public readonly CheckExternalArgumentValidity = (context: Story): void => {\n    const externalName: string | null = this.target\n      ? this.target.firstComponent\n      : null;\n    const external = context.externals.get(externalName as any);\n    if (!external) {\n      throw new Error(\"external not found\");\n    }\n\n    const externalArgCount: number = external.argumentNames.length;\n    let ownArgCount = 0;\n    if (this.args) {\n      ownArgCount = this.args.length;\n    }\n\n    if (ownArgCount !== externalArgCount) {\n      this.Error(\n        `incorrect number of arguments sent to external function '${externalName}'. Expected ${externalArgCount} but got ${ownArgCount}`\n      );\n    }\n  };\n\n  public Error(\n    message: string,\n    source: ParsedObject | null = null,\n    isWarning: boolean = false\n  ): void {\n    // Could be getting an error from a nested Divert\n    if (source !== this && source) {\n      super.Error(message, source);\n      return;\n    }\n\n    if (this.isFunctionCall) {\n      super.Error(`Function call ${message}`, source, isWarning);\n    } else {\n      super.Error(`Divert ${message}`, source, isWarning);\n    }\n  }\n\n  public toString = (): string => {\n    let returnString = \"\";\n    if (this.target !== null) {\n      returnString += this.target.toString();\n    } else {\n      return \"-> <empty divert>\";\n    }\n\n    if (this.isTunnel) {\n      returnString += \" ->\";\n    }\n    if (this.isFunctionCall) {\n      returnString += \" ()\";\n    }\n\n    return returnString;\n  };\n}\n","import { Divert as RuntimeDivert } from \"../../../../engine/Divert\";\nimport { InkObject as RuntimeObject } from \"../../../../engine/Object\";\n\nexport class GatherPointToResolve {\n  constructor(\n    public divert: RuntimeDivert,\n    public targetRuntimeObj: RuntimeObject\n  ) {}\n}\n","import { Divert as RuntimeDivert } from \"../../../../engine/Divert\";\nimport { InkObject as RuntimeObject } from \"../../../../engine/Object\";\n\nexport class SequenceDivertToResolve {\n  constructor(\n    public divert: RuntimeDivert,\n    public targetContent: RuntimeObject\n  ) {}\n}\n","export enum CustomFlags {\n  ParsingString = 0x1,\n}\n","import { ContentList } from \"../ContentList\";\nimport { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { ControlCommand as RuntimeControlCommand } from \"../../../../engine/ControlCommand\";\nimport { Divert as RuntimeDivert } from \"../../../../engine/Divert\";\nimport { IntValue } from \"../../../../engine/Value\";\nimport { NativeFunctionCall } from \"../../../../engine/NativeFunctionCall\";\nimport { ParsedObject } from \"../Object\";\nimport { InkObject as RuntimeObject } from \"../../../../engine/Object\";\nimport { SequenceDivertToResolve } from \"./SequenceDivertToResolve\";\nimport { SequenceType } from \"./SequenceType\";\nimport { Story } from \"../Story\";\nimport { Weave } from \"../Weave\";\n\nexport class Sequence extends ParsedObject {\n  private _sequenceDivertsToResolve: SequenceDivertToResolve[] = [];\n\n  public sequenceElements: ParsedObject[];\n\n  constructor(\n    elementContentLists: ContentList[],\n    public readonly sequenceType: SequenceType\n  ) {\n    super();\n\n    this.sequenceType = sequenceType;\n    this.sequenceElements = [];\n\n    for (const elementContentList of elementContentLists) {\n      const contentObjs = elementContentList.content;\n      let seqElObject: ParsedObject | null = null;\n\n      // Don't attempt to create a weave for the sequence element\n      // if the content list is empty. Weaves don't like it!\n      if (contentObjs === null || contentObjs.length === 0) {\n        seqElObject = elementContentList;\n      } else {\n        seqElObject = new Weave(contentObjs);\n      }\n\n      this.sequenceElements.push(seqElObject);\n      this.AddContent(seqElObject);\n    }\n  }\n\n  // Generate runtime code that looks like:\n  //\n  //   chosenIndex = MIN(sequence counter, num elements) e.g. for \"Stopping\"\n  //   if chosenIndex == 0, divert to s0\n  //   if chosenIndex == 1, divert to s1  [etc]\n  //\n  //   - s0:\n  //      <content for sequence element>\n  //      divert to no-op\n  //   - s1:\n  //      <content for sequence element>\n  //      divert to no-op\n  //   - s2:\n  //      empty branch if using \"once\"\n  //      divert to no-op\n  //\n  //    no-op\n  //\n  public readonly GenerateRuntimeObject = (): RuntimeObject => {\n    const container = new RuntimeContainer();\n    container.visitsShouldBeCounted = true;\n    container.countingAtStartOnly = true;\n\n    this._sequenceDivertsToResolve = [];\n\n    // Get sequence read count\n    container.AddContent(RuntimeControlCommand.EvalStart());\n    container.AddContent(RuntimeControlCommand.VisitIndex());\n\n    const once: boolean = (this.sequenceType & SequenceType.Once) > 0;\n    const cycle: boolean = (this.sequenceType & SequenceType.Cycle) > 0;\n    const stopping: boolean = (this.sequenceType & SequenceType.Stopping) > 0;\n    const shuffle: boolean = (this.sequenceType & SequenceType.Shuffle) > 0;\n\n    let seqBranchCount = this.sequenceElements.length;\n    if (once) {\n      seqBranchCount += 1;\n    }\n\n    // Chosen sequence index:\n    //  - Stopping: take the MIN(read count, num elements - 1)\n    //  - Once: take the MIN(read count, num elements)\n    //    (the last one being empty)\n    if (stopping || once) {\n      //var limit = stopping ? seqBranchCount-1 : seqBranchCount;\n      container.AddContent(new IntValue(seqBranchCount - 1));\n      container.AddContent(NativeFunctionCall.CallWithName(\"MIN\"));\n    } else if (cycle) {\n      // - Cycle: take (read count % num elements)\n      container.AddContent(new IntValue(this.sequenceElements.length));\n      container.AddContent(NativeFunctionCall.CallWithName(\"%\"));\n    }\n\n    // Shuffle\n    if (shuffle) {\n      // Create point to return to when sequence is complete\n      const postShuffleNoOp = RuntimeControlCommand.NoOp();\n\n      // When visitIndex == lastIdx, we skip the shuffle\n      if (once || stopping) {\n        // if( visitIndex == lastIdx ) -> skipShuffle\n        const lastIdx = stopping\n          ? this.sequenceElements.length - 1\n          : this.sequenceElements.length;\n\n        container.AddContent(RuntimeControlCommand.Duplicate());\n        container.AddContent(new IntValue(lastIdx));\n        container.AddContent(NativeFunctionCall.CallWithName(\"==\"));\n\n        const skipShuffleDivert = new RuntimeDivert();\n        skipShuffleDivert.isConditional = true;\n        container.AddContent(skipShuffleDivert);\n\n        this.AddDivertToResolve(skipShuffleDivert, postShuffleNoOp);\n      }\n\n      // This one's a bit more complex! Choose the index at runtime.\n      let elementCountToShuffle = this.sequenceElements.length;\n      if (stopping) {\n        elementCountToShuffle -= 1;\n      }\n\n      container.AddContent(new IntValue(elementCountToShuffle));\n      container.AddContent(RuntimeControlCommand.SequenceShuffleIndex());\n      if (once || stopping) {\n        container.AddContent(postShuffleNoOp);\n      }\n    }\n\n    container.AddContent(RuntimeControlCommand.EvalEnd());\n\n    // Create point to return to when sequence is complete\n    const postSequenceNoOp = RuntimeControlCommand.NoOp();\n\n    // Each of the main sequence branches, and one extra empty branch if\n    // we have a \"once\" sequence.\n    for (let elIndex = 0; elIndex < seqBranchCount; elIndex += 1) {\n      // This sequence element:\n      //  if( chosenIndex == this index ) divert to this sequence element\n      // duplicate chosen sequence index, since it'll be consumed by \"==\"\n      container.AddContent(RuntimeControlCommand.EvalStart());\n      container.AddContent(RuntimeControlCommand.Duplicate());\n      container.AddContent(new IntValue(elIndex));\n      container.AddContent(NativeFunctionCall.CallWithName(\"==\"));\n      container.AddContent(RuntimeControlCommand.EvalEnd());\n\n      // Divert branch for this sequence element\n      const sequenceDivert = new RuntimeDivert();\n      sequenceDivert.isConditional = true;\n      container.AddContent(sequenceDivert);\n\n      let contentContainerForSequenceBranch: RuntimeContainer;\n\n      // Generate content for this sequence element\n      if (elIndex < this.sequenceElements.length) {\n        const el = this.sequenceElements[elIndex];\n        contentContainerForSequenceBranch = el.runtimeObject as RuntimeContainer;\n      } else {\n        // Final empty branch for \"once\" sequences\n        contentContainerForSequenceBranch = new RuntimeContainer();\n      }\n\n      contentContainerForSequenceBranch.name = `s${elIndex}`;\n      contentContainerForSequenceBranch.InsertContent(\n        RuntimeControlCommand.PopEvaluatedValue(),\n        0\n      );\n\n      // When sequence element is complete, divert back to end of sequence\n      const seqBranchCompleteDivert = new RuntimeDivert();\n      contentContainerForSequenceBranch.AddContent(seqBranchCompleteDivert);\n      container.AddToNamedContentOnly(contentContainerForSequenceBranch);\n\n      // Save the diverts for reference resolution later (in ResolveReferences)\n      this.AddDivertToResolve(\n        sequenceDivert,\n        contentContainerForSequenceBranch\n      );\n      this.AddDivertToResolve(seqBranchCompleteDivert, postSequenceNoOp);\n    }\n\n    container.AddContent(postSequenceNoOp);\n\n    return container;\n  };\n\n  public readonly AddDivertToResolve = (\n    divert: RuntimeDivert,\n    targetContent: RuntimeObject\n  ) => {\n    this._sequenceDivertsToResolve.push(\n      new SequenceDivertToResolve(divert, targetContent)\n    );\n  };\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n\n    for (const toResolve of this._sequenceDivertsToResolve) {\n      toResolve.divert.targetPath = toResolve.targetContent.path;\n    }\n  }\n}\n","import { Container as RuntimeContainer } from \"../../../engine/Container\";\nimport { ControlCommand as RuntimeControlCommand } from \"../../../engine/ControlCommand\";\nimport { Divert } from \"./Divert/Divert\";\nimport { DivertTargetValue } from \"../../../engine/Value\";\nimport { ParsedObject } from \"./Object\";\nimport { InkObject as RuntimeObject } from \"../../../engine/Object\";\nimport { Story } from \"./Story\";\nimport { Void } from \"../../../engine/Void\";\n\nexport class TunnelOnwards extends ParsedObject {\n  private _overrideDivertTarget: DivertTargetValue | null = null;\n\n  private _divertAfter: Divert | null = null;\n  get divertAfter() {\n    return this._divertAfter;\n  }\n\n  set divertAfter(value) {\n    this._divertAfter = value;\n    if (this._divertAfter) {\n      this.AddContent(this._divertAfter);\n    }\n  }\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject => {\n    const container = new RuntimeContainer();\n\n    // Set override path for tunnel onwards (or nothing)\n    container.AddContent(RuntimeControlCommand.EvalStart());\n\n    if (this.divertAfter) {\n      // Generate runtime object's generated code and steal the arguments runtime code\n      const returnRuntimeObj = this.divertAfter.GenerateRuntimeObject();\n      const returnRuntimeContainer = returnRuntimeObj as RuntimeContainer;\n      if (returnRuntimeContainer) {\n        // Steal all code for generating arguments from the divert\n        const args = this.divertAfter.args;\n        if (args !== null && args.length > 0) {\n          // Steal everything betwen eval start and eval end\n          let evalStart = -1;\n          let evalEnd = -1;\n          for (\n            let ii = 0;\n            ii < returnRuntimeContainer.content.length;\n            ii += 1\n          ) {\n            const cmd = returnRuntimeContainer.content[\n              ii\n            ] as RuntimeControlCommand;\n            if (cmd) {\n              if (\n                evalStart == -1 &&\n                cmd.commandType === RuntimeControlCommand.CommandType.EvalStart\n              ) {\n                evalStart = ii;\n              } else if (\n                cmd.commandType === RuntimeControlCommand.CommandType.EvalEnd\n              ) {\n                evalEnd = ii;\n              }\n            }\n          }\n\n          for (let ii = evalStart + 1; ii < evalEnd; ii += 1) {\n            const obj = returnRuntimeContainer.content[ii];\n            obj.parent = null; // prevent error of being moved between owners\n            container.AddContent(returnRuntimeContainer.content[ii]);\n          }\n        }\n      }\n\n      // Finally, divert to the requested target\n      this._overrideDivertTarget = new DivertTargetValue();\n      container.AddContent(this._overrideDivertTarget);\n    } else {\n      // No divert after tunnel onwards\n      container.AddContent(new Void());\n    }\n\n    container.AddContent(RuntimeControlCommand.EvalEnd());\n    container.AddContent(RuntimeControlCommand.PopTunnel());\n\n    return container;\n  };\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n\n    if (this.divertAfter && this.divertAfter.targetContent) {\n      this._overrideDivertTarget!.targetPath = this.divertAfter.targetContent.runtimePath;\n    }\n  }\n\n  public toString = (): string => {\n    return ` -> ${this._divertAfter}`;\n  };\n}\n","import { InkListItem, SerializedInkListItem } from \"./InkList\";\nimport { TryGetResult } from \"./TryGetResult\";\n\nexport class ListDefinition {\n  public _name: string;\n  public _items: Map<SerializedInkListItem, number> | null;\n  public _itemNameToValues: Map<string, number>;\n\n  constructor(name: string, items: Map<string, number> | null) {\n    this._name = name || \"\";\n    this._items = null;\n    this._itemNameToValues = items || new Map();\n  }\n  get name() {\n    return this._name;\n  }\n  get items() {\n    if (this._items == null) {\n      this._items = new Map();\n      for (let [key, value] of this._itemNameToValues) {\n        let item = new InkListItem(this.name, key);\n        this._items.set(item.serialized(), value);\n      }\n    }\n\n    return this._items;\n  }\n\n  public ValueForItem(item: InkListItem) {\n    if (!item.itemName) return 0;\n\n    let intVal = this._itemNameToValues.get(item.itemName);\n    if (typeof intVal !== \"undefined\") return intVal;\n    else return 0;\n  }\n  public ContainsItem(item: InkListItem) {\n    if (!item.itemName) return false;\n    if (item.originName != this.name) return false;\n\n    return this._itemNameToValues.has(item.itemName);\n  }\n  public ContainsItemWithName(itemName: string) {\n    return this._itemNameToValues.has(itemName);\n  }\n  public TryGetItemWithValue(\n    val: number,\n    /* out */ item: InkListItem\n  ): TryGetResult<InkListItem> {\n    for (let [key, value] of this._itemNameToValues) {\n      if (value == val) {\n        item = new InkListItem(this.name, key);\n        return { result: item, exists: true };\n      }\n    }\n\n    item = InkListItem.Null;\n    return { result: item, exists: false };\n  }\n  public TryGetValueForItem(\n    item: InkListItem,\n    /* out */ intVal: number\n  ): TryGetResult<number> {\n    if (!item.itemName) return { result: 0, exists: false };\n    let value = this._itemNameToValues.get(item.itemName);\n\n    if (!value) return { result: 0, exists: false };\n    return { result: value, exists: true };\n  }\n}\n","import { InkList as RuntimeInkList } from \"../../../../engine/InkList\";\nimport { InkListItem as RuntimeInkListItem } from \"../../../../engine/InkList\";\nimport { ListDefinition as RuntimeListDefinition } from \"../../../../engine/ListDefinition\";\nimport { ListElementDefinition } from \"./ListElementDefinition\";\nimport { ListValue } from \"../../../../engine/Value\";\nimport { ParsedObject } from \"../Object\";\nimport { Story } from \"../Story\";\nimport { SymbolType } from \"../SymbolType\";\nimport { VariableAssignment } from \"../Variable/VariableAssignment\";\nimport { Identifier } from \"../Identifier\";\n\nexport class ListDefinition extends ParsedObject {\n  public identifier: Identifier | null = null;\n  public variableAssignment: VariableAssignment | null = null;\n\n  get typeName() {\n    return \"List definition\";\n  }\n\n  private _elementsByName: Map<string, ListElementDefinition> | null = null;\n\n  get runtimeListDefinition(): RuntimeListDefinition {\n    const allItems: Map<string, number> = new Map();\n    for (const e of this.itemDefinitions) {\n      if (!allItems.has(e.name!)) {\n        allItems.set(e.name!, e.seriesValue);\n      } else {\n        this.Error(\n          `List '${this.identifier}' contains duplicate items called '${e.name}'`\n        );\n      }\n    }\n\n    return new RuntimeListDefinition(this.identifier?.name || \"\", allItems);\n  }\n\n  public readonly ItemNamed = (\n    itemName: string\n  ): ListElementDefinition | null => {\n    if (this._elementsByName === null) {\n      this._elementsByName = new Map();\n\n      for (const el of this.itemDefinitions) {\n        this._elementsByName.set(el.name!, el);\n      }\n    }\n\n    const foundElement = this._elementsByName.get(itemName) || null;\n\n    return foundElement;\n  };\n\n  constructor(public itemDefinitions: ListElementDefinition[]) {\n    super();\n\n    let currentValue = 1;\n    for (const e of this.itemDefinitions) {\n      if (e.explicitValue !== null) {\n        currentValue = e.explicitValue;\n      }\n\n      e.seriesValue = currentValue;\n\n      currentValue += 1;\n    }\n\n    this.AddContent(itemDefinitions as any);\n  }\n\n  public readonly GenerateRuntimeObject = (): ListValue => {\n    const initialValues = new RuntimeInkList();\n    for (const itemDef of this.itemDefinitions) {\n      if (itemDef.inInitialList) {\n        const item = new RuntimeInkListItem(\n          this.identifier?.name || null,\n          itemDef.name || null\n        );\n        initialValues.Add(item, itemDef.seriesValue);\n      }\n    }\n\n    // Set origin name, so\n    initialValues.SetInitialOriginName(this.identifier?.name || \"\");\n\n    return new ListValue(initialValues);\n  };\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n    context.CheckForNamingCollisions(this, this.identifier!, SymbolType.List);\n  }\n}\n","import { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { Expression } from \"../Expression/Expression\";\nimport { FlowBase } from \"../Flow/FlowBase\";\nimport { ClosestFlowBase } from \"../Flow/ClosestFlowBase\";\nimport { ListDefinition } from \"../List/ListDefinition\";\nimport { ParsedObject } from \"../Object\";\nimport { InkObject as RuntimeObject } from \"../../../../engine/Object\";\nimport { Story } from \"../Story\";\nimport { SymbolType } from \"../SymbolType\";\nimport { VariableAssignment as RuntimeVariableAssignment } from \"../../../../engine/VariableAssignment\";\nimport { VariableReference } from \"./VariableReference\";\nimport { Identifier } from \"../Identifier\";\nimport { asOrNull } from \"../../../../engine/TypeAssertion\";\n\nexport class VariableAssignment extends ParsedObject {\n  private _runtimeAssignment: RuntimeVariableAssignment | null = null;\n\n  get variableName(): string {\n    return this.variableIdentifier.name!;\n  }\n  public readonly variableIdentifier: Identifier;\n  public readonly expression: Expression | null = null;\n  public readonly listDefinition: ListDefinition | null = null;\n  public readonly isGlobalDeclaration: boolean;\n  public readonly isNewTemporaryDeclaration: boolean;\n\n  get typeName() {\n    if (this.isNewTemporaryDeclaration) {\n      return \"temp\";\n    } else if (this.isGlobalDeclaration) {\n      return \"VAR\";\n    }\n\n    return \"variable assignment\";\n  }\n\n  get isDeclaration(): boolean {\n    return this.isGlobalDeclaration || this.isNewTemporaryDeclaration;\n  }\n\n  constructor({\n    assignedExpression,\n    isGlobalDeclaration,\n    isTemporaryNewDeclaration,\n    listDef,\n    variableIdentifier,\n  }: {\n    readonly assignedExpression?: Expression;\n    readonly isGlobalDeclaration?: boolean;\n    readonly isTemporaryNewDeclaration?: boolean;\n    readonly listDef?: ListDefinition;\n    readonly variableIdentifier: Identifier;\n  }) {\n    super();\n\n    this.variableIdentifier = variableIdentifier;\n    this.isGlobalDeclaration = Boolean(isGlobalDeclaration);\n    this.isNewTemporaryDeclaration = Boolean(isTemporaryNewDeclaration);\n\n    // Defensive programming in case parsing of assignedExpression failed\n    if (listDef instanceof ListDefinition) {\n      this.listDefinition = this.AddContent(listDef) as ListDefinition;\n      this.listDefinition.variableAssignment = this;\n\n      // List definitions are always global\n      this.isGlobalDeclaration = true;\n    } else if (assignedExpression) {\n      this.expression = this.AddContent(assignedExpression) as Expression;\n    }\n  }\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject | null => {\n    let newDeclScope: FlowBase | null | undefined = null;\n    if (this.isGlobalDeclaration) {\n      newDeclScope = this.story;\n    } else if (this.isNewTemporaryDeclaration) {\n      newDeclScope = ClosestFlowBase(this);\n    }\n\n    if (newDeclScope) {\n      newDeclScope.AddNewVariableDeclaration(this);\n    }\n\n    // Global declarations don't generate actual procedural\n    // runtime objects, but instead add a global variable to the story itself.\n    // The story then initialises them all in one go at the start of the game.\n    if (this.isGlobalDeclaration) {\n      return null;\n    }\n\n    const container = new RuntimeContainer();\n\n    // The expression's runtimeObject is actually another nested container\n    if (this.expression) {\n      container.AddContent(this.expression.runtimeObject);\n    } else if (this.listDefinition) {\n      container.AddContent(this.listDefinition.runtimeObject);\n    }\n\n    this._runtimeAssignment = new RuntimeVariableAssignment(\n      this.variableName,\n      this.isNewTemporaryDeclaration\n    );\n\n    container.AddContent(this._runtimeAssignment);\n\n    return container;\n  };\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n\n    // List definitions are checked for conflicts separately\n    if (this.isDeclaration && this.listDefinition === null) {\n      context.CheckForNamingCollisions(\n        this,\n        this.variableIdentifier,\n        this.isGlobalDeclaration ? SymbolType.Var : SymbolType.Temp\n      );\n    }\n\n    // Initial VAR x = [intialValue] declaration, not re-assignment\n    if (this.isGlobalDeclaration) {\n      const variableReference = asOrNull(this.expression, VariableReference);\n      if (\n        variableReference &&\n        !variableReference.isConstantReference &&\n        !variableReference.isListItemReference\n      ) {\n        this.Error(\n          \"global variable assignments cannot refer to other variables, only literal values, constants and list items\"\n        );\n      }\n    }\n\n    if (!this.isNewTemporaryDeclaration) {\n      const resolvedVarAssignment = context.ResolveVariableWithName(\n        this.variableName,\n        this\n      );\n\n      if (!resolvedVarAssignment.found) {\n        if (this.variableName in this.story.constants) {\n          this.Error(\n            `Can't re-assign to a constant (do you need to use VAR when declaring '${this.variableName}'?)`,\n            this\n          );\n        } else {\n          this.Error(\n            `Variable could not be found to assign to: '${this.variableName}'`,\n            this\n          );\n        }\n      }\n\n      // A runtime assignment may not have been generated if it's the initial global declaration,\n      // since these are hoisted out and handled specially in Story.ExportRuntime.\n      if (this._runtimeAssignment) {\n        this._runtimeAssignment.isGlobal = resolvedVarAssignment.isGlobal;\n      }\n    }\n  }\n\n  public readonly toString = (): string =>\n    `${\n      this.isGlobalDeclaration\n        ? \"VAR\"\n        : this.isNewTemporaryDeclaration\n        ? \"~ temp\"\n        : \"\"\n    } ${this.variableName}`;\n}\n","import { AuthorWarning } from \"./AuthorWarning\";\nimport { Choice } from \"./Choice\";\nimport { Conditional } from \"./Conditional/Conditional\";\nimport { ConstantDeclaration } from \"./Declaration/ConstantDeclaration\";\nimport { Container as RuntimeContainer } from \"../../../engine/Container\";\nimport { Divert } from \"./Divert/Divert\";\nimport { Divert as RuntimeDivert } from \"../../../engine/Divert\";\nimport { DivertTarget } from \"./Divert/DivertTarget\";\nimport { FlowBase } from \"./Flow/FlowBase\";\nimport { Gather } from \"./Gather/Gather\";\nimport { GatherPointToResolve } from \"./Gather/GatherPointToResolve\";\nimport { IWeavePoint } from \"./IWeavePoint\";\nimport { ParsedObject } from \"./Object\";\nimport { InkObject as RuntimeObject } from \"../../../engine/Object\";\nimport { Sequence } from \"./Sequence/Sequence\";\nimport { Story } from \"./Story\";\nimport { Text } from \"./Text\";\nimport { TunnelOnwards } from \"./TunnelOnwards\";\nimport { VariableAssignment } from \"./Variable/VariableAssignment\";\nimport { asOrNull } from \"../../../engine/TypeAssertion\";\n\ntype BadTerminationHandler = (terminatingObj: ParsedObject) => void;\n\n// Used by the FlowBase when constructing the weave flow from\n// a flat list of content objects.\nexport class Weave extends ParsedObject {\n  // Containers can be chained as multiple gather points\n  // get created as the same indentation level.\n  // rootContainer is always the first in the chain, while\n  // currentContainer is the latest.\n  get rootContainer(): RuntimeContainer {\n    if (!this._rootContainer) {\n      this._rootContainer = this.GenerateRuntimeObject();\n    }\n\n    return this._rootContainer;\n  }\n\n  // Keep track of previous weave point (Choice or Gather)\n  // at the current indentation level:\n  //  - to add ordinary content to be nested under it\n  //  - to add nested content under it when it's indented\n  //  - to remove it from the list of loose ends when\n  //     - it has indented content since it's no longer a loose end\n  //     - it's a gather and it has a choice added to it\n  public previousWeavePoint: IWeavePoint | null = null;\n  public addContentToPreviousWeavePoint: boolean = false;\n\n  // Used for determining whether the next Gather should auto-enter\n  public hasSeenChoiceInSection: boolean = false;\n\n  public currentContainer: RuntimeContainer | null = null;\n  public baseIndentIndex: number;\n\n  private _unnamedGatherCount: number = 0;\n  private _choiceCount: number = 0;\n  private _rootContainer: RuntimeContainer | null = null;\n  private _namedWeavePoints: Map<string, IWeavePoint> = new Map();\n  get namedWeavePoints() {\n    return this._namedWeavePoints;\n  }\n\n  // Loose ends are:\n  //  - Choices or Gathers that need to be joined up\n  //  - Explicit Divert to gather points (i.e. \"->\" without a target)\n  public looseEnds: IWeavePoint[] = [];\n\n  public gatherPointsToResolve: GatherPointToResolve[] = [];\n\n  get lastParsedSignificantObject(): ParsedObject | null {\n    if (this.content.length === 0) {\n      return null;\n    }\n\n    // Don't count extraneous newlines or VAR/CONST declarations,\n    // since they're \"empty\" statements outside of the main flow.\n    let lastObject: ParsedObject | null = null;\n    for (let ii = this.content.length - 1; ii >= 0; --ii) {\n      lastObject = this.content[ii];\n\n      let lastText = asOrNull(lastObject, Text);\n      if (lastText && lastText.text === \"\\n\") {\n        continue;\n      }\n\n      if (this.IsGlobalDeclaration(lastObject)) {\n        continue;\n      }\n\n      break;\n    }\n\n    const lastWeave = asOrNull(lastObject, Weave);\n    if (lastWeave) {\n      lastObject = lastWeave.lastParsedSignificantObject;\n    }\n\n    return lastObject;\n  }\n\n  constructor(cont: ParsedObject[], indentIndex: number = -1) {\n    super();\n\n    if (indentIndex == -1) {\n      this.baseIndentIndex = this.DetermineBaseIndentationFromContent(cont);\n    } else {\n      this.baseIndentIndex = indentIndex;\n    }\n\n    this.AddContent(cont);\n\n    this.ConstructWeaveHierarchyFromIndentation();\n  }\n\n  public readonly ResolveWeavePointNaming = (): void => {\n    const namedWeavePoints = [\n      ...this.FindAll<IWeavePoint>(Gather)(\n        (w) => !(w.name === null || w.name === undefined)\n      ),\n      ...this.FindAll<IWeavePoint>(Choice)(\n        (w) => !(w.name === null || w.name === undefined)\n      ),\n    ];\n    this._namedWeavePoints = new Map();\n\n    for (const weavePoint of namedWeavePoints) {\n      // Check for weave point naming collisions\n      const existingWeavePoint:\n        | IWeavePoint\n        | null\n        | undefined = this.namedWeavePoints.get(\n        weavePoint.identifier?.name || \"\"\n      );\n\n      if (existingWeavePoint) {\n        const typeName =\n          existingWeavePoint instanceof Gather ? \"gather\" : \"choice\";\n        const existingObj: ParsedObject = existingWeavePoint;\n\n        this.Error(\n          `A ${typeName} with the same label name '${\n            weavePoint.name\n          }' already exists in this context on line ${\n            existingObj.debugMetadata\n              ? existingObj.debugMetadata.startLineNumber\n              : \"NO DEBUG METADATA AVAILABLE\"\n          }`,\n          weavePoint as ParsedObject\n        );\n      }\n      if (weavePoint.identifier?.name) {\n        this.namedWeavePoints.set(weavePoint.identifier?.name, weavePoint);\n      }\n    }\n  };\n\n  public readonly ConstructWeaveHierarchyFromIndentation = (): void => {\n    // Find nested indentation and convert to a proper object hierarchy\n    // (i.e. indented content is replaced with a Weave object that contains\n    // that nested content)\n    let contentIdx = 0;\n    while (contentIdx < this.content.length) {\n      const obj: ParsedObject = this.content[contentIdx];\n\n      // Choice or Gather\n      if (obj instanceof Choice || obj instanceof Gather) {\n        const weavePoint: IWeavePoint = obj;\n        const weaveIndentIdx = weavePoint.indentationDepth - 1;\n\n        // Inner level indentation - recurse\n        if (weaveIndentIdx > this.baseIndentIndex) {\n          // Step through content until indent jumps out again\n          let innerWeaveStartIdx = contentIdx;\n          while (contentIdx < this.content.length) {\n            const innerWeaveObj =\n              asOrNull(this.content[contentIdx], Choice) ||\n              asOrNull(this.content[contentIdx], Gather);\n            if (innerWeaveObj !== null) {\n              const innerIndentIdx = innerWeaveObj.indentationDepth - 1;\n              if (innerIndentIdx <= this.baseIndentIndex) {\n                break;\n              }\n            }\n\n            contentIdx += 1;\n          }\n\n          const weaveContentCount = contentIdx - innerWeaveStartIdx;\n          const weaveContent = this.content.slice(\n            innerWeaveStartIdx,\n            innerWeaveStartIdx + weaveContentCount\n          );\n\n          this.content.splice(innerWeaveStartIdx, weaveContentCount);\n\n          const weave = new Weave(weaveContent, weaveIndentIdx);\n          this.InsertContent(innerWeaveStartIdx, weave);\n\n          // Continue iteration from this point\n          contentIdx = innerWeaveStartIdx;\n        }\n      }\n\n      contentIdx += 1;\n    }\n  };\n\n  // When the indentation wasn't told to us at construction time using\n  // a choice point with a known indentation level, we may be told to\n  // determine the indentation level by incrementing from our closest ancestor.\n  public readonly DetermineBaseIndentationFromContent = (\n    contentList: ParsedObject[]\n  ): number => {\n    for (const obj of contentList) {\n      if (obj instanceof Choice || obj instanceof Gather) {\n        return obj.indentationDepth - 1;\n      }\n    }\n\n    // No weave points, so it doesn't matter\n    return 0;\n  };\n\n  public readonly GenerateRuntimeObject = (): RuntimeContainer => {\n    this._rootContainer = new RuntimeContainer();\n    this.currentContainer = this._rootContainer;\n    this.looseEnds = [];\n    this.gatherPointsToResolve = [];\n\n    // Iterate through content for the block at this level of indentation\n    //  - Normal content is nested under Choices and Gathers\n    //  - Blocks that are further indented cause recursion\n    //  - Keep track of loose ends so that they can be diverted to Gathers\n    for (const obj of this.content) {\n      // Choice or Gather\n      if (obj instanceof Choice || obj instanceof Gather) {\n        this.AddRuntimeForWeavePoint(obj as IWeavePoint);\n      } else {\n        // Non-weave point\n        if (obj instanceof Weave) {\n          // Nested weave\n          const weave = obj;\n          this.AddRuntimeForNestedWeave(weave);\n          this.gatherPointsToResolve.splice(\n            0,\n            0,\n            ...weave.gatherPointsToResolve\n          );\n        } else {\n          // Other object\n          // May be complex object that contains statements - e.g. a multi-line conditional\n          this.AddGeneralRuntimeContent(obj.runtimeObject);\n        }\n      }\n    }\n\n    // Pass any loose ends up the hierarhcy\n    this.PassLooseEndsToAncestors();\n\n    return this._rootContainer;\n  };\n\n  // Found gather point:\n  //  - gather any loose ends\n  //  - set the gather as the main container to dump new content in\n  public readonly AddRuntimeForGather = (gather: Gather): void => {\n    // Determine whether this Gather should be auto-entered:\n    //  - It is auto-entered if there were no choices in the last section\n    //  - A section is \"since the previous gather\" - so reset now\n    const autoEnter = !this.hasSeenChoiceInSection;\n    this.hasSeenChoiceInSection = false;\n\n    const gatherContainer = gather.runtimeContainer;\n\n    if (!gather.name) {\n      // Use disallowed character so it's impossible to have a name collision\n      gatherContainer.name = `g-${this._unnamedGatherCount}`;\n      this._unnamedGatherCount += 1;\n    }\n\n    if (autoEnter) {\n      if (!this.currentContainer) {\n        throw new Error();\n      }\n\n      // Auto-enter: include in main content\n      this.currentContainer.AddContent(gatherContainer);\n    } else {\n      // Don't auto-enter:\n      // Add this gather to the main content, but only accessible\n      // by name so that it isn't stepped into automatically, but only via\n      // a divert from a loose end.\n      this.rootContainer.AddToNamedContentOnly(gatherContainer);\n    }\n\n    // Consume loose ends: divert them to this gather\n    for (const looseEndWeavePoint of this.looseEnds) {\n      const looseEnd = looseEndWeavePoint as ParsedObject;\n\n      // Skip gather loose ends that are at the same level\n      // since they'll be handled by the auto-enter code below\n      // that only jumps into the gather if (current runtime choices == 0)\n      if (looseEnd instanceof Gather) {\n        const prevGather = looseEnd;\n        if (prevGather.indentationDepth == gather.indentationDepth) {\n          continue;\n        }\n      }\n\n      let divert: RuntimeDivert | null = null;\n      if (looseEnd instanceof Divert) {\n        divert = looseEnd.runtimeObject as RuntimeDivert;\n      } else {\n        divert = new RuntimeDivert();\n        const looseWeavePoint = looseEnd as IWeavePoint;\n        if (!looseWeavePoint.runtimeContainer) {\n          throw new Error();\n        }\n\n        looseWeavePoint.runtimeContainer.AddContent(divert);\n      }\n\n      // Pass back knowledge of this loose end being diverted\n      // to the FlowBase so that it can maintain a list of them,\n      // and resolve the divert references later\n      this.gatherPointsToResolve.push(\n        new GatherPointToResolve(divert, gatherContainer)\n      );\n    }\n\n    this.looseEnds = [];\n\n    // Replace the current container itself\n    this.currentContainer = gatherContainer;\n  };\n\n  public readonly AddRuntimeForWeavePoint = (weavePoint: IWeavePoint): void => {\n    // Current level Gather\n    if (weavePoint instanceof Gather) {\n      this.AddRuntimeForGather(weavePoint);\n    }\n\n    // Current level choice\n    else if (weavePoint instanceof Choice) {\n      if (!this.currentContainer) {\n        throw new Error();\n      }\n\n      // Gathers that contain choices are no longer loose ends\n      // (same as when weave points get nested content)\n      if (this.previousWeavePoint instanceof Gather) {\n        this.looseEnds.splice(\n          this.looseEnds.indexOf(this.previousWeavePoint),\n          1\n        );\n      }\n\n      // Add choice point content\n      const choice = weavePoint; //, Choice);\n\n      this.currentContainer.AddContent(choice.runtimeObject);\n      if (!choice.innerContentContainer) {\n        throw new Error();\n      } //guaranteed not to happen\n\n      // Add choice's inner content to self\n      choice.innerContentContainer.name = `c-${this._choiceCount}`;\n      this.currentContainer.AddToNamedContentOnly(choice.innerContentContainer);\n      this._choiceCount += 1;\n\n      this.hasSeenChoiceInSection = true;\n    }\n\n    // Keep track of loose ends\n    this.addContentToPreviousWeavePoint = false; // default\n    if (this.WeavePointHasLooseEnd(weavePoint)) {\n      this.looseEnds.push(weavePoint);\n\n      const looseChoice = asOrNull(weavePoint, Choice);\n      if (looseChoice) {\n        this.addContentToPreviousWeavePoint = true;\n      }\n    }\n\n    this.previousWeavePoint = weavePoint;\n  };\n\n  // Add nested block at a greater indentation level\n  public readonly AddRuntimeForNestedWeave = (nestedResult: Weave): void => {\n    // Add this inner block to current container\n    // (i.e. within the main container, or within the last defined Choice/Gather)\n    this.AddGeneralRuntimeContent(nestedResult.rootContainer);\n\n    // Now there's a deeper indentation level, the previous weave point doesn't\n    // count as a loose end (since it will have content to go to)\n    if (this.previousWeavePoint !== null) {\n      this.looseEnds.splice(this.looseEnds.indexOf(this.previousWeavePoint), 1);\n\n      this.addContentToPreviousWeavePoint = false;\n    }\n  };\n\n  // Normal content gets added into the latest Choice or Gather by default,\n  // unless there hasn't been one yet.\n  public readonly AddGeneralRuntimeContent = (content: RuntimeObject): void => {\n    // Content is allowed to evaluate runtimeObject to null\n    // (e.g. AuthorWarning, which doesn't make it into the runtime)\n    if (content === null) {\n      return;\n    }\n\n    if (this.addContentToPreviousWeavePoint) {\n      if (\n        !this.previousWeavePoint ||\n        !this.previousWeavePoint.runtimeContainer\n      ) {\n        throw new Error();\n      }\n\n      this.previousWeavePoint.runtimeContainer.AddContent(content);\n    } else {\n      if (!this.currentContainer) {\n        throw new Error();\n      }\n\n      this.currentContainer.AddContent(content);\n    }\n  };\n\n  public readonly PassLooseEndsToAncestors = () => {\n    if (this.looseEnds.length === 0) {\n      return;\n    }\n\n    // Search for Weave ancestor to pass loose ends to for gathering.\n    // There are two types depending on whether the current weave\n    // is separated by a conditional or sequence.\n    //  - An \"inner\" weave is one that is directly connected to the current\n    //    weave - i.e. you don't have to pass through a conditional or\n    //    sequence to get to it. We're allowed to pass all loose ends to\n    //    one of these.\n    //  - An \"outer\" weave is one that is outside of a conditional/sequence\n    //    that the current weave is nested within. We're only allowed to\n    //    pass gathers (i.e. 'normal flow') loose ends up there, not normal\n    //    choices. The rule is that choices have to be diverted explicitly\n    //    by the author since it's ambiguous where flow should go otherwise.\n    //\n    // e.g.:\n    //\n    //   - top                       <- e.g. outer weave\n    //   {true:\n    //       * choice                <- e.g. inner weave\n    //         * * choice 2\n    //             more content      <- e.g. current weave\n    //       * choice 2\n    //   }\n    //   - more of outer weave\n    //\n    let closestInnerWeaveAncestor: Weave | null = null;\n    let closestOuterWeaveAncestor: Weave | null = null;\n\n    // Find inner and outer ancestor weaves as defined above.\n    let nested = false;\n    for (\n      let ancestor = this.parent;\n      ancestor !== null;\n      ancestor = ancestor.parent\n    ) {\n      // Found ancestor?\n      const weaveAncestor = asOrNull(ancestor, Weave);\n      if (weaveAncestor) {\n        if (!nested && closestInnerWeaveAncestor === null) {\n          closestInnerWeaveAncestor = weaveAncestor;\n        }\n\n        if (nested && closestOuterWeaveAncestor === null) {\n          closestOuterWeaveAncestor = weaveAncestor;\n        }\n      }\n\n      // Weaves nested within Sequences or Conditionals are\n      // \"sealed\" - any loose ends require explicit diverts.\n      if (ancestor instanceof Sequence || ancestor instanceof Conditional) {\n        nested = true;\n      }\n    }\n\n    // No weave to pass loose ends to at all?\n    if (\n      closestInnerWeaveAncestor === null &&\n      closestOuterWeaveAncestor === null\n    ) {\n      return;\n    }\n\n    // Follow loose end passing logic as defined above\n    for (let ii = this.looseEnds.length - 1; ii >= 0; ii -= 1) {\n      const looseEnd = this.looseEnds[ii];\n      let received = false;\n\n      if (nested) {\n        // This weave is nested within a conditional or sequence:\n        //  - choices can only be passed up to direct ancestor (\"inner\") weaves\n        //  - gathers can be passed up to either, but favour the closer (inner) weave\n        //    if there is one\n        if (looseEnd instanceof Choice && closestInnerWeaveAncestor !== null) {\n          closestInnerWeaveAncestor.ReceiveLooseEnd(looseEnd);\n          received = true;\n        } else if (!(looseEnd instanceof Choice)) {\n          const receivingWeave =\n            closestInnerWeaveAncestor || closestOuterWeaveAncestor;\n          if (receivingWeave !== null) {\n            receivingWeave.ReceiveLooseEnd(looseEnd);\n            received = true;\n          }\n        }\n      } else {\n        // No nesting, all loose ends can be safely passed up\n        if (closestInnerWeaveAncestor?.hasOwnProperty(\"ReceiveLooseEnd\")) {\n          closestInnerWeaveAncestor!.ReceiveLooseEnd(looseEnd);\n        }\n        received = true;\n      }\n\n      if (received) {\n        this.looseEnds.splice(ii, 1);\n      }\n    }\n  };\n\n  public readonly ReceiveLooseEnd = (childWeaveLooseEnd: IWeavePoint): void => {\n    this.looseEnds.push(childWeaveLooseEnd);\n  };\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n\n    // Check that choices nested within conditionals and sequences are terminated\n    if (this.looseEnds !== null && this.looseEnds.length > 0) {\n      let isNestedWeave = false;\n      for (\n        let ancestor = this.parent;\n        ancestor !== null;\n        ancestor = ancestor.parent\n      ) {\n        if (ancestor instanceof Sequence || ancestor instanceof Conditional) {\n          isNestedWeave = true;\n          break;\n        }\n      }\n\n      if (isNestedWeave) {\n        this.ValidateTermination(this.BadNestedTerminationHandler);\n      }\n    }\n\n    for (const gatherPoint of this.gatherPointsToResolve) {\n      gatherPoint.divert.targetPath = gatherPoint.targetRuntimeObj.path;\n    }\n\n    this.CheckForWeavePointNamingCollisions();\n  }\n\n  public readonly WeavePointNamed = (name: string): IWeavePoint | null => {\n    if (!this.namedWeavePoints) {\n      return null;\n    }\n\n    let weavePointResult:\n      | IWeavePoint\n      | null\n      | undefined = this.namedWeavePoints.get(name);\n    if (weavePointResult) {\n      return weavePointResult;\n    }\n\n    return null;\n  };\n\n  // Global VARs and CONSTs are treated as \"outside of the flow\"\n  // when iterating over content that follows loose ends\n  public readonly IsGlobalDeclaration = (obj: ParsedObject) => {\n    const varAss = asOrNull(obj, VariableAssignment);\n    if (varAss && varAss.isGlobalDeclaration && varAss.isDeclaration) {\n      return true;\n    }\n\n    const constDecl = asOrNull(obj, ConstantDeclaration);\n    if (constDecl) {\n      return true;\n    }\n\n    return false;\n  };\n\n  // While analysing final loose ends, we look to see whether there\n  // are any diverts etc which choices etc divert from\n  public readonly ContentThatFollowsWeavePoint = (\n    weavePoint: IWeavePoint\n  ): ParsedObject[] => {\n    const returned = [];\n    const obj = weavePoint as ParsedObject;\n\n    // Inner content first (e.g. for a choice)\n    if (obj.content !== null) {\n      for (const contentObj of obj.content) {\n        // Global VARs and CONSTs are treated as \"outside of the flow\"\n        if (this.IsGlobalDeclaration(contentObj)) {\n          continue;\n        }\n\n        returned.push(contentObj);\n      }\n    }\n\n    const parentWeave = asOrNull(obj.parent, Weave);\n    if (parentWeave === null) {\n      throw new Error(\"Expected weave point parent to be weave?\");\n    }\n\n    const weavePointIdx = parentWeave.content.indexOf(obj);\n    for (let ii = weavePointIdx + 1; ii < parentWeave.content.length; ii += 1) {\n      const laterObj = parentWeave.content[ii];\n\n      // Global VARs and CONSTs are treated as \"outside of the flow\"\n      if (this.IsGlobalDeclaration(laterObj)) {\n        continue;\n      }\n\n      // End of the current flow\n      // if (laterObj instanceof IWeavePoint) // cannot test on interface in ts\n      if (laterObj instanceof Choice || laterObj instanceof Gather) {\n        break;\n      }\n\n      // Other weaves will be have their own loose ends\n      if (laterObj instanceof Weave) {\n        break;\n      }\n\n      returned.push(laterObj);\n    }\n\n    return returned;\n  };\n\n  public readonly ValidateTermination = (\n    badTerminationHandler: BadTerminationHandler\n  ): void => {\n    // Don't worry if the last object in the flow is a \"TODO\",\n    // even if there are other loose ends in other places\n    if (this.lastParsedSignificantObject instanceof AuthorWarning) {\n      return;\n    }\n\n    // By now, any sub-weaves will have passed loose ends up to the root weave (this).\n    // So there are 2 possible situations:\n    //  - There are loose ends from somewhere in the flow.\n    //    These aren't necessarily \"real\" loose ends - they're weave points\n    //    that don't connect to any lower weave points, so we just\n    //    have to check that they terminate properly.\n    //  - This weave is just a list of content with no actual weave points,\n    //    so we just need to check that the list of content terminates.\n\n    const hasLooseEnds: boolean =\n      this.looseEnds !== null && this.looseEnds.length > 0;\n\n    if (hasLooseEnds) {\n      for (const looseEnd of this.looseEnds) {\n        const looseEndFlow = this.ContentThatFollowsWeavePoint(looseEnd);\n        this.ValidateFlowOfObjectsTerminates(\n          looseEndFlow,\n          looseEnd as ParsedObject,\n          badTerminationHandler\n        );\n      }\n    } else {\n      // No loose ends... is there any inner weaving at all?\n      // If not, make sure the single content stream is terminated correctly\n      //\n      // If there's any actual weaving, assume that content is\n      // terminated correctly since we would've had a loose end otherwise\n      for (const obj of this.content) {\n        if (obj instanceof Choice || obj instanceof Divert) {\n          return;\n        }\n      }\n\n      // Straight linear flow? Check it terminates\n      this.ValidateFlowOfObjectsTerminates(\n        this.content,\n        this,\n        badTerminationHandler\n      );\n    }\n  };\n\n  readonly BadNestedTerminationHandler: BadTerminationHandler = (\n    terminatingObj\n  ) => {\n    let conditional: Conditional | null = null;\n    for (\n      let ancestor = terminatingObj.parent;\n      ancestor !== null;\n      ancestor = ancestor.parent\n    ) {\n      if (ancestor instanceof Sequence || ancestor instanceof Conditional) {\n        conditional = asOrNull(ancestor, Conditional);\n        break;\n      }\n    }\n\n    let errorMsg =\n      \"Choices nested in conditionals or sequences need to explicitly divert afterwards.\";\n\n    // Tutorialise proper choice syntax if this looks like a single choice within a condition, e.g.\n    // { condition:\n    //      * choice\n    // }\n    if (conditional !== null) {\n      let numChoices = conditional.FindAll<Choice>(Choice)().length;\n      if (numChoices === 1) {\n        errorMsg = `Choices with conditions should be written: '* {condition} choice'. Otherwise, ${errorMsg.toLowerCase()}`;\n      }\n    }\n\n    this.Error(errorMsg, terminatingObj);\n  };\n\n  public readonly ValidateFlowOfObjectsTerminates = (\n    objFlow: ParsedObject[],\n    defaultObj: ParsedObject,\n    badTerminationHandler: BadTerminationHandler\n  ) => {\n    let terminated = false;\n    let terminatingObj: ParsedObject = defaultObj;\n    for (const flowObj of objFlow) {\n      const divert = flowObj.Find(Divert)(\n        (d) =>\n          !d.isThread &&\n          !d.isTunnel &&\n          !d.isFunctionCall &&\n          !(d.parent instanceof DivertTarget)\n      );\n\n      if (divert !== null) {\n        terminated = true;\n      }\n\n      if (flowObj.Find(TunnelOnwards)() != null) {\n        terminated = true;\n        break;\n      }\n\n      terminatingObj = flowObj;\n    }\n\n    if (!terminated) {\n      // Author has left a note to self here - clearly we don't need\n      // to leave them with another warning since they know what they're doing.\n      if (terminatingObj instanceof AuthorWarning) {\n        return;\n      }\n\n      badTerminationHandler(terminatingObj);\n    }\n  };\n\n  public readonly WeavePointHasLooseEnd = (\n    weavePoint: IWeavePoint\n  ): boolean => {\n    // No content, must be a loose end.\n    if (weavePoint.content === null) {\n      return true;\n    }\n\n    // If a weave point is diverted from, it doesn't have a loose end.\n    // Detect a divert object within a weavePoint's main content\n    // Work backwards since we're really interested in the end,\n    // although it doesn't actually make a difference!\n    // (content after a divert will simply be inaccessible)\n    for (let ii = weavePoint.content.length - 1; ii >= 0; --ii) {\n      let innerDivert = asOrNull(weavePoint.content[ii], Divert);\n      if (innerDivert) {\n        const willReturn =\n          innerDivert.isThread ||\n          innerDivert.isTunnel ||\n          innerDivert.isFunctionCall;\n        if (!willReturn) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  };\n\n  // Enforce rule that weave points must not have the same\n  // name as any stitches or knots upwards in the hierarchy\n  public readonly CheckForWeavePointNamingCollisions = (): void => {\n    if (!this.namedWeavePoints) {\n      return;\n    }\n\n    const ancestorFlows = [];\n    for (const obj of this.ancestry) {\n      const flow = asOrNull(obj, FlowBase);\n      if (flow) {\n        ancestorFlows.push(flow);\n      } else {\n        break;\n      }\n    }\n\n    for (const [weavePointName, weavePoint] of this.namedWeavePoints) {\n      for (const flow of ancestorFlows) {\n        // Shallow search\n        const otherContentWithName = flow.ContentWithNameAtLevel(\n          weavePointName\n        );\n        if (otherContentWithName && otherContentWithName !== weavePoint) {\n          const errorMsg = `${weavePoint.GetType()} '${weavePointName}' has the same label name as a ${otherContentWithName.GetType()} (on ${\n            otherContentWithName.debugMetadata\n          })`;\n          this.Error(errorMsg, weavePoint);\n        }\n      }\n    }\n  };\n}\n","﻿import { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { ControlCommand as RuntimeControlCommand } from \"../../../../engine/ControlCommand\";\nimport { Divert as RuntimeDivert } from \"../../../../engine/Divert\";\nimport { Expression } from \"../Expression/Expression\";\nimport { ParsedObject } from \"../Object\";\nimport { InkObject as RuntimeObject } from \"../../../../engine/Object\";\nimport { NativeFunctionCall } from \"../../../../engine/NativeFunctionCall\";\nimport { StringValue } from \"../../../../engine/Value\";\nimport { Story } from \"../Story\";\nimport { Text } from \"../Text\";\nimport { Weave } from \"../Weave\";\nimport { asOrNull } from \"../../../../engine/TypeAssertion\";\n\nexport class ConditionalSingleBranch extends ParsedObject {\n  public _contentContainer: RuntimeContainer | null = null;\n  public _conditionalDivert: RuntimeDivert | null = null;\n  public _ownExpression: Expression | null = null;\n  public _innerWeave: Weave | null = null;\n  // bool condition, e.g.:\n  // { 5 == 4:\n  //   - the true branch\n  //   - the false branch\n  // }\n  public isTrueBranch: boolean = false;\n\n  // When each branch has its own expression like a switch statement,\n  // this is non-null. e.g.\n  // { x:\n  //    - 4: the value of x is four (ownExpression is the value 4)\n  //    - 3: the value of x is three\n  // }\n  get ownExpression() {\n    return this._ownExpression;\n  }\n\n  set ownExpression(value) {\n    this._ownExpression = value;\n    if (this._ownExpression) {\n      this.AddContent(this._ownExpression);\n    }\n  }\n\n  // In the above example, match equality of x with 4 for the first branch.\n  // This is as opposed to simply evaluating boolean equality for each branch,\n  // example when shouldMatchEquality is FALSE:\n  // {\n  //    3 > 2:  This will happen\n  //    2 > 3:  This won't happen\n  // }\n  public matchingEquality: boolean = false;\n\n  public isElse: boolean = false;\n  public isInline: boolean = false;\n\n  public returnDivert: RuntimeDivert | null = null;\n\n  constructor(content?: ParsedObject[] | null | undefined) {\n    super();\n\n    // Branches are allowed to be empty\n    if (content) {\n      this._innerWeave = new Weave(content);\n      this.AddContent(this._innerWeave);\n    }\n  }\n\n  // Runtime content can be summarised as follows:\n  //  - Evaluate an expression if necessary to branch on\n  //  - Branch to a named container if true\n  //       - Divert back to main flow\n  //         (owner Conditional is in control of this target point)\n  public readonly GenerateRuntimeObject = (): RuntimeObject => {\n    // Check for common mistake, of putting \"else:\" instead of \"- else:\"\n    if (this._innerWeave) {\n      for (const c of this._innerWeave.content) {\n        const text = asOrNull(c, Text);\n        if (text) {\n          // Don't need to trim at the start since the parser handles that already\n          if (text.text.startsWith(\"else:\")) {\n            this.Warning(\n              \"Saw the text 'else:' which is being treated as content. Did you mean '- else:'?\",\n              text\n            );\n          }\n        }\n      }\n    }\n\n    const container = new RuntimeContainer();\n\n    // Are we testing against a condition that's used for more than just this\n    // branch? If so, the first thing we need to do is replicate the value that's\n    // on the evaluation stack so that we don't fully consume it, in case other\n    // branches need to use it.\n    const duplicatesStackValue: boolean = this.matchingEquality && !this.isElse;\n\n    if (duplicatesStackValue) {\n      container.AddContent(RuntimeControlCommand.Duplicate());\n    }\n\n    this._conditionalDivert = new RuntimeDivert();\n\n    // else clause is unconditional catch-all, otherwise the divert is conditional\n    this._conditionalDivert.isConditional = !this.isElse;\n\n    // Need extra evaluation?\n    if (!this.isTrueBranch && !this.isElse) {\n      const needsEval: boolean = this.ownExpression !== null;\n      if (needsEval) {\n        container.AddContent(RuntimeControlCommand.EvalStart());\n      }\n\n      if (this.ownExpression) {\n        this.ownExpression.GenerateIntoContainer(container);\n      }\n\n      // Uses existing duplicated value\n      if (this.matchingEquality) {\n        container.AddContent(NativeFunctionCall.CallWithName(\"==\"));\n      }\n\n      if (needsEval) {\n        container.AddContent(RuntimeControlCommand.EvalEnd());\n      }\n    }\n\n    // Will pop from stack if conditional\n    container.AddContent(this._conditionalDivert);\n\n    this._contentContainer = this.GenerateRuntimeForContent();\n    this._contentContainer.name = \"b\";\n\n    // Multi-line conditionals get a newline at the start of each branch\n    // (as opposed to the start of the multi-line conditional since the condition\n    //  may evaluate to false.)\n    if (!this.isInline) {\n      this._contentContainer.InsertContent(new StringValue(\"\\n\"), 0);\n    }\n\n    if (duplicatesStackValue || (this.isElse && this.matchingEquality)) {\n      this._contentContainer.InsertContent(\n        RuntimeControlCommand.PopEvaluatedValue(),\n        0\n      );\n    }\n\n    container.AddToNamedContentOnly(this._contentContainer);\n\n    this.returnDivert = new RuntimeDivert();\n    this._contentContainer.AddContent(this.returnDivert);\n\n    return container;\n  };\n\n  public readonly GenerateRuntimeForContent = (): RuntimeContainer => {\n    // Empty branch - create empty container\n    if (this._innerWeave === null) {\n      return new RuntimeContainer();\n    }\n\n    return this._innerWeave.rootContainer;\n  };\n\n  public ResolveReferences(context: Story): void {\n    if (!this._conditionalDivert || !this._contentContainer) {\n      throw new Error();\n    }\n\n    this._conditionalDivert.targetPath = this._contentContainer.path;\n    super.ResolveReferences(context);\n  }\n}\n","export enum StatementLevel {\n  InnerBlock,\n  Stitch,\n  Knot,\n  Top,\n}\n","export class DebugMetadata {\n  public startLineNumber: number = 0;\n  public endLineNumber: number = 0;\n  public startCharacterNumber: number = 0;\n  public endCharacterNumber: number = 0;\n  public fileName: string | null = null;\n  public sourceName: string | null = null;\n\n  public Merge(dm: DebugMetadata) {\n    let newDebugMetadata = new DebugMetadata();\n\n    newDebugMetadata.fileName = this.fileName;\n    newDebugMetadata.sourceName = this.sourceName;\n\n    if (this.startLineNumber < dm.startLineNumber) {\n      newDebugMetadata.startLineNumber = this.startLineNumber;\n      newDebugMetadata.startCharacterNumber = this.startCharacterNumber;\n    } else if (this.startLineNumber > dm.startLineNumber) {\n      newDebugMetadata.startLineNumber = dm.startLineNumber;\n      newDebugMetadata.startCharacterNumber = dm.startCharacterNumber;\n    } else {\n      newDebugMetadata.startLineNumber = this.startLineNumber;\n      newDebugMetadata.startCharacterNumber = Math.min(\n        this.startCharacterNumber,\n        dm.startCharacterNumber\n      );\n    }\n\n    if (this.endLineNumber > dm.endLineNumber) {\n      newDebugMetadata.endLineNumber = this.endLineNumber;\n      newDebugMetadata.endCharacterNumber = this.endCharacterNumber;\n    } else if (this.endLineNumber < dm.endLineNumber) {\n      newDebugMetadata.endLineNumber = dm.endLineNumber;\n      newDebugMetadata.endCharacterNumber = dm.endCharacterNumber;\n    } else {\n      newDebugMetadata.endLineNumber = this.endLineNumber;\n      newDebugMetadata.endCharacterNumber = Math.max(\n        this.endCharacterNumber,\n        dm.endCharacterNumber\n      );\n    }\n\n    return newDebugMetadata;\n  }\n\n  public toString() {\n    if (this.fileName !== null) {\n      return `line ${this.startLineNumber} of ${this.fileName}\"`;\n    } else {\n      return \"line \" + this.startLineNumber;\n    }\n  }\n}\n","import { INamedContent } from \"../../../../engine/INamedContent\";\nimport { ParsedObject } from \"../Object\";\nimport { InkObject as RuntimeObject } from \"../../../../engine/Object\";\nimport { Identifier } from \"../Identifier\";\n\nexport class ExternalDeclaration extends ParsedObject implements INamedContent {\n  public get name(): string | null {\n    return this.identifier?.name || null;\n  }\n\n  constructor(\n    public readonly identifier: Identifier,\n    public readonly argumentNames: string[]\n  ) {\n    super();\n  }\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject | null => {\n    this.story.AddExternal(this);\n\n    // No runtime code exists for an external, only metadata\n    return null;\n  };\n\n  public toString(): string {\n    return `EXTERNAL ${this.identifier?.name}`;\n  }\n}\n","import { Argument } from \"./ParsedHierarchy/Argument\";\nimport { Identifier } from \"./ParsedHierarchy/Identifier\";\n\nexport class FlowDecl {\n  constructor(\n    public readonly name: Identifier,\n    public readonly args: Argument[],\n    public readonly isFunction: boolean\n  ) {}\n}\n","import { ParsedObject } from \"./Object\";\nimport { InkObject as RuntimeObject } from \"../../../engine/Object\";\n\nexport class Wrap<T extends RuntimeObject> extends ParsedObject {\n  constructor(private _objToWrap: T) {\n    super();\n  }\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject => this._objToWrap;\n}\n","import { Glue as RuntimeGlue } from \"../../../engine/Glue\";\nimport { Wrap } from \"./Wrap\";\n\nexport class Glue extends Wrap<RuntimeGlue> {\n  constructor(glue: RuntimeGlue) {\n    super(glue);\n  }\n}\n","import { InkObject } from \"./Object\";\n\nexport class Glue extends InkObject {\n  public toString() {\n    return \"Glue\";\n  }\n}\n","import { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { ContentList } from \"../ContentList\";\nimport { Expression } from \"./Expression\";\nimport { FlowBase } from \"../Flow/FlowBase\";\nimport { NativeFunctionCall } from \"../../../../engine/NativeFunctionCall\";\nimport { IntValue } from \"../../../../engine/Value\";\nimport { Story } from \"../Story\";\nimport { VariableAssignment as RuntimeVariableAssignment } from \"../../../../engine/VariableAssignment\";\nimport { VariableReference as RuntimeVariableReference } from \"../../../../engine/VariableReference\";\nimport { Weave } from \"../Weave\";\nimport { Identifier } from \"../Identifier\";\n\nexport class IncDecExpression extends Expression {\n  private _runtimeAssignment: RuntimeVariableAssignment | null = null;\n\n  public isInc: boolean;\n  public expression: Expression | null = null;\n\n  constructor(\n    public readonly varIdentifier: Identifier | null,\n    isIncOrExpression: boolean | Expression,\n    isInc?: boolean\n  ) {\n    super();\n\n    if (isIncOrExpression instanceof Expression) {\n      this.expression = isIncOrExpression;\n      this.AddContent(this.expression);\n      this.isInc = Boolean(isInc);\n    } else {\n      this.isInc = isIncOrExpression as boolean;\n    }\n  }\n\n  public readonly GenerateIntoContainer = (\n    container: RuntimeContainer\n  ): void => {\n    // x = x + y\n    // ^^^ ^ ^ ^\n    //  4  1 3 2\n    // Reverse polish notation: (x 1 +) (assign to x)\n\n    // 1.\n    container.AddContent(\n      new RuntimeVariableReference(this.varIdentifier?.name || null)\n    );\n\n    // 2.\n    // - Expression used in the form ~ x += y\n    // - Simple version: ~ x++\n    if (this.expression) {\n      this.expression.GenerateIntoContainer(container);\n    } else {\n      container.AddContent(new IntValue(1));\n    }\n\n    // 3.\n    container.AddContent(\n      NativeFunctionCall.CallWithName(this.isInc ? \"+\" : \"-\")\n    );\n\n    // 4.\n    this._runtimeAssignment = new RuntimeVariableAssignment(\n      this.varIdentifier?.name || null,\n      false\n    );\n    container.AddContent(this._runtimeAssignment);\n  };\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n\n    const varResolveResult = context.ResolveVariableWithName(\n      this.varIdentifier?.name || \"\",\n      this\n    );\n\n    if (!varResolveResult.found) {\n      this.Error(\n        `variable for ${this.incrementDecrementWord} could not be found: '${this.varIdentifier}' after searching: {this.descriptionOfScope}`\n      );\n    }\n\n    if (!this._runtimeAssignment) {\n      throw new Error();\n    }\n\n    this._runtimeAssignment.isGlobal = varResolveResult.isGlobal;\n\n    if (\n      !(this.parent instanceof Weave) &&\n      !(this.parent instanceof FlowBase) &&\n      !(this.parent instanceof ContentList)\n    ) {\n      this.Error(`Can't use ${this.incrementDecrementWord} as sub-expression`);\n    }\n  }\n\n  get incrementDecrementWord(): \"increment\" | \"decrement\" {\n    if (this.isInc) {\n      return \"increment\";\n    }\n\n    return \"decrement\";\n  }\n\n  public readonly toString = (): string => {\n    if (this.expression) {\n      return `${this.varIdentifier?.name}${this.isInc ? \" += \" : \" -= \"}${\n        this.expression\n      }`;\n    }\n\n    return `${this.varIdentifier?.name}` + (this.isInc ? \"++\" : \"--\");\n  };\n}\n","import { ParsedObject } from \"./Object\";\nimport { InkObject as RuntimeObject } from \"../../../engine/Object\";\nimport { Story } from \"./Story\";\n\nexport class IncludedFile extends ParsedObject {\n  constructor(public readonly includedStory: Story | null) {\n    super();\n  }\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject | null => {\n    // Left to the main story to process\n    return null;\n  };\n}\n","export class InfixOperator {\n  constructor(\n    public readonly type: string,\n    public readonly precedence: number,\n    public readonly requireWhitespace: boolean\n  ) {}\n\n  public readonly toString = (): string => this.type;\n}\n","import { Argument } from \"./Argument\";\nimport { FlowBase } from \"./Flow/FlowBase\";\nimport { FlowLevel } from \"./Flow/FlowLevel\";\nimport { Identifier } from \"./Identifier\";\nimport { ParsedObject } from \"./Object\";\nimport { Story } from \"./Story\";\n\nexport class Knot extends FlowBase {\n  get flowLevel(): FlowLevel {\n    return FlowLevel.Knot;\n  }\n\n  constructor(\n    name: Identifier,\n    topLevelObjects: ParsedObject[],\n    args: Argument[],\n    isFunction: boolean\n  ) {\n    super(name, topLevelObjects, args, isFunction);\n  }\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n\n    let parentStory = this.story;\n\n    // Enforce rule that stitches must not have the same\n    // name as any knots that exist in the story\n    for (const stitchName in this.subFlowsByName) {\n      const knotWithStitchName = parentStory.ContentWithNameAtLevel(\n        stitchName,\n        FlowLevel.Knot,\n        false\n      );\n\n      if (knotWithStitchName) {\n        const stitch = this.subFlowsByName.get(stitchName);\n        const errorMsg = `Stitch '${\n          stitch ? stitch.name : \"NO STITCH FOUND\"\n        }' has the same name as a knot (on ${\n          knotWithStitchName.debugMetadata\n        })`;\n        this.Error(errorMsg, stitch);\n      }\n    }\n  }\n}\n","import { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { Expression } from \"../Expression/Expression\";\nimport { InkList as RuntimeInkList } from \"../../../../engine/InkList\";\nimport { InkListItem as RuntimeInkListItem } from \"../../../../engine/InkList\";\nimport { ListElementDefinition } from \"./ListElementDefinition\";\nimport { ListValue } from \"../../../../engine/Value\";\nimport { Identifier } from \"../Identifier\";\n\nexport class List extends Expression {\n  constructor(public readonly itemIdentifierList: Identifier[]) {\n    super();\n  }\n\n  public readonly GenerateIntoContainer = (\n    container: RuntimeContainer\n  ): void => {\n    const runtimeRawList = new RuntimeInkList();\n\n    if (this.itemIdentifierList != null) {\n      for (const itemIdentifier of this.itemIdentifierList) {\n        const nameParts = itemIdentifier?.name?.split(\".\") || [];\n\n        let listName: string | null = null;\n        let listItemName: string = \"\";\n        if (nameParts.length > 1) {\n          listName = nameParts[0];\n          listItemName = nameParts[1];\n        } else {\n          listItemName = nameParts[0];\n        }\n\n        const listItem = this.story.ResolveListItem(\n          listName,\n          listItemName,\n          this\n        ) as ListElementDefinition;\n\n        if (listItem === null) {\n          if (listName === null) {\n            this.Error(\n              `Could not find list definition that contains item '${itemIdentifier}'`\n            );\n          } else {\n            this.Error(`Could not find list item ${itemIdentifier}`);\n          }\n        } else {\n          if (listItem.parent == null) {\n            this.Error(\n              `Could not find list definition for item ${itemIdentifier}`\n            );\n            return;\n          }\n          if (!listName) {\n            listName = listItem.parent.identifier?.name || null;\n          }\n\n          const item = new RuntimeInkListItem(listName, listItem.name || null);\n\n          if (runtimeRawList.has(item.serialized())) {\n            this.Warning(`Duplicate of item '${itemIdentifier}' in list.`);\n          } else {\n            runtimeRawList.Add(item, listItem.seriesValue);\n          }\n        }\n      }\n    }\n\n    container.AddContent(new ListValue(runtimeRawList));\n  };\n}\n","import { ListDefinition } from \"./ListDefinition\";\nimport { ParsedObject } from \"../Object\";\nimport { InkObject as RuntimeObject } from \"../../../../engine/Object\";\nimport { Story } from \"../Story\";\nimport { SymbolType } from \"../SymbolType\";\nimport { Identifier } from \"../Identifier\";\n\nexport class ListElementDefinition extends ParsedObject {\n  public seriesValue: number = 0;\n\n  public parent: ListDefinition | null = null;\n\n  get fullName(): string {\n    const parentList = this.parent;\n    if (parentList === null) {\n      throw new Error(\"Can't get full name without a parent list.\");\n    }\n\n    return `${parentList.identifier?.name}.${this.name}`;\n  }\n\n  get typeName(): string {\n    return \"List element\";\n  }\n\n  get name(): string | null {\n    return this.indentifier?.name || null;\n  }\n\n  constructor(\n    public readonly indentifier: Identifier,\n    public readonly inInitialList: boolean,\n    public readonly explicitValue: number | null = null\n  ) {\n    super();\n    this.parent = super.parent as ListDefinition;\n  }\n\n  public readonly GenerateRuntimeObject = (): RuntimeObject => {\n    throw new Error(\"Not implemented.\");\n  };\n\n  public ResolveReferences(context: Story): void {\n    super.ResolveReferences(context);\n    context.CheckForNamingCollisions(\n      this,\n      this.indentifier,\n      SymbolType.ListItem\n    );\n  }\n\n  public readonly toString = (): string => this.fullName;\n}\n","import { Argument } from \"./Argument\";\nimport { FlowBase } from \"./Flow/FlowBase\";\nimport { FlowLevel } from \"./Flow/FlowLevel\";\nimport { Identifier } from \"./Identifier\";\nimport { ParsedObject } from \"./Object\";\n\nexport class Stitch extends FlowBase {\n  get flowLevel(): FlowLevel {\n    return FlowLevel.Stitch;\n  }\n\n  constructor(\n    name: Identifier,\n    topLevelObjects: ParsedObject[],\n    args: Argument[],\n    isFunction: boolean\n  ) {\n    super(name, topLevelObjects, args, isFunction);\n  }\n\n  public toString = (): string => {\n    return `${\n      this.parent !== null ? this.parent + \" > \" : \"\"\n    }${super.toString()}`;\n  };\n}\n","import { InkObject } from \"./Object\";\n\nexport class Tag extends InkObject {\n  public readonly text: string;\n\n  constructor(tagText: string) {\n    super();\n    this.text = tagText.toString() || \"\";\n  }\n\n  public toString(): string {\n    return \"# \" + this.text;\n  }\n}\n","import { Path } from \"./Path\";\nimport { CallStack } from \"./CallStack\";\nimport { throwNullException } from \"./NullException\";\nimport { InkObject } from \"./Object\";\n\nexport class Choice extends InkObject {\n  public text: string = \"\";\n  public index: number = 0;\n  public threadAtGeneration: CallStack.Thread | null = null;\n  public sourcePath: string = \"\";\n  public targetPath: Path | null = null;\n  public isInvisibleDefault: boolean = false;\n  public originalThreadIndex: number = 0;\n\n  get pathStringOnChoice(): string {\n    if (this.targetPath === null)\n      return throwNullException(\"Choice.targetPath\");\n    return this.targetPath.toString();\n  }\n  set pathStringOnChoice(value: string) {\n    this.targetPath = new Path(value);\n  }\n}\n","import { InkListItem } from \"./InkList\";\nimport { ListValue } from \"./Value\";\nimport { ListDefinition } from \"./ListDefinition\";\nimport { TryGetResult } from \"./TryGetResult\";\nimport { throwNullException } from \"./NullException\";\n\nexport class ListDefinitionsOrigin {\n  protected _lists: Map<string, ListDefinition>;\n  protected _allUnambiguousListValueCache: Map<string, ListValue>;\n\n  constructor(lists: ListDefinition[]) {\n    this._lists = new Map();\n    this._allUnambiguousListValueCache = new Map();\n\n    for (let list of lists) {\n      this._lists.set(list.name, list);\n\n      for (let [key, val] of list.items) {\n        let item = InkListItem.fromSerializedKey(key);\n        let listValue = new ListValue(item, val);\n\n        if (!item.itemName) {\n          throw new Error(\"item.itemName is null or undefined.\");\n        }\n\n        this._allUnambiguousListValueCache.set(item.itemName, listValue);\n        this._allUnambiguousListValueCache.set(item.fullName, listValue);\n      }\n    }\n  }\n  get lists(): ListDefinition[] {\n    let listOfLists: ListDefinition[] = [];\n\n    for (let [, value] of this._lists) {\n      listOfLists.push(value);\n    }\n\n    return listOfLists;\n  }\n  public TryListGetDefinition(\n    name: string | null,\n    /* out */ def: ListDefinition | null\n  ): TryGetResult<ListDefinition | null> {\n    if (name === null) {\n      return { result: def, exists: false };\n    }\n    // initially, this function returns a boolean and the second parameter is an out.\n    let definition = this._lists.get(name);\n    if (!definition) return { result: def, exists: false };\n\n    return { result: definition, exists: true };\n  }\n  public FindSingleItemListWithName(name: string | null) {\n    if (name === null) {\n      return throwNullException(\"name\");\n    }\n    let val = this._allUnambiguousListValueCache.get(name);\n\n    if (typeof val !== \"undefined\") {\n      return val;\n    }\n\n    return null;\n  }\n}\n","import { Container } from \"./Container\";\nimport {\n  Value,\n  IntValue,\n  FloatValue,\n  StringValue,\n  DivertTargetValue,\n  VariablePointerValue,\n  ListValue,\n  BoolValue,\n} from \"./Value\";\nimport { Glue } from \"./Glue\";\nimport { ControlCommand } from \"./ControlCommand\";\nimport { PushPopType } from \"./PushPop\";\nimport { Divert } from \"./Divert\";\nimport { ChoicePoint } from \"./ChoicePoint\";\nimport { VariableReference } from \"./VariableReference\";\nimport { VariableAssignment } from \"./VariableAssignment\";\nimport { NativeFunctionCall } from \"./NativeFunctionCall\";\nimport { Void } from \"./Void\";\nimport { Tag } from \"./Tag\";\nimport { Path } from \"./Path\";\nimport { Choice } from \"./Choice\";\nimport { ListDefinition } from \"./ListDefinition\";\nimport { ListDefinitionsOrigin } from \"./ListDefinitionsOrigin\";\nimport { InkListItem, InkList } from \"./InkList\";\nimport { InkObject } from \"./Object\";\nimport { asOrNull } from \"./TypeAssertion\";\nimport { throwNullException } from \"./NullException\";\nimport { SimpleJson } from \"./SimpleJson\";\n\nexport class JsonSerialisation {\n  public static JArrayToRuntimeObjList(\n    jArray: any[],\n    skipLast: boolean = false\n  ) {\n    let count = jArray.length;\n    if (skipLast) count--;\n\n    let list: InkObject[] = [];\n\n    for (let i = 0; i < count; i++) {\n      let jTok = jArray[i];\n      let runtimeObj = this.JTokenToRuntimeObject(jTok);\n      if (runtimeObj === null) {\n        return throwNullException(\"runtimeObj\");\n      }\n      list.push(runtimeObj);\n    }\n\n    return list;\n  }\n\n  public static WriteDictionaryRuntimeObjs(\n    writer: SimpleJson.Writer,\n    dictionary: Map<string, InkObject>\n  ) {\n    writer.WriteObjectStart();\n    for (let [key, value] of dictionary) {\n      writer.WritePropertyStart(key);\n      this.WriteRuntimeObject(writer, value);\n      writer.WritePropertyEnd();\n    }\n    writer.WriteObjectEnd();\n  }\n\n  public static WriteListRuntimeObjs(\n    writer: SimpleJson.Writer,\n    list: InkObject[]\n  ) {\n    writer.WriteArrayStart();\n    for (let value of list) {\n      this.WriteRuntimeObject(writer, value);\n    }\n    writer.WriteArrayEnd();\n  }\n\n  public static WriteIntDictionary(\n    writer: SimpleJson.Writer,\n    dict: Map<string, number>\n  ) {\n    writer.WriteObjectStart();\n    for (let [key, value] of dict) {\n      writer.WriteIntProperty(key, value);\n    }\n    writer.WriteObjectEnd();\n  }\n\n  public static WriteRuntimeObject(\n    writer: SimpleJson.Writer,\n    obj: InkObject\n  ): void {\n    let container = asOrNull(obj, Container);\n    if (container) {\n      this.WriteRuntimeContainer(writer, container);\n      return;\n    }\n\n    let divert = asOrNull(obj, Divert);\n    if (divert) {\n      let divTypeKey = \"->\";\n      if (divert.isExternal) {\n        divTypeKey = \"x()\";\n      } else if (divert.pushesToStack) {\n        if (divert.stackPushType == PushPopType.Function) {\n          divTypeKey = \"f()\";\n        } else if (divert.stackPushType == PushPopType.Tunnel) {\n          divTypeKey = \"->t->\";\n        }\n      }\n\n      let targetStr;\n      if (divert.hasVariableTarget) {\n        targetStr = divert.variableDivertName;\n      } else {\n        targetStr = divert.targetPathString;\n      }\n\n      writer.WriteObjectStart();\n      writer.WriteProperty(divTypeKey, targetStr);\n\n      if (divert.hasVariableTarget) {\n        writer.WriteProperty(\"var\", true);\n      }\n\n      if (divert.isConditional) {\n        writer.WriteProperty(\"c\", true);\n      }\n\n      if (divert.externalArgs > 0) {\n        writer.WriteIntProperty(\"exArgs\", divert.externalArgs);\n      }\n\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let choicePoint = asOrNull(obj, ChoicePoint);\n    if (choicePoint) {\n      writer.WriteObjectStart();\n      writer.WriteProperty(\"*\", choicePoint.pathStringOnChoice);\n      writer.WriteIntProperty(\"flg\", choicePoint.flags);\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let boolVal = asOrNull(obj, BoolValue);\n    if (boolVal) {\n      writer.WriteBool(boolVal.value);\n      return;\n    }\n\n    let intVal = asOrNull(obj, IntValue);\n    if (intVal) {\n      writer.WriteInt(intVal.value);\n      return;\n    }\n\n    let floatVal = asOrNull(obj, FloatValue);\n    if (floatVal) {\n      writer.WriteFloat(floatVal.value);\n      return;\n    }\n\n    let strVal = asOrNull(obj, StringValue);\n    if (strVal) {\n      if (strVal.isNewline) {\n        writer.Write(\"\\n\", false);\n      } else {\n        writer.WriteStringStart();\n        writer.WriteStringInner(\"^\");\n        writer.WriteStringInner(strVal.value);\n        writer.WriteStringEnd();\n      }\n      return;\n    }\n\n    let listVal = asOrNull(obj, ListValue);\n    if (listVal) {\n      this.WriteInkList(writer, listVal);\n      return;\n    }\n\n    let divTargetVal = asOrNull(obj, DivertTargetValue);\n    if (divTargetVal) {\n      writer.WriteObjectStart();\n      if (divTargetVal.value === null) {\n        return throwNullException(\"divTargetVal.value\");\n      }\n      writer.WriteProperty(\"^->\", divTargetVal.value.componentsString);\n      writer.WriteObjectEnd();\n\n      return;\n    }\n\n    let varPtrVal = asOrNull(obj, VariablePointerValue);\n    if (varPtrVal) {\n      writer.WriteObjectStart();\n      writer.WriteProperty(\"^var\", varPtrVal.value);\n      writer.WriteIntProperty(\"ci\", varPtrVal.contextIndex);\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let glue = asOrNull(obj, Glue);\n    if (glue) {\n      writer.Write(\"<>\");\n      return;\n    }\n\n    let controlCmd = asOrNull(obj, ControlCommand);\n    if (controlCmd) {\n      writer.Write(\n        JsonSerialisation._controlCommandNames[controlCmd.commandType]\n      );\n      return;\n    }\n\n    let nativeFunc = asOrNull(obj, NativeFunctionCall);\n    if (nativeFunc) {\n      let name = nativeFunc.name;\n\n      if (name == \"^\") name = \"L^\";\n\n      writer.Write(name);\n      return;\n    }\n\n    let varRef = asOrNull(obj, VariableReference);\n    if (varRef) {\n      writer.WriteObjectStart();\n      let readCountPath = varRef.pathStringForCount;\n      if (readCountPath != null) {\n        writer.WriteProperty(\"CNT?\", readCountPath);\n      } else {\n        writer.WriteProperty(\"VAR?\", varRef.name);\n      }\n\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let varAss = asOrNull(obj, VariableAssignment);\n    if (varAss) {\n      writer.WriteObjectStart();\n\n      let key = varAss.isGlobal ? \"VAR=\" : \"temp=\";\n      writer.WriteProperty(key, varAss.variableName);\n\n      // Reassignment?\n      if (!varAss.isNewDeclaration) writer.WriteProperty(\"re\", true);\n\n      writer.WriteObjectEnd();\n\n      return;\n    }\n\n    let voidObj = asOrNull(obj, Void);\n    if (voidObj) {\n      writer.Write(\"void\");\n      return;\n    }\n\n    let tag = asOrNull(obj, Tag);\n    if (tag) {\n      writer.WriteObjectStart();\n      writer.WriteProperty(\"#\", tag.text);\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let choice = asOrNull(obj, Choice);\n    if (choice) {\n      this.WriteChoice(writer, choice);\n      return;\n    }\n\n    throw new Error(\"Failed to convert runtime object to Json token: \" + obj);\n  }\n\n  public static JObjectToDictionaryRuntimeObjs(jObject: Record<string, any>) {\n    let dict: Map<string, InkObject> = new Map();\n\n    for (let key in jObject) {\n      if (jObject.hasOwnProperty(key)) {\n        let inkObject = this.JTokenToRuntimeObject(jObject[key]);\n        if (inkObject === null) {\n          return throwNullException(\"inkObject\");\n        }\n        dict.set(key, inkObject);\n      }\n    }\n\n    return dict;\n  }\n\n  public static JObjectToIntDictionary(jObject: Record<string, any>) {\n    let dict: Map<string, number> = new Map();\n    for (let key in jObject) {\n      if (jObject.hasOwnProperty(key)) {\n        dict.set(key, parseInt(jObject[key]));\n      }\n    }\n    return dict;\n  }\n\n  public static JTokenToRuntimeObject(token: any): InkObject | null {\n    if (\n      (typeof token === \"number\" && !isNaN(token)) ||\n      typeof token === \"boolean\"\n    ) {\n      return Value.Create(token);\n    }\n\n    if (typeof token === \"string\") {\n      let str = token.toString();\n\n      // String value\n      let firstChar = str[0];\n      if (firstChar == \"^\") return new StringValue(str.substring(1));\n      else if (firstChar == \"\\n\" && str.length == 1)\n        return new StringValue(\"\\n\");\n\n      // Glue\n      if (str == \"<>\") return new Glue();\n\n      // Control commands (would looking up in a hash set be faster?)\n      for (let i = 0; i < JsonSerialisation._controlCommandNames.length; ++i) {\n        let cmdName = JsonSerialisation._controlCommandNames[i];\n        if (str == cmdName) {\n          return new ControlCommand(i);\n        }\n      }\n\n      // Native functions\n      if (str == \"L^\") str = \"^\";\n      if (NativeFunctionCall.CallExistsWithName(str))\n        return NativeFunctionCall.CallWithName(str);\n\n      // Pop\n      if (str == \"->->\") return ControlCommand.PopTunnel();\n      else if (str == \"~ret\") return ControlCommand.PopFunction();\n\n      // Void\n      if (str == \"void\") return new Void();\n    }\n\n    if (typeof token === \"object\" && !Array.isArray(token)) {\n      let obj = token as Record<string, any>;\n      let propValue;\n\n      // Divert target value to path\n      if (obj[\"^->\"]) {\n        propValue = obj[\"^->\"];\n        return new DivertTargetValue(new Path(propValue.toString()));\n      }\n\n      // VariablePointerValue\n      if (obj[\"^var\"]) {\n        propValue = obj[\"^var\"];\n        let varPtr = new VariablePointerValue(propValue.toString());\n        if (\"ci\" in obj) {\n          propValue = obj[\"ci\"];\n          varPtr.contextIndex = parseInt(propValue);\n        }\n        return varPtr;\n      }\n\n      // Divert\n      let isDivert = false;\n      let pushesToStack = false;\n      let divPushType = PushPopType.Function;\n      let external = false;\n      if ((propValue = obj[\"->\"])) {\n        isDivert = true;\n      } else if ((propValue = obj[\"f()\"])) {\n        isDivert = true;\n        pushesToStack = true;\n        divPushType = PushPopType.Function;\n      } else if ((propValue = obj[\"->t->\"])) {\n        isDivert = true;\n        pushesToStack = true;\n        divPushType = PushPopType.Tunnel;\n      } else if ((propValue = obj[\"x()\"])) {\n        isDivert = true;\n        external = true;\n        pushesToStack = false;\n        divPushType = PushPopType.Function;\n      }\n\n      if (isDivert) {\n        let divert = new Divert();\n        divert.pushesToStack = pushesToStack;\n        divert.stackPushType = divPushType;\n        divert.isExternal = external;\n\n        let target = propValue.toString();\n\n        if ((propValue = obj[\"var\"])) divert.variableDivertName = target;\n        else divert.targetPathString = target;\n\n        divert.isConditional = !!obj[\"c\"];\n\n        if (external) {\n          if ((propValue = obj[\"exArgs\"]))\n            divert.externalArgs = parseInt(propValue);\n        }\n\n        return divert;\n      }\n\n      // Choice\n      if ((propValue = obj[\"*\"])) {\n        let choice = new ChoicePoint();\n        choice.pathStringOnChoice = propValue.toString();\n\n        if ((propValue = obj[\"flg\"])) choice.flags = parseInt(propValue);\n\n        return choice;\n      }\n\n      // Variable reference\n      if ((propValue = obj[\"VAR?\"])) {\n        return new VariableReference(propValue.toString());\n      } else if ((propValue = obj[\"CNT?\"])) {\n        let readCountVarRef = new VariableReference();\n        readCountVarRef.pathStringForCount = propValue.toString();\n        return readCountVarRef;\n      }\n\n      // Variable assignment\n      let isVarAss = false;\n      let isGlobalVar = false;\n      if ((propValue = obj[\"VAR=\"])) {\n        isVarAss = true;\n        isGlobalVar = true;\n      } else if ((propValue = obj[\"temp=\"])) {\n        isVarAss = true;\n        isGlobalVar = false;\n      }\n      if (isVarAss) {\n        let varName = propValue.toString();\n        let isNewDecl = !obj[\"re\"];\n        let varAss = new VariableAssignment(varName, isNewDecl);\n        varAss.isGlobal = isGlobalVar;\n        return varAss;\n      }\n      if (obj[\"#\"] !== undefined) {\n        propValue = obj[\"#\"];\n        return new Tag(propValue.toString());\n      }\n\n      // List value\n      if ((propValue = obj[\"list\"])) {\n        // var listContent = (Dictionary<string, object>)propValue;\n        let listContent = propValue as Record<string, any>;\n        let rawList = new InkList();\n        if ((propValue = obj[\"origins\"])) {\n          // var namesAsObjs = (List<object>)propValue;\n          let namesAsObjs = propValue as string[];\n          // rawList.SetInitialOriginNames(namesAsObjs.Cast<string>().ToList());\n          rawList.SetInitialOriginNames(namesAsObjs);\n        }\n\n        for (let key in listContent) {\n          if (listContent.hasOwnProperty(key)) {\n            let nameToVal = listContent[key];\n            let item = new InkListItem(key);\n            let val = parseInt(nameToVal);\n            rawList.Add(item, val);\n          }\n        }\n\n        return new ListValue(rawList);\n      }\n\n      if (obj[\"originalChoicePath\"] != null) return this.JObjectToChoice(obj);\n    }\n\n    // Array is always a Runtime.Container\n    if (Array.isArray(token)) {\n      return this.JArrayToContainer(token);\n    }\n\n    if (token === null || token === undefined) return null;\n\n    throw new Error(\n      \"Failed to convert token to runtime object: \" +\n        this.toJson(token, [\"parent\"])\n    );\n  }\n\n  public static toJson<T>(\n    me: T,\n    removes?: (keyof T)[],\n    space?: number\n  ): string {\n    return JSON.stringify(\n      me,\n      (k, v) => (removes?.some((r) => r === k) ? undefined : v),\n      space\n    );\n  }\n\n  public static WriteRuntimeContainer(\n    writer: SimpleJson.Writer,\n    container: Container | null,\n    withoutName: boolean = false\n  ) {\n    writer.WriteArrayStart();\n    if (container === null) {\n      return throwNullException(\"container\");\n    }\n    for (let c of container.content) this.WriteRuntimeObject(writer, c);\n\n    let namedOnlyContent = container.namedOnlyContent;\n    let countFlags = container.countFlags;\n    let hasNameProperty = container.name != null && !withoutName;\n\n    let hasTerminator =\n      namedOnlyContent != null || countFlags > 0 || hasNameProperty;\n    if (hasTerminator) {\n      writer.WriteObjectStart();\n    }\n\n    if (namedOnlyContent != null) {\n      for (let [key, value] of namedOnlyContent) {\n        let name = key;\n        let namedContainer = asOrNull(value, Container);\n        writer.WritePropertyStart(name);\n        this.WriteRuntimeContainer(writer, namedContainer, true);\n        writer.WritePropertyEnd();\n      }\n    }\n\n    if (countFlags > 0) writer.WriteIntProperty(\"#f\", countFlags);\n\n    if (hasNameProperty) writer.WriteProperty(\"#n\", container.name);\n\n    if (hasTerminator) writer.WriteObjectEnd();\n    else writer.WriteNull();\n\n    writer.WriteArrayEnd();\n  }\n\n  public static JArrayToContainer(jArray: any[]) {\n    let container = new Container();\n    container.content = this.JArrayToRuntimeObjList(jArray, true);\n\n    let terminatingObj = jArray[jArray.length - 1] as Record<string, any>;\n    if (terminatingObj != null) {\n      let namedOnlyContent = new Map();\n\n      for (let key in terminatingObj) {\n        if (key == \"#f\") {\n          container.countFlags = parseInt(terminatingObj[key]);\n        } else if (key == \"#n\") {\n          container.name = terminatingObj[key].toString();\n        } else {\n          let namedContentItem = this.JTokenToRuntimeObject(\n            terminatingObj[key]\n          );\n          // var namedSubContainer = namedContentItem as Container;\n          let namedSubContainer = asOrNull(namedContentItem, Container);\n          if (namedSubContainer) namedSubContainer.name = key;\n          namedOnlyContent.set(key, namedContentItem);\n        }\n      }\n\n      container.namedOnlyContent = namedOnlyContent;\n    }\n\n    return container;\n  }\n\n  public static JObjectToChoice(jObj: Record<string, any>) {\n    let choice = new Choice();\n    choice.text = jObj[\"text\"].toString();\n    choice.index = parseInt(jObj[\"index\"]);\n    choice.sourcePath = jObj[\"originalChoicePath\"].toString();\n    choice.originalThreadIndex = parseInt(jObj[\"originalThreadIndex\"]);\n    choice.pathStringOnChoice = jObj[\"targetPath\"].toString();\n    return choice;\n  }\n\n  public static WriteChoice(writer: SimpleJson.Writer, choice: Choice) {\n    writer.WriteObjectStart();\n    writer.WriteProperty(\"text\", choice.text);\n    writer.WriteIntProperty(\"index\", choice.index);\n    writer.WriteProperty(\"originalChoicePath\", choice.sourcePath);\n    writer.WriteIntProperty(\"originalThreadIndex\", choice.originalThreadIndex);\n    writer.WriteProperty(\"targetPath\", choice.pathStringOnChoice);\n    writer.WriteObjectEnd();\n  }\n\n  public static WriteInkList(writer: SimpleJson.Writer, listVal: ListValue) {\n    let rawList = listVal.value;\n    if (rawList === null) {\n      return throwNullException(\"rawList\");\n    }\n\n    writer.WriteObjectStart();\n    writer.WritePropertyStart(\"list\");\n    writer.WriteObjectStart();\n\n    for (let [key, val] of rawList) {\n      let item = InkListItem.fromSerializedKey(key);\n      let itemVal = val;\n\n      if (item.itemName === null) {\n        return throwNullException(\"item.itemName\");\n      }\n\n      writer.WritePropertyNameStart();\n      writer.WritePropertyNameInner(item.originName ? item.originName : \"?\");\n      writer.WritePropertyNameInner(\".\");\n      writer.WritePropertyNameInner(item.itemName);\n      writer.WritePropertyNameEnd();\n\n      writer.Write(itemVal);\n\n      writer.WritePropertyEnd();\n    }\n\n    writer.WriteObjectEnd();\n\n    writer.WritePropertyEnd();\n\n    if (\n      rawList.Count == 0 &&\n      rawList.originNames != null &&\n      rawList.originNames.length > 0\n    ) {\n      writer.WritePropertyStart(\"origins\");\n      writer.WriteArrayStart();\n      for (let name of rawList.originNames) writer.Write(name);\n      writer.WriteArrayEnd();\n      writer.WritePropertyEnd();\n    }\n\n    writer.WriteObjectEnd();\n  }\n\n  public static ListDefinitionsToJToken(origin: ListDefinitionsOrigin) {\n    let result: Record<string, any> = {};\n\n    for (let def of origin.lists) {\n      let listDefJson: Record<string, any> = {};\n\n      for (let [key, val] of def.items) {\n        let item = InkListItem.fromSerializedKey(key);\n        if (item.itemName === null) {\n          return throwNullException(\"item.itemName\");\n        }\n        listDefJson[item.itemName] = val;\n      }\n\n      result[def.name] = listDefJson;\n    }\n\n    return result;\n  }\n\n  public static JTokenToListDefinitions(obj: Record<string, any>) {\n    // var defsObj = (Dictionary<string, object>)obj;\n    let defsObj = obj;\n\n    let allDefs: ListDefinition[] = [];\n\n    for (let key in defsObj) {\n      if (defsObj.hasOwnProperty(key)) {\n        let name = key.toString();\n        // var listDefJson = (Dictionary<string, object>)kv.Value;\n        let listDefJson = defsObj[key] as Record<string, any>;\n\n        // Cast (string, object) to (string, int) for items\n        let items: Map<string, number> = new Map();\n\n        for (let nameValueKey in listDefJson) {\n          if (defsObj.hasOwnProperty(key)) {\n            let nameValue = listDefJson[nameValueKey];\n            items.set(nameValueKey, parseInt(nameValue));\n          }\n        }\n\n        let def = new ListDefinition(name, items);\n        allDefs.push(def);\n      }\n    }\n\n    return new ListDefinitionsOrigin(allDefs);\n  }\n\n  private static _controlCommandNames = (() => {\n    let _controlCommandNames: string[] = [];\n\n    _controlCommandNames[ControlCommand.CommandType.EvalStart] = \"ev\";\n    _controlCommandNames[ControlCommand.CommandType.EvalOutput] = \"out\";\n    _controlCommandNames[ControlCommand.CommandType.EvalEnd] = \"/ev\";\n    _controlCommandNames[ControlCommand.CommandType.Duplicate] = \"du\";\n    _controlCommandNames[ControlCommand.CommandType.PopEvaluatedValue] = \"pop\";\n    _controlCommandNames[ControlCommand.CommandType.PopFunction] = \"~ret\";\n    _controlCommandNames[ControlCommand.CommandType.PopTunnel] = \"->->\";\n    _controlCommandNames[ControlCommand.CommandType.BeginString] = \"str\";\n    _controlCommandNames[ControlCommand.CommandType.EndString] = \"/str\";\n    _controlCommandNames[ControlCommand.CommandType.NoOp] = \"nop\";\n    _controlCommandNames[ControlCommand.CommandType.ChoiceCount] = \"choiceCnt\";\n    _controlCommandNames[ControlCommand.CommandType.Turns] = \"turn\";\n    _controlCommandNames[ControlCommand.CommandType.TurnsSince] = \"turns\";\n    _controlCommandNames[ControlCommand.CommandType.ReadCount] = \"readc\";\n    _controlCommandNames[ControlCommand.CommandType.Random] = \"rnd\";\n    _controlCommandNames[ControlCommand.CommandType.SeedRandom] = \"srnd\";\n    _controlCommandNames[ControlCommand.CommandType.VisitIndex] = \"visit\";\n    _controlCommandNames[ControlCommand.CommandType.SequenceShuffleIndex] =\n      \"seq\";\n    _controlCommandNames[ControlCommand.CommandType.StartThread] = \"thread\";\n    _controlCommandNames[ControlCommand.CommandType.Done] = \"done\";\n    _controlCommandNames[ControlCommand.CommandType.End] = \"end\";\n    _controlCommandNames[ControlCommand.CommandType.ListFromInt] = \"listInt\";\n    _controlCommandNames[ControlCommand.CommandType.ListRange] = \"range\";\n    _controlCommandNames[ControlCommand.CommandType.ListRandom] = \"lrnd\";\n\n    for (let i = 0; i < ControlCommand.CommandType.TOTAL_VALUES; ++i) {\n      if (_controlCommandNames[i] == null)\n        throw new Error(\"Control command not accounted for in serialisation\");\n    }\n\n    return _controlCommandNames;\n  })();\n}\n","import { PushPopType } from \"./PushPop\";\nimport { Path } from \"./Path\";\nimport { Story } from \"./Story\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { ListValue } from \"./Value\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { Pointer } from \"./Pointer\";\nimport { InkObject } from \"./Object\";\nimport { Debug } from \"./Debug\";\nimport { tryGetValueFromMap } from \"./TryGetResult\";\nimport { throwNullException } from \"./NullException\";\nimport { SimpleJson } from \"./SimpleJson\";\n\nexport class CallStack {\n  get elements() {\n    return this.callStack;\n  }\n\n  get depth() {\n    return this.elements.length;\n  }\n\n  get currentElement() {\n    let thread = this._threads[this._threads.length - 1];\n    let cs = thread.callstack;\n    return cs[cs.length - 1];\n  }\n\n  get currentElementIndex() {\n    return this.callStack.length - 1;\n  }\n\n  get currentThread(): CallStack.Thread {\n    return this._threads[this._threads.length - 1];\n  }\n  set currentThread(value: CallStack.Thread) {\n    Debug.Assert(\n      this._threads.length == 1,\n      \"Shouldn't be directly setting the current thread when we have a stack of them\"\n    );\n\n    this._threads.length = 0;\n    this._threads.push(value);\n  }\n\n  get canPop() {\n    return this.callStack.length > 1;\n  }\n\n  constructor(storyContext: Story);\n  constructor(toCopy: CallStack);\n  constructor() {\n    if (arguments[0] instanceof Story) {\n      let storyContext = arguments[0] as Story;\n\n      this._startOfRoot = Pointer.StartOf(storyContext.rootContentContainer);\n      this.Reset();\n    } else {\n      let toCopy = arguments[0] as CallStack;\n\n      this._threads = [];\n      for (let otherThread of toCopy._threads) {\n        this._threads.push(otherThread.Copy());\n      }\n      this._threadCounter = toCopy._threadCounter;\n      this._startOfRoot = toCopy._startOfRoot.copy();\n    }\n  }\n\n  public Reset() {\n    this._threads = [];\n    this._threads.push(new CallStack.Thread());\n\n    this._threads[0].callstack.push(\n      new CallStack.Element(PushPopType.Tunnel, this._startOfRoot)\n    );\n  }\n\n  public SetJsonToken(jObject: Record<string, any>, storyContext: Story) {\n    this._threads.length = 0;\n\n    // TODO: (List<object>) jObject [\"threads\"];\n    let jThreads: any[] = jObject[\"threads\"];\n\n    for (let jThreadTok of jThreads) {\n      // TODO: var jThreadObj = (Dictionary<string, object>)jThreadTok;\n      let jThreadObj = jThreadTok;\n      let thread = new CallStack.Thread(jThreadObj, storyContext);\n      this._threads.push(thread);\n    }\n\n    // TODO: (int)jObject [\"threadCounter\"];\n    this._threadCounter = parseInt(jObject[\"threadCounter\"]);\n    this._startOfRoot = Pointer.StartOf(storyContext.rootContentContainer);\n  }\n  public WriteJson(w: SimpleJson.Writer) {\n    w.WriteObject((writer) => {\n      writer.WritePropertyStart(\"threads\");\n      writer.WriteArrayStart();\n\n      for (let thread of this._threads) {\n        thread.WriteJson(writer);\n      }\n\n      writer.WriteArrayEnd();\n      writer.WritePropertyEnd();\n\n      writer.WritePropertyStart(\"threadCounter\");\n      writer.WriteInt(this._threadCounter);\n      writer.WritePropertyEnd();\n    });\n  }\n\n  public PushThread() {\n    let newThread = this.currentThread.Copy();\n    this._threadCounter++;\n    newThread.threadIndex = this._threadCounter;\n    this._threads.push(newThread);\n  }\n\n  public ForkThread() {\n    let forkedThread = this.currentThread.Copy();\n    this._threadCounter++;\n    forkedThread.threadIndex = this._threadCounter;\n    return forkedThread;\n  }\n\n  public PopThread() {\n    if (this.canPopThread) {\n      this._threads.splice(this._threads.indexOf(this.currentThread), 1); // should be equivalent to a pop()\n    } else {\n      throw new Error(\"Can't pop thread\");\n    }\n  }\n\n  get canPopThread() {\n    return this._threads.length > 1 && !this.elementIsEvaluateFromGame;\n  }\n\n  get elementIsEvaluateFromGame() {\n    return this.currentElement.type == PushPopType.FunctionEvaluationFromGame;\n  }\n\n  public Push(\n    type: PushPopType,\n    externalEvaluationStackHeight: number = 0,\n    outputStreamLengthWithPushed: number = 0\n  ) {\n    let element = new CallStack.Element(\n      type,\n      this.currentElement.currentPointer,\n      false\n    );\n\n    element.evaluationStackHeightWhenPushed = externalEvaluationStackHeight;\n    element.functionStartInOutputStream = outputStreamLengthWithPushed;\n\n    this.callStack.push(element);\n  }\n\n  public CanPop(type: PushPopType | null = null) {\n    if (!this.canPop) return false;\n\n    if (type == null) return true;\n\n    return this.currentElement.type == type;\n  }\n\n  public Pop(type: PushPopType | null = null) {\n    if (this.CanPop(type)) {\n      this.callStack.pop();\n      return;\n    } else {\n      throw new Error(\"Mismatched push/pop in Callstack\");\n    }\n  }\n\n  public GetTemporaryVariableWithName(\n    name: string | null,\n    contextIndex: number = -1\n  ) {\n    if (contextIndex == -1) contextIndex = this.currentElementIndex + 1;\n\n    let contextElement = this.callStack[contextIndex - 1];\n\n    let varValue = tryGetValueFromMap(\n      contextElement.temporaryVariables,\n      name,\n      null\n    );\n    if (varValue.exists) {\n      return varValue.result;\n    } else {\n      return null;\n    }\n  }\n\n  public SetTemporaryVariable(\n    name: string,\n    value: any,\n    declareNew: boolean,\n    contextIndex: number = -1\n  ) {\n    if (contextIndex == -1) contextIndex = this.currentElementIndex + 1;\n\n    let contextElement = this.callStack[contextIndex - 1];\n\n    if (!declareNew && !contextElement.temporaryVariables.get(name)) {\n      throw new Error(\"Could not find temporary variable to set: \" + name);\n    }\n\n    let oldValue = tryGetValueFromMap(\n      contextElement.temporaryVariables,\n      name,\n      null\n    );\n    if (oldValue.exists)\n      ListValue.RetainListOriginsForAssignment(oldValue.result, value);\n\n    contextElement.temporaryVariables.set(name, value);\n  }\n\n  public ContextForVariableNamed(name: string) {\n    if (this.currentElement.temporaryVariables.get(name)) {\n      return this.currentElementIndex + 1;\n    } else {\n      return 0;\n    }\n  }\n\n  public ThreadWithIndex(index: number) {\n    let filtered = this._threads.filter((t) => {\n      if (t.threadIndex == index) return t;\n    });\n\n    return filtered.length > 0 ? filtered[0] : null;\n  }\n\n  get callStack() {\n    return this.currentThread.callstack;\n  }\n\n  get callStackTrace() {\n    let sb = new StringBuilder();\n\n    for (let t = 0; t < this._threads.length; t++) {\n      let thread = this._threads[t];\n      let isCurrent = t == this._threads.length - 1;\n      sb.AppendFormat(\n        \"=== THREAD {0}/{1} {2}===\\n\",\n        t + 1,\n        this._threads.length,\n        isCurrent ? \"(current) \" : \"\"\n      );\n\n      for (let i = 0; i < thread.callstack.length; i++) {\n        if (thread.callstack[i].type == PushPopType.Function)\n          sb.Append(\"  [FUNCTION] \");\n        else sb.Append(\"  [TUNNEL] \");\n\n        let pointer = thread.callstack[i].currentPointer;\n        if (!pointer.isNull) {\n          sb.Append(\"<SOMEWHERE IN \");\n          if (pointer.container === null) {\n            return throwNullException(\"pointer.container\");\n          }\n          sb.Append(pointer.container.path.toString());\n          sb.AppendLine(\">\");\n        }\n      }\n    }\n\n    return sb.toString();\n  }\n\n  public _threads!: CallStack.Thread[]; // Banged because it's initialized in Reset().\n  public _threadCounter: number = 0;\n  public _startOfRoot: Pointer = Pointer.Null;\n}\n\nexport namespace CallStack {\n  export class Element {\n    public currentPointer: Pointer;\n    public inExpressionEvaluation: boolean;\n    public temporaryVariables: Map<string, InkObject>;\n    public type: PushPopType;\n\n    public evaluationStackHeightWhenPushed: number = 0;\n    public functionStartInOutputStream: number = 0;\n\n    constructor(\n      type: PushPopType,\n      pointer: Pointer,\n      inExpressionEvaluation: boolean = false\n    ) {\n      this.currentPointer = pointer.copy();\n      this.inExpressionEvaluation = inExpressionEvaluation;\n      this.temporaryVariables = new Map();\n      this.type = type;\n    }\n\n    public Copy() {\n      let copy = new Element(\n        this.type,\n        this.currentPointer,\n        this.inExpressionEvaluation\n      );\n      copy.temporaryVariables = new Map(this.temporaryVariables);\n      copy.evaluationStackHeightWhenPushed = this.evaluationStackHeightWhenPushed;\n      copy.functionStartInOutputStream = this.functionStartInOutputStream;\n      return copy;\n    }\n  }\n\n  export class Thread {\n    public callstack: Element[];\n    public threadIndex: number = 0;\n    public previousPointer: Pointer = Pointer.Null;\n\n    constructor();\n    constructor(jThreadObj: any, storyContext: Story);\n    constructor() {\n      this.callstack = [];\n\n      if (arguments[0] && arguments[1]) {\n        let jThreadObj = arguments[0];\n        let storyContext = arguments[1];\n\n        // TODO: (int) jThreadObj['threadIndex'] can raise;\n        this.threadIndex = parseInt(jThreadObj[\"threadIndex\"]);\n\n        let jThreadCallstack = jThreadObj[\"callstack\"];\n\n        for (let jElTok of jThreadCallstack) {\n          let jElementObj = jElTok;\n\n          // TODO: (int) jElementObj['type'] can raise;\n          let pushPopType: PushPopType = parseInt(jElementObj[\"type\"]);\n\n          let pointer = Pointer.Null;\n\n          let currentContainerPathStr: string;\n          // TODO: jElementObj.TryGetValue (\"cPath\", out currentContainerPathStrToken);\n          let currentContainerPathStrToken = jElementObj[\"cPath\"];\n          if (typeof currentContainerPathStrToken !== \"undefined\") {\n            currentContainerPathStr = currentContainerPathStrToken.toString();\n\n            let threadPointerResult = storyContext.ContentAtPath(\n              new Path(currentContainerPathStr)\n            );\n            pointer.container = threadPointerResult.container;\n            pointer.index = parseInt(jElementObj[\"idx\"]);\n\n            if (threadPointerResult.obj == null)\n              throw new Error(\n                \"When loading state, internal story location couldn't be found: \" +\n                  currentContainerPathStr +\n                  \". Has the story changed since this save data was created?\"\n              );\n            else if (threadPointerResult.approximate) {\n              if (pointer.container === null) {\n                return throwNullException(\"pointer.container\");\n              }\n              storyContext.Warning(\n                \"When loading state, exact internal story location couldn't be found: '\" +\n                  currentContainerPathStr +\n                  \"', so it was approximated to '\" +\n                  pointer.container.path.toString() +\n                  \"' to recover. Has the story changed since this save data was created?\"\n              );\n            }\n          }\n\n          let inExpressionEvaluation = !!jElementObj[\"exp\"];\n\n          let el = new Element(pushPopType, pointer, inExpressionEvaluation);\n\n          let temps = jElementObj[\"temp\"];\n          if (typeof temps !== \"undefined\") {\n            el.temporaryVariables = JsonSerialisation.JObjectToDictionaryRuntimeObjs(\n              temps\n            );\n          } else {\n            el.temporaryVariables.clear();\n          }\n\n          this.callstack.push(el);\n        }\n\n        let prevContentObjPath = jThreadObj[\"previousContentObject\"];\n        if (typeof prevContentObjPath !== \"undefined\") {\n          let prevPath = new Path(prevContentObjPath.toString());\n          this.previousPointer = storyContext.PointerAtPath(prevPath);\n        }\n      }\n    }\n\n    public Copy() {\n      let copy = new Thread();\n      copy.threadIndex = this.threadIndex;\n      for (let e of this.callstack) {\n        copy.callstack.push(e.Copy());\n      }\n      copy.previousPointer = this.previousPointer.copy();\n      return copy;\n    }\n\n    public WriteJson(writer: SimpleJson.Writer) {\n      writer.WriteObjectStart();\n\n      writer.WritePropertyStart(\"callstack\");\n      writer.WriteArrayStart();\n      for (let el of this.callstack) {\n        writer.WriteObjectStart();\n        if (!el.currentPointer.isNull) {\n          if (el.currentPointer.container === null) {\n            return throwNullException(\"el.currentPointer.container\");\n          }\n          writer.WriteProperty(\n            \"cPath\",\n            el.currentPointer.container.path.componentsString\n          );\n          writer.WriteIntProperty(\"idx\", el.currentPointer.index);\n        }\n\n        writer.WriteProperty(\"exp\", el.inExpressionEvaluation);\n        writer.WriteIntProperty(\"type\", el.type);\n\n        if (el.temporaryVariables.size > 0) {\n          writer.WritePropertyStart(\"temp\");\n          JsonSerialisation.WriteDictionaryRuntimeObjs(\n            writer,\n            el.temporaryVariables\n          );\n          writer.WritePropertyEnd();\n        }\n\n        writer.WriteObjectEnd();\n      }\n      writer.WriteArrayEnd();\n      writer.WritePropertyEnd();\n\n      writer.WriteIntProperty(\"threadIndex\", this.threadIndex);\n\n      if (!this.previousPointer.isNull) {\n        let resolvedPointer = this.previousPointer.Resolve();\n        if (resolvedPointer === null) {\n          return throwNullException(\"this.previousPointer.Resolve()\");\n        }\n        writer.WriteProperty(\n          \"previousContentObject\",\n          resolvedPointer.path.toString()\n        );\n      }\n\n      writer.WriteObjectEnd();\n    }\n  }\n}\n","import {\n  AbstractValue,\n  Value,\n  VariablePointerValue,\n  ListValue,\n  IntValue,\n  FloatValue,\n  BoolValue,\n} from \"./Value\";\nimport { VariableAssignment } from \"./VariableAssignment\";\nimport { InkObject } from \"./Object\";\nimport { ListDefinitionsOrigin } from \"./ListDefinitionsOrigin\";\nimport { StoryException } from \"./StoryException\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { asOrThrows, asOrNull, isEquatable } from \"./TypeAssertion\";\nimport { tryGetValueFromMap } from \"./TryGetResult\";\nimport { throwNullException } from \"./NullException\";\nimport { CallStack } from \"./CallStack\";\nimport { StatePatch } from \"./StatePatch\";\nimport { SimpleJson } from \"./SimpleJson\";\n\nexport class VariablesState {\n  // The way variableChangedEvent is a bit different than the reference implementation.\n  // Originally it uses the C# += operator to add delegates, but in js we need to maintain\n  // an actual collection of delegates (ie. callbacks) to register a new one, there is a\n  // special ObserveVariableChange method below.\n  public variableChangedEventCallbacks: Array<\n    (variableName: string, newValue: InkObject) => void\n  > = [];\n  public variableChangedEvent(variableName: string, newValue: InkObject): void {\n    for (let callback of this.variableChangedEventCallbacks) {\n      callback(variableName, newValue);\n    }\n  }\n\n  public patch: StatePatch | null = null;\n\n  get batchObservingVariableChanges() {\n    return this._batchObservingVariableChanges;\n  }\n  set batchObservingVariableChanges(value: boolean) {\n    this._batchObservingVariableChanges = value;\n    if (value) {\n      this._changedVariablesForBatchObs = new Set();\n    } else {\n      if (this._changedVariablesForBatchObs != null) {\n        for (let variableName of this._changedVariablesForBatchObs) {\n          let currentValue = this._globalVariables.get(variableName);\n          if (!currentValue) {\n            throwNullException(\"currentValue\");\n          } else {\n            this.variableChangedEvent(variableName, currentValue);\n          }\n        }\n\n        this._changedVariablesForBatchObs = null;\n      }\n    }\n  }\n\n  get callStack() {\n    return this._callStack;\n  }\n  set callStack(callStack) {\n    this._callStack = callStack;\n  }\n\n  private _batchObservingVariableChanges: boolean = false;\n\n  // the original code uses a magic getter and setter for global variables,\n  // allowing things like variableState['varname]. This is not quite possible\n  // in js without a Proxy, so it is replaced with this $ function.\n  public $(variableName: string, value: any) {\n    if (typeof value === \"undefined\") {\n      let varContents = null;\n\n      if (this.patch !== null) {\n        varContents = this.patch.TryGetGlobal(variableName, null);\n        if (varContents.exists)\n          return (varContents.result as AbstractValue).valueObject;\n      }\n\n      varContents = this._globalVariables.get(variableName);\n\n      if (typeof varContents === \"undefined\") {\n        varContents = this._defaultGlobalVariables.get(variableName);\n      }\n\n      if (typeof varContents !== \"undefined\")\n        return (varContents as AbstractValue).valueObject;\n      else return null;\n    } else {\n      if (typeof this._defaultGlobalVariables.get(variableName) === \"undefined\")\n        throw new StoryException(\n          \"Cannot assign to a variable (\" +\n            variableName +\n            \") that hasn't been declared in the story\"\n        );\n\n      let val = Value.Create(value);\n      if (val == null) {\n        if (value == null) {\n          throw new Error(\"Cannot pass null to VariableState\");\n        } else {\n          throw new Error(\n            \"Invalid value passed to VariableState: \" + value.toString()\n          );\n        }\n      }\n\n      this.SetGlobal(variableName, val);\n    }\n  }\n\n  constructor(\n    callStack: CallStack,\n    listDefsOrigin: ListDefinitionsOrigin | null\n  ) {\n    this._globalVariables = new Map();\n    this._callStack = callStack;\n    this._listDefsOrigin = listDefsOrigin;\n\n    // if es6 proxies are available, use them.\n    try {\n      // the proxy is used to allow direct manipulation of global variables.\n      // It first tries to access the objects own property, and if none is\n      // found it delegates the call to the $ method, defined below\n      let p = new Proxy(this, {\n        get(target: any, name) {\n          return name in target ? target[name] : target.$(name);\n        },\n        set(target: any, name, value) {\n          if (name in target) target[name] = value;\n          else target.$(name, value);\n          return true; // returning a falsy value make the trap fail\n        },\n      });\n\n      return p;\n    } catch (e) {\n      // thr proxy object is not available in this context. we should warn the\n      // dev but writting to the console feels a bit intrusive.\n      // console.log(\"ES6 Proxy not available - direct manipulation of global variables can't work, use $() instead.\");\n    }\n  }\n\n  public ApplyPatch() {\n    if (this.patch === null) {\n      return throwNullException(\"this.patch\");\n    }\n\n    for (let [namedVarKey, namedVarValue] of this.patch.globals) {\n      this._globalVariables.set(namedVarKey, namedVarValue);\n    }\n\n    if (this._changedVariablesForBatchObs !== null) {\n      for (let name of this.patch.changedVariables) {\n        this._changedVariablesForBatchObs.add(name);\n      }\n    }\n\n    this.patch = null;\n  }\n\n  public SetJsonToken(jToken: Record<string, any>) {\n    this._globalVariables.clear();\n\n    for (let [varValKey, varValValue] of this._defaultGlobalVariables) {\n      let loadedToken = jToken[varValKey];\n      if (typeof loadedToken !== \"undefined\") {\n        let tokenInkObject = JsonSerialisation.JTokenToRuntimeObject(\n          loadedToken\n        );\n        if (tokenInkObject === null) {\n          return throwNullException(\"tokenInkObject\");\n        }\n        this._globalVariables.set(varValKey, tokenInkObject);\n      } else {\n        this._globalVariables.set(varValKey, varValValue);\n      }\n    }\n  }\n\n  public static dontSaveDefaultValues: boolean = true;\n\n  public WriteJson(writer: SimpleJson.Writer) {\n    writer.WriteObjectStart();\n    for (let [keyValKey, keyValValue] of this._globalVariables) {\n      let name = keyValKey;\n      let val = keyValValue;\n\n      if (VariablesState.dontSaveDefaultValues) {\n        if (this._defaultGlobalVariables.has(name)) {\n          let defaultVal = this._defaultGlobalVariables.get(name)!;\n          if (this.RuntimeObjectsEqual(val, defaultVal)) continue;\n        }\n      }\n\n      writer.WritePropertyStart(name);\n      JsonSerialisation.WriteRuntimeObject(writer, val);\n      writer.WritePropertyEnd();\n    }\n    writer.WriteObjectEnd();\n  }\n\n  public RuntimeObjectsEqual(\n    obj1: InkObject | null,\n    obj2: InkObject | null\n  ): boolean {\n    if (obj1 === null) {\n      return throwNullException(\"obj1\");\n    }\n    if (obj2 === null) {\n      return throwNullException(\"obj2\");\n    }\n\n    if (obj1.constructor !== obj2.constructor) return false;\n\n    let boolVal = asOrNull(obj1, BoolValue);\n    if (boolVal !== null) {\n      return boolVal.value === asOrThrows(obj2, BoolValue).value;\n    }\n\n    let intVal = asOrNull(obj1, IntValue);\n    if (intVal !== null) {\n      return intVal.value === asOrThrows(obj2, IntValue).value;\n    }\n\n    let floatVal = asOrNull(obj1, FloatValue);\n    if (floatVal !== null) {\n      return floatVal.value === asOrThrows(obj2, FloatValue).value;\n    }\n\n    let val1 = asOrNull(obj1, Value);\n    let val2 = asOrNull(obj2, Value);\n    if (val1 !== null && val2 !== null) {\n      if (isEquatable(val1.valueObject) && isEquatable(val2.valueObject)) {\n        return val1.valueObject.Equals(val2.valueObject);\n      } else {\n        return val1.valueObject === val2.valueObject;\n      }\n    }\n\n    throw new Error(\n      \"FastRoughDefinitelyEquals: Unsupported runtime object type: \" +\n        obj1.constructor.name\n    );\n  }\n\n  public GetVariableWithName(\n    name: string | null,\n    contextIndex: number = -1\n  ): InkObject | null {\n    let varValue = this.GetRawVariableWithName(name, contextIndex);\n\n    // var varPointer = varValue as VariablePointerValue;\n    let varPointer = asOrNull(varValue, VariablePointerValue);\n    if (varPointer !== null) {\n      varValue = this.ValueAtVariablePointer(varPointer);\n    }\n\n    return varValue;\n  }\n\n  public TryGetDefaultVariableValue(name: string | null): InkObject | null {\n    let val = tryGetValueFromMap(this._defaultGlobalVariables, name, null);\n    return val.exists ? val.result : null;\n  }\n\n  public GlobalVariableExistsWithName(name: string) {\n    return (\n      this._globalVariables.has(name) ||\n      (this._defaultGlobalVariables !== null &&\n        this._defaultGlobalVariables.has(name))\n    );\n  }\n\n  public GetRawVariableWithName(name: string | null, contextIndex: number) {\n    let varValue: InkObject | null = null;\n\n    if (contextIndex == 0 || contextIndex == -1) {\n      let variableValue = null;\n      if (this.patch !== null) {\n        variableValue = this.patch.TryGetGlobal(name, null);\n        if (variableValue.exists) return variableValue.result!;\n      }\n\n      // this is a conditional assignment\n      variableValue = tryGetValueFromMap(this._globalVariables, name, null);\n      if (variableValue.exists) return variableValue.result;\n\n      if (this._defaultGlobalVariables !== null) {\n        variableValue = tryGetValueFromMap(\n          this._defaultGlobalVariables,\n          name,\n          null\n        );\n        if (variableValue.exists) return variableValue.result;\n      }\n\n      if (this._listDefsOrigin === null)\n        return throwNullException(\"VariablesState._listDefsOrigin\");\n      let listItemValue = this._listDefsOrigin.FindSingleItemListWithName(name);\n      if (listItemValue) return listItemValue;\n    }\n\n    varValue = this._callStack.GetTemporaryVariableWithName(name, contextIndex);\n\n    return varValue;\n  }\n\n  public ValueAtVariablePointer(pointer: VariablePointerValue) {\n    return this.GetVariableWithName(pointer.variableName, pointer.contextIndex);\n  }\n\n  public Assign(varAss: VariableAssignment, value: InkObject) {\n    let name = varAss.variableName;\n    if (name === null) {\n      return throwNullException(\"name\");\n    }\n    let contextIndex = -1;\n\n    let setGlobal = false;\n    if (varAss.isNewDeclaration) {\n      setGlobal = varAss.isGlobal;\n    } else {\n      setGlobal = this.GlobalVariableExistsWithName(name);\n    }\n\n    if (varAss.isNewDeclaration) {\n      // var varPointer = value as VariablePointerValue;\n      let varPointer = asOrNull(value, VariablePointerValue);\n      if (varPointer !== null) {\n        let fullyResolvedVariablePointer = this.ResolveVariablePointer(\n          varPointer\n        );\n        value = fullyResolvedVariablePointer;\n      }\n    } else {\n      let existingPointer = null;\n      do {\n        // existingPointer = GetRawVariableWithName (name, contextIndex) as VariablePointerValue;\n        existingPointer = asOrNull(\n          this.GetRawVariableWithName(name, contextIndex),\n          VariablePointerValue\n        );\n        if (existingPointer != null) {\n          name = existingPointer.variableName;\n          contextIndex = existingPointer.contextIndex;\n          setGlobal = contextIndex == 0;\n        }\n      } while (existingPointer != null);\n    }\n\n    if (setGlobal) {\n      this.SetGlobal(name, value);\n    } else {\n      this._callStack.SetTemporaryVariable(\n        name,\n        value,\n        varAss.isNewDeclaration,\n        contextIndex\n      );\n    }\n  }\n\n  public SnapshotDefaultGlobals() {\n    this._defaultGlobalVariables = new Map(this._globalVariables);\n  }\n\n  public RetainListOriginsForAssignment(\n    oldValue: InkObject,\n    newValue: InkObject\n  ) {\n    let oldList = asOrThrows(oldValue, ListValue);\n    let newList = asOrThrows(newValue, ListValue);\n\n    if (oldList.value && newList.value && newList.value.Count == 0) {\n      newList.value.SetInitialOriginNames(oldList.value.originNames);\n    }\n  }\n\n  public SetGlobal(variableName: string | null, value: InkObject) {\n    let oldValue = null;\n\n    if (this.patch === null) {\n      oldValue = tryGetValueFromMap(this._globalVariables, variableName, null);\n    }\n\n    if (this.patch !== null) {\n      oldValue = this.patch.TryGetGlobal(variableName, null);\n      if (!oldValue.exists) {\n        oldValue = tryGetValueFromMap(\n          this._globalVariables,\n          variableName,\n          null\n        );\n      }\n    }\n\n    ListValue.RetainListOriginsForAssignment(oldValue!.result!, value);\n\n    if (variableName === null) {\n      return throwNullException(\"variableName\");\n    }\n\n    if (this.patch !== null) {\n      this.patch.SetGlobal(variableName, value);\n    } else {\n      this._globalVariables.set(variableName, value);\n    }\n\n    // TODO: Not sure !== is equivalent to !value.Equals(oldValue)\n    if (\n      this.variableChangedEvent !== null &&\n      oldValue !== null &&\n      value !== oldValue.result\n    ) {\n      if (this.batchObservingVariableChanges) {\n        if (this._changedVariablesForBatchObs === null) {\n          return throwNullException(\"this._changedVariablesForBatchObs\");\n        }\n\n        if (this.patch !== null) {\n          this.patch.AddChangedVariable(variableName);\n        } else if (this._changedVariablesForBatchObs !== null) {\n          this._changedVariablesForBatchObs.add(variableName);\n        }\n      } else {\n        this.variableChangedEvent(variableName, value);\n      }\n    }\n  }\n\n  public ResolveVariablePointer(varPointer: VariablePointerValue) {\n    let contextIndex = varPointer.contextIndex;\n\n    if (contextIndex == -1)\n      contextIndex = this.GetContextIndexOfVariableNamed(\n        varPointer.variableName\n      );\n\n    let valueOfVariablePointedTo = this.GetRawVariableWithName(\n      varPointer.variableName,\n      contextIndex\n    );\n\n    // var doubleRedirectionPointer = valueOfVariablePointedTo as VariablePointerValue;\n    let doubleRedirectionPointer = asOrNull(\n      valueOfVariablePointedTo,\n      VariablePointerValue\n    );\n    if (doubleRedirectionPointer != null) {\n      return doubleRedirectionPointer;\n    } else {\n      return new VariablePointerValue(varPointer.variableName, contextIndex);\n    }\n  }\n\n  public GetContextIndexOfVariableNamed(varName: string) {\n    if (this.GlobalVariableExistsWithName(varName)) return 0;\n\n    return this._callStack.currentElementIndex;\n  }\n\n  /**\n   * This function is specific to the js version of ink. It allows to register a\n   * callback that will be called when a variable changes. The original code uses\n   * `state.variableChangedEvent += callback` instead.\n   *\n   * @param {function} callback\n   */\n  public ObserveVariableChange(\n    callback: (variableName: string, newValue: InkObject) => void\n  ) {\n    this.variableChangedEventCallbacks.push(callback);\n  }\n\n  private _globalVariables: Map<string, InkObject>;\n  private _defaultGlobalVariables: Map<string, InkObject> = new Map();\n\n  private _callStack: CallStack;\n  private _changedVariablesForBatchObs: Set<string> | null = new Set();\n  private _listDefsOrigin: ListDefinitionsOrigin | null;\n}\n","// Taken from https://gist.github.com/blixt/f17b47c62508be59987b\n// Ink uses a seedable PRNG of which there is none in native javascript.\nexport class PRNG {\n  private seed: number;\n\n  constructor(seed: number) {\n    this.seed = seed % 2147483647;\n    if (this.seed <= 0) this.seed += 2147483646;\n  }\n  public next(): number {\n    return (this.seed = (this.seed * 16807) % 2147483647);\n  }\n  public nextFloat(): number {\n    return (this.next() - 1) / 2147483646;\n  }\n}\n","import { InkObject } from \"./Object\";\nimport { Container } from \"./Container\";\n\nexport class StatePatch {\n  get globals() {\n    return this._globals;\n  }\n  get changedVariables() {\n    return this._changedVariables;\n  }\n  get visitCounts() {\n    return this._visitCounts;\n  }\n  get turnIndices() {\n    return this._turnIndices;\n  }\n\n  constructor();\n  constructor(toCopy: StatePatch | null);\n  constructor() {\n    if (arguments.length === 1 && arguments[0] !== null) {\n      let toCopy = arguments[0] as StatePatch;\n      this._globals = new Map(toCopy._globals);\n      this._changedVariables = new Set(toCopy._changedVariables);\n      this._visitCounts = new Map(toCopy._visitCounts);\n      this._turnIndices = new Map(toCopy._turnIndices);\n    } else {\n      this._globals = new Map();\n      this._changedVariables = new Set();\n      this._visitCounts = new Map();\n      this._turnIndices = new Map();\n    }\n  }\n\n  public TryGetGlobal(name: string | null, /* out */ value: InkObject | null) {\n    if (name !== null && this._globals.has(name)) {\n      return { result: this._globals.get(name), exists: true };\n    }\n\n    return { result: value, exists: false };\n  }\n\n  public SetGlobal(name: string, value: InkObject) {\n    this._globals.set(name, value);\n  }\n\n  public AddChangedVariable(name: string) {\n    return this._changedVariables.add(name);\n  }\n\n  public TryGetVisitCount(container: Container, /* out */ count: number) {\n    if (this._visitCounts.has(container)) {\n      return { result: this._visitCounts.get(container), exists: true };\n    }\n\n    return { result: count, exists: false };\n  }\n\n  public SetVisitCount(container: Container, count: number) {\n    this._visitCounts.set(container, count);\n  }\n\n  public SetTurnIndex(container: Container, index: number) {\n    this._turnIndices.set(container, index);\n  }\n\n  public TryGetTurnIndex(container: Container, /* out */ index: number) {\n    if (this._turnIndices.has(container)) {\n      return { result: this._turnIndices.get(container), exists: true };\n    }\n\n    return { result: index, exists: false };\n  }\n\n  private _globals: Map<string, InkObject>;\n  private _changedVariables: Set<string> = new Set();\n  private _visitCounts: Map<Container, number> = new Map();\n  private _turnIndices: Map<Container, number> = new Map();\n}\n","export class SimpleJson {\n  public static TextToDictionary(text: string) {\n    return new SimpleJson.Reader(text).ToDictionary();\n  }\n\n  public static TextToArray(text: string) {\n    return new SimpleJson.Reader(text).ToArray();\n  }\n}\n\nexport namespace SimpleJson {\n  export class Reader {\n    constructor(text: string) {\n      this._rootObject = JSON.parse(text);\n    }\n\n    public ToDictionary() {\n      return this._rootObject as Record<string, any>;\n    }\n\n    public ToArray() {\n      return this._rootObject as any[];\n    }\n\n    private _rootObject: any[] | Record<string, any>;\n  }\n\n  // In C#, this class writes json tokens directly to a StringWriter or\n  // another stream. Here, a temporary hierarchy is created in the form\n  // of a javascript object, which is serialised in the `toString` method.\n  // See individual methods and properties for more information.\n  export class Writer {\n    public WriteObject(inner: (w: Writer) => void) {\n      this.WriteObjectStart();\n      inner(this);\n      this.WriteObjectEnd();\n    }\n\n    // Add a new object.\n    public WriteObjectStart() {\n      this.StartNewObject(true);\n\n      let newObject: Record<string, any> = {};\n\n      if (this.state === SimpleJson.Writer.State.Property) {\n        // This object is created as the value of a property,\n        // inside an other object.\n        this.Assert(this.currentCollection !== null);\n        this.Assert(this.currentPropertyName !== null);\n\n        let propertyName = this._propertyNameStack.pop();\n        this.currentCollection![propertyName!] = newObject;\n        this._collectionStack.push(newObject);\n      } else if (this.state === SimpleJson.Writer.State.Array) {\n        // This object is created as the child of an array.\n        this.Assert(this.currentCollection !== null);\n\n        this.currentCollection!.push(newObject);\n        this._collectionStack.push(newObject);\n      } else {\n        // This object is the root object.\n        this.Assert(this.state === SimpleJson.Writer.State.None);\n        this._jsonObject = newObject;\n        this._collectionStack.push(newObject);\n      }\n\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Object)\n      );\n    }\n\n    public WriteObjectEnd() {\n      this.Assert(this.state === SimpleJson.Writer.State.Object);\n      this._collectionStack.pop();\n      this._stateStack.pop();\n    }\n\n    // Write a property name / value pair to the current object.\n    public WriteProperty(\n      name: any,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      innerOrContent: ((w: Writer) => void) | string | boolean | null\n    ) {\n      this.WritePropertyStart(name);\n      if (arguments[1] instanceof Function) {\n        let inner = arguments[1];\n        inner(this);\n      } else {\n        let content: string | boolean | null = arguments[1];\n        this.Write(content);\n      }\n      this.WritePropertyEnd();\n    }\n\n    // Int and Float are separate calls, since there both are\n    // numbers in JavaScript, but need to be handled differently.\n\n    public WriteIntProperty(name: any, content: number) {\n      this.WritePropertyStart(name);\n      this.WriteInt(content);\n      this.WritePropertyEnd();\n    }\n\n    public WriteFloatProperty(name: any, content: number) {\n      this.WritePropertyStart(name);\n      this.WriteFloat(content);\n      this.WritePropertyEnd();\n    }\n\n    // Prepare a new property name, which will be use to add the\n    // new object when calling _addToCurrentObject() from a Write\n    // method.\n    public WritePropertyStart(name: any) {\n      this.Assert(this.state === SimpleJson.Writer.State.Object);\n      this._propertyNameStack.push(name);\n\n      this.IncrementChildCount();\n\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Property)\n      );\n    }\n\n    public WritePropertyEnd() {\n      this.Assert(this.state === SimpleJson.Writer.State.Property);\n      this.Assert(this.childCount === 1);\n      this._stateStack.pop();\n    }\n\n    // Prepare a new property name, except this time, the property name\n    // will be created by concatenating all the strings passed to\n    // WritePropertyNameInner.\n    public WritePropertyNameStart() {\n      this.Assert(this.state === SimpleJson.Writer.State.Object);\n      this.IncrementChildCount();\n\n      this._currentPropertyName = \"\";\n\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Property)\n      );\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.PropertyName)\n      );\n    }\n\n    public WritePropertyNameEnd() {\n      this.Assert(this.state === SimpleJson.Writer.State.PropertyName);\n      this.Assert(this._currentPropertyName !== null);\n      this._propertyNameStack.push(this._currentPropertyName!);\n      this._currentPropertyName = null;\n      this._stateStack.pop();\n    }\n\n    public WritePropertyNameInner(str: string) {\n      this.Assert(this.state === SimpleJson.Writer.State.PropertyName);\n      this.Assert(this._currentPropertyName !== null);\n      this._currentPropertyName += str;\n    }\n\n    // Add a new array.\n    public WriteArrayStart() {\n      this.StartNewObject(true);\n\n      let newObject: any[] = [];\n\n      if (this.state === SimpleJson.Writer.State.Property) {\n        // This array is created as the value of a property,\n        // inside an object.\n        this.Assert(this.currentCollection !== null);\n        this.Assert(this.currentPropertyName !== null);\n\n        let propertyName = this._propertyNameStack.pop();\n        this.currentCollection![propertyName!] = newObject;\n        this._collectionStack.push(newObject);\n      } else if (this.state === SimpleJson.Writer.State.Array) {\n        // This array is created as the child of another array.\n        this.Assert(this.currentCollection !== null);\n\n        this.currentCollection!.push(newObject);\n        this._collectionStack.push(newObject);\n      } else {\n        // This array is the root object.\n        this.Assert(this.state === SimpleJson.Writer.State.None);\n        this._jsonObject = newObject;\n        this._collectionStack.push(newObject);\n      }\n\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Array)\n      );\n    }\n\n    public WriteArrayEnd() {\n      this.Assert(this.state === SimpleJson.Writer.State.Array);\n      this._collectionStack.pop();\n      this._stateStack.pop();\n    }\n\n    // Add the value to the appropriate collection (array / object), given the current\n    // context.\n    public Write(\n      value: number | string | boolean | null,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      escape: boolean = true\n    ) {\n      if (value === null) {\n        console.error(\"Warning: trying to write a null value\");\n        return;\n      }\n\n      this.StartNewObject(false);\n      this._addToCurrentObject(value);\n    }\n\n    public WriteBool(value: boolean | null) {\n      if (value === null) {\n        return;\n      }\n\n      this.StartNewObject(false);\n      this._addToCurrentObject(value);\n    }\n\n    public WriteInt(value: number | null) {\n      if (value === null) {\n        return;\n      }\n\n      this.StartNewObject(false);\n\n      // Math.floor is used as a precaution:\n      //     1. to ensure that the value is written as an integer\n      //        (without a fractional part -> 1 instead of 1.0), even\n      //        though it should be the default behaviour of\n      //        JSON.serialize;\n      //     2. to ensure that if a floating number is passed\n      //        accidentally, it's converted to an integer.\n      //\n      // This guarantees savegame compatibility with the reference\n      // implementation.\n      this._addToCurrentObject(Math.floor(value));\n    }\n\n    // Since JSON doesn't support NaN and Infinity, these values\n    // are converted here.\n    public WriteFloat(value: number | null) {\n      if (value === null) {\n        return;\n      }\n\n      this.StartNewObject(false);\n      if (value == Number.POSITIVE_INFINITY) {\n        this._addToCurrentObject(3.4e38);\n      } else if (value == Number.NEGATIVE_INFINITY) {\n        this._addToCurrentObject(-3.4e38);\n      } else if (isNaN(value)) {\n        this._addToCurrentObject(0.0);\n      } else {\n        this._addToCurrentObject(value);\n      }\n    }\n\n    public WriteNull() {\n      this.StartNewObject(false);\n      this._addToCurrentObject(null);\n    }\n\n    // Prepare a string before adding it to the current collection in\n    // WriteStringEnd(). The string will be a concatenation of all the\n    // strings passed to WriteStringInner.\n    public WriteStringStart() {\n      this.StartNewObject(false);\n      this._currentString = \"\";\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.String)\n      );\n    }\n\n    public WriteStringEnd() {\n      this.Assert(this.state == SimpleJson.Writer.State.String);\n      this._stateStack.pop();\n      this._addToCurrentObject(this._currentString);\n      this._currentString = null;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    public WriteStringInner(str: string | null, escape: boolean = true) {\n      this.Assert(this.state === SimpleJson.Writer.State.String);\n\n      if (str === null) {\n        console.error(\"Warning: trying to write a null string\");\n        return;\n      }\n\n      this._currentString += str;\n    }\n\n    // Serialise the root object into a JSON string.\n    public toString() {\n      if (this._jsonObject === null) {\n        return \"\";\n      }\n\n      return JSON.stringify(this._jsonObject);\n    }\n\n    // Prepare the state stack when adding new objects / values.\n    private StartNewObject(container: boolean) {\n      if (container) {\n        this.Assert(\n          this.state === SimpleJson.Writer.State.None ||\n            this.state === SimpleJson.Writer.State.Property ||\n            this.state === SimpleJson.Writer.State.Array\n        );\n      } else {\n        this.Assert(\n          this.state === SimpleJson.Writer.State.Property ||\n            this.state === SimpleJson.Writer.State.Array\n        );\n      }\n\n      if (this.state === SimpleJson.Writer.State.Property) {\n        this.Assert(this.childCount === 0);\n      }\n\n      if (\n        this.state === SimpleJson.Writer.State.Array ||\n        this.state === SimpleJson.Writer.State.Property\n      ) {\n        this.IncrementChildCount();\n      }\n    }\n\n    // These getters peek all the different stacks.\n\n    private get state() {\n      if (this._stateStack.length > 0) {\n        return this._stateStack[this._stateStack.length - 1].type;\n      } else {\n        return SimpleJson.Writer.State.None;\n      }\n    }\n\n    private get childCount() {\n      if (this._stateStack.length > 0) {\n        return this._stateStack[this._stateStack.length - 1].childCount;\n      } else {\n        return 0;\n      }\n    }\n\n    private get currentCollection() {\n      if (this._collectionStack.length > 0) {\n        return this._collectionStack[this._collectionStack.length - 1];\n      } else {\n        return null;\n      }\n    }\n\n    private get currentPropertyName() {\n      if (this._propertyNameStack.length > 0) {\n        return this._propertyNameStack[this._propertyNameStack.length - 1];\n      } else {\n        return null;\n      }\n    }\n\n    private IncrementChildCount() {\n      this.Assert(this._stateStack.length > 0);\n      let currEl = this._stateStack.pop()!;\n      currEl.childCount++;\n      this._stateStack.push(currEl);\n    }\n\n    private Assert(condition: boolean) {\n      if (!condition) throw Error(\"Assert failed while writing JSON\");\n    }\n\n    // This method did not exist in the original C# code. It adds\n    // the given value to the current collection (used by Write methods).\n    private _addToCurrentObject(value: number | string | boolean | null) {\n      this.Assert(this.currentCollection !== null);\n      if (this.state === SimpleJson.Writer.State.Array) {\n        this.Assert(Array.isArray(this.currentCollection));\n        (this.currentCollection as any[]).push(value);\n      } else if (this.state === SimpleJson.Writer.State.Property) {\n        this.Assert(!Array.isArray(this.currentCollection));\n        this.Assert(this.currentPropertyName !== null);\n        (this.currentCollection as Record<string, any>)[\n          this.currentPropertyName!\n        ] = value;\n        this._propertyNameStack.pop();\n      }\n    }\n\n    // In addition to `_stateStack` present in the original code,\n    // this implementation of SimpleJson use two other stacks and two\n    // temporary variables holding the current context.\n\n    // Used to keep track of the current property name being built\n    // with `WritePropertyNameStart`, `WritePropertyNameInner` and\n    // `WritePropertyNameEnd`.\n    private _currentPropertyName: string | null = null;\n\n    // Used to keep track of the current string value being built\n    // with `WriteStringStart`, `WriteStringInner` and\n    // `WriteStringEnd`.\n    private _currentString: string | null = null;\n\n    private _stateStack: SimpleJson.Writer.StateElement[] = [];\n\n    // Keep track of the current collection being built (either an array\n    // or an object). For instance, at the '?' step during the hiarchy\n    // creation, this hierarchy:\n    // [3, {a: [b, ?]}] will have this corresponding stack:\n    // (bottom) [Array, Object, Array] (top)\n    private _collectionStack: Array<any[] | Record<string, any>> = [];\n\n    // Keep track of the current property being assigned. For instance, at\n    // the '?' step during the hiarchy creation, this hierarchy:\n    // [3, {a: [b, {c: ?}]}] will have this corresponding stack:\n    // (bottom) [a, c] (top)\n    private _propertyNameStack: string[] = [];\n\n    // Object containing the entire hiearchy.\n    private _jsonObject: Record<string, any> | any[] | null = null;\n  }\n\n  export namespace Writer {\n    export enum State {\n      None,\n      Object,\n      Array,\n      Property,\n      PropertyName,\n      String,\n    }\n\n    export class StateElement {\n      public type: SimpleJson.Writer.State = SimpleJson.Writer.State.None;\n      public childCount: number = 0;\n\n      constructor(type: SimpleJson.Writer.State) {\n        this.type = type;\n      }\n    }\n  }\n}\n","export type ErrorHandler = (message: string, type: ErrorType) => void;\n\nexport enum ErrorType {\n  Author,\n  Warning,\n  Error,\n}\n","import { CallStack } from \"./CallStack\";\nimport { Choice } from \"./Choice\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { InkObject } from \"./Object\";\nimport { SimpleJson } from \"./SimpleJson\";\nimport { Story } from \"./Story\";\nimport { throwNullException } from \"./NullException\";\n\nexport class Flow {\n  public name: string;\n  public callStack: CallStack;\n  public outputStream: InkObject[];\n  public currentChoices: Choice[];\n\n  constructor(name: String, story: Story);\n  constructor(name: String, story: Story, jObject: Record<string, any>);\n  constructor() {\n    let name = arguments[0] as string;\n    let story = arguments[1] as Story;\n\n    this.name = name;\n    this.callStack = new CallStack(story);\n\n    if (arguments[2]) {\n      let jObject = arguments[2] as Record<string, any>;\n\n      this.callStack.SetJsonToken(jObject[\"callstack\"], story);\n      this.outputStream = JsonSerialisation.JArrayToRuntimeObjList(\n        jObject[\"outputStream\"]\n      );\n      this.currentChoices = JsonSerialisation.JArrayToRuntimeObjList(\n        jObject[\"currentChoices\"]\n      ) as Choice[];\n\n      let jChoiceThreadsObj = jObject[\"choiceThreads\"];\n      if (typeof jChoiceThreadsObj !== \"undefined\") {\n        this.LoadFlowChoiceThreads(jChoiceThreadsObj, story);\n      }\n    } else {\n      this.outputStream = [];\n      this.currentChoices = [];\n    }\n  }\n\n  public WriteJson(writer: SimpleJson.Writer) {\n    writer.WriteObjectStart();\n\n    writer.WriteProperty(\"callstack\", (w) => this.callStack.WriteJson(w));\n    writer.WriteProperty(\"outputStream\", (w) =>\n      JsonSerialisation.WriteListRuntimeObjs(w, this.outputStream)\n    );\n\n    let hasChoiceThreads = false;\n    for (let c of this.currentChoices) {\n      if (c.threadAtGeneration === null)\n        return throwNullException(\"c.threadAtGeneration\");\n\n      c.originalThreadIndex = c.threadAtGeneration.threadIndex;\n\n      if (this.callStack.ThreadWithIndex(c.originalThreadIndex) === null) {\n        if (!hasChoiceThreads) {\n          hasChoiceThreads = true;\n          writer.WritePropertyStart(\"choiceThreads\");\n          writer.WriteObjectStart();\n        }\n\n        writer.WritePropertyStart(c.originalThreadIndex);\n        c.threadAtGeneration.WriteJson(writer);\n        writer.WritePropertyEnd();\n      }\n    }\n\n    if (hasChoiceThreads) {\n      writer.WriteObjectEnd();\n      writer.WritePropertyEnd();\n    }\n\n    writer.WriteProperty(\"currentChoices\", (w) => {\n      w.WriteArrayStart();\n      for (let c of this.currentChoices) {\n        JsonSerialisation.WriteChoice(w, c);\n      }\n      w.WriteArrayEnd();\n    });\n\n    writer.WriteObjectEnd();\n  }\n\n  public LoadFlowChoiceThreads(\n    jChoiceThreads: Record<string, any>,\n    story: Story\n  ) {\n    for (let choice of this.currentChoices) {\n      let foundActiveThread = this.callStack.ThreadWithIndex(\n        choice.originalThreadIndex\n      );\n      if (foundActiveThread !== null) {\n        choice.threadAtGeneration = foundActiveThread.Copy();\n      } else {\n        let jSavedChoiceThread =\n          jChoiceThreads[`${choice.originalThreadIndex}`];\n        choice.threadAtGeneration = new CallStack.Thread(\n          jSavedChoiceThread,\n          story\n        );\n      }\n    }\n  }\n}\n","import { CallStack } from \"./CallStack\";\nimport { VariablesState } from \"./VariablesState\";\nimport { ValueType, Value, StringValue, ListValue } from \"./Value\";\nimport { PushPopType } from \"./PushPop\";\nimport { Tag } from \"./Tag\";\nimport { Glue } from \"./Glue\";\nimport { Path } from \"./Path\";\nimport { ControlCommand } from \"./ControlCommand\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { PRNG } from \"./PRNG\";\nimport { Void } from \"./Void\";\nimport { Pointer } from \"./Pointer\";\nimport { tryGetValueFromMap } from \"./TryGetResult\";\nimport { Choice } from \"./Choice\";\nimport { asOrNull, asOrThrows, nullIfUndefined } from \"./TypeAssertion\";\nimport { Debug } from \"./Debug\";\nimport { Container } from \"./Container\";\nimport { InkObject } from \"./Object\";\nimport { throwNullException } from \"./NullException\";\nimport { Story } from \"./Story\";\nimport { StatePatch } from \"./StatePatch\";\nimport { SimpleJson } from \"./SimpleJson\";\nimport { Flow } from \"./Flow\";\nimport { InkList } from \"./InkList\";\n\nexport class StoryState {\n  public readonly kInkSaveStateVersion = 9;\n  public readonly kMinCompatibleLoadVersion = 8;\n\n  public onDidLoadState: (() => void) | null = null;\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  public ToJson(indented: boolean = false) {\n    let writer = new SimpleJson.Writer();\n    this.WriteJson(writer);\n    return writer.toString();\n  }\n  public toJson(indented: boolean = false) {\n    return this.ToJson(indented);\n  }\n\n  public LoadJson(json: string) {\n    let jObject = SimpleJson.TextToDictionary(json);\n    this.LoadJsonObj(jObject);\n    if (this.onDidLoadState !== null) this.onDidLoadState();\n  }\n\n  public VisitCountAtPathString(pathString: string) {\n    let visitCountOut;\n\n    if (this._patch !== null) {\n      let container = this.story.ContentAtPath(new Path(pathString)).container;\n      if (container === null)\n        throw new Error(\"Content at path not found: \" + pathString);\n\n      visitCountOut = this._patch.TryGetVisitCount(container, 0);\n      if (visitCountOut.exists) return visitCountOut.result;\n    }\n\n    visitCountOut = tryGetValueFromMap(this._visitCounts, pathString, null);\n    if (visitCountOut.exists) return visitCountOut.result;\n\n    return 0;\n  }\n\n  public VisitCountForContainer(container: Container | null): number {\n    if (container === null) {\n      return throwNullException(\"container\");\n    }\n    if (!container.visitsShouldBeCounted) {\n      this.story.Error(\n        \"Read count for target (\" +\n          container.name +\n          \" - on \" +\n          container.debugMetadata +\n          \") unknown. The story may need to be compiled with countAllVisits flag (-c).\"\n      );\n      return 0;\n    }\n\n    if (this._patch !== null) {\n      let count = this._patch.TryGetVisitCount(container, 0);\n      if (count.exists) {\n        return count.result!;\n      }\n    }\n\n    let containerPathStr = container.path.toString();\n    let count2 = tryGetValueFromMap(this._visitCounts, containerPathStr, null);\n    if (count2.exists) {\n      return count2.result!;\n    }\n\n    return 0;\n  }\n\n  public IncrementVisitCountForContainer(container: Container) {\n    if (this._patch !== null) {\n      let currCount = this.VisitCountForContainer(container);\n      currCount++;\n      this._patch.SetVisitCount(container, currCount);\n      return;\n    }\n\n    let containerPathStr = container.path.toString();\n    let count = tryGetValueFromMap(this._visitCounts, containerPathStr, null);\n    if (count.exists) {\n      this._visitCounts.set(containerPathStr, count.result! + 1);\n    } else {\n      this._visitCounts.set(containerPathStr, 1);\n    }\n  }\n\n  public RecordTurnIndexVisitToContainer(container: Container) {\n    if (this._patch !== null) {\n      this._patch.SetTurnIndex(container, this.currentTurnIndex);\n      return;\n    }\n\n    let containerPathStr = container.path.toString();\n    this._turnIndices.set(containerPathStr, this.currentTurnIndex);\n  }\n\n  public TurnsSinceForContainer(container: Container) {\n    if (!container.turnIndexShouldBeCounted) {\n      this.story.Error(\n        \"TURNS_SINCE() for target (\" +\n          container.name +\n          \" - on \" +\n          container.debugMetadata +\n          \") unknown. The story may need to be compiled with countAllVisits flag (-c).\"\n      );\n    }\n\n    if (this._patch !== null) {\n      let index = this._patch.TryGetTurnIndex(container, 0);\n      if (index.exists) {\n        return this.currentTurnIndex - index.result!;\n      }\n    }\n\n    let containerPathStr = container.path.toString();\n    let index2 = tryGetValueFromMap(this._turnIndices, containerPathStr, 0);\n    if (index2.exists) {\n      return this.currentTurnIndex - index2.result!;\n    } else {\n      return -1;\n    }\n  }\n\n  get callstackDepth() {\n    return this.callStack.depth;\n  }\n\n  get outputStream() {\n    return this._currentFlow.outputStream;\n  }\n\n  get currentChoices() {\n    // If we can continue generating text content rather than choices,\n    // then we reflect the choice list as being empty, since choices\n    // should always come at the end.\n    if (this.canContinue) return [];\n    return this._currentFlow.currentChoices;\n  }\n\n  get generatedChoices() {\n    return this._currentFlow.currentChoices;\n  }\n\n  get currentErrors() {\n    return this._currentErrors;\n  }\n  private _currentErrors: string[] | null = null;\n\n  get currentWarnings() {\n    return this._currentWarnings;\n  }\n  private _currentWarnings: string[] | null = null;\n\n  get variablesState() {\n    return this._variablesState;\n  }\n  set variablesState(value) {\n    this._variablesState = value;\n  }\n  private _variablesState: VariablesState;\n\n  get callStack() {\n    return this._currentFlow.callStack;\n  }\n\n  get evaluationStack() {\n    return this._evaluationStack;\n  }\n  private _evaluationStack: InkObject[];\n\n  public divertedPointer: Pointer = Pointer.Null;\n\n  get currentTurnIndex() {\n    return this._currentTurnIndex;\n  }\n  set currentTurnIndex(value) {\n    this._currentTurnIndex = value;\n  }\n  private _currentTurnIndex: number = 0;\n\n  public storySeed: number = 0;\n  public previousRandom: number = 0;\n  public didSafeExit: boolean = false;\n\n  public story: Story;\n\n  get currentPathString() {\n    let pointer = this.currentPointer;\n    if (pointer.isNull) {\n      return null;\n    } else {\n      if (pointer.path === null) {\n        return throwNullException(\"pointer.path\");\n      }\n      return pointer.path.toString();\n    }\n  }\n\n  get currentPointer() {\n    return this.callStack.currentElement.currentPointer.copy();\n  }\n\n  set currentPointer(value) {\n    this.callStack.currentElement.currentPointer = value.copy();\n  }\n\n  get previousPointer() {\n    return this.callStack.currentThread.previousPointer.copy();\n  }\n\n  set previousPointer(value) {\n    this.callStack.currentThread.previousPointer = value.copy();\n  }\n\n  get canContinue() {\n    return !this.currentPointer.isNull && !this.hasError;\n  }\n\n  get hasError() {\n    return this.currentErrors != null && this.currentErrors.length > 0;\n  }\n\n  get hasWarning() {\n    return this.currentWarnings != null && this.currentWarnings.length > 0;\n  }\n\n  get currentText() {\n    if (this._outputStreamTextDirty) {\n      let sb = new StringBuilder();\n\n      for (let outputObj of this.outputStream) {\n        // var textContent = outputObj as StringValue;\n        let textContent = asOrNull(outputObj, StringValue);\n        if (textContent !== null) {\n          sb.Append(textContent.value);\n        }\n      }\n\n      this._currentText = this.CleanOutputWhitespace(sb.toString());\n      this._outputStreamTextDirty = false;\n    }\n\n    return this._currentText;\n  }\n  private _currentText: string | null = null;\n\n  public CleanOutputWhitespace(str: string) {\n    let sb = new StringBuilder();\n\n    let currentWhitespaceStart = -1;\n    let startOfLine = 0;\n\n    for (let i = 0; i < str.length; i++) {\n      let c = str.charAt(i);\n\n      let isInlineWhitespace = c == \" \" || c == \"\\t\";\n\n      if (isInlineWhitespace && currentWhitespaceStart == -1)\n        currentWhitespaceStart = i;\n\n      if (!isInlineWhitespace) {\n        if (\n          c != \"\\n\" &&\n          currentWhitespaceStart > 0 &&\n          currentWhitespaceStart != startOfLine\n        ) {\n          sb.Append(\" \");\n        }\n        currentWhitespaceStart = -1;\n      }\n\n      if (c == \"\\n\") startOfLine = i + 1;\n\n      if (!isInlineWhitespace) sb.Append(c);\n    }\n\n    return sb.toString();\n  }\n\n  get currentTags() {\n    if (this._outputStreamTagsDirty) {\n      this._currentTags = [];\n\n      for (let outputObj of this.outputStream) {\n        // var tag = outputObj as Tag;\n        let tag = asOrNull(outputObj, Tag);\n        if (tag !== null) {\n          this._currentTags.push(tag.text);\n        }\n      }\n\n      this._outputStreamTagsDirty = false;\n    }\n\n    return this._currentTags;\n  }\n  private _currentTags: string[] | null = null;\n\n  get currentFlowName() {\n    return this._currentFlow.name;\n  }\n\n  get inExpressionEvaluation() {\n    return this.callStack.currentElement.inExpressionEvaluation;\n  }\n  set inExpressionEvaluation(value) {\n    this.callStack.currentElement.inExpressionEvaluation = value;\n  }\n\n  constructor(story: Story) {\n    this.story = story;\n\n    this._currentFlow = new Flow(this.kDefaultFlowName, story);\n    this.OutputStreamDirty();\n\n    this._evaluationStack = [];\n\n    this._variablesState = new VariablesState(\n      this.callStack,\n      story.listDefinitions\n    );\n\n    this._visitCounts = new Map();\n    this._turnIndices = new Map();\n    this.currentTurnIndex = -1;\n\n    let timeSeed = new Date().getTime();\n    this.storySeed = new PRNG(timeSeed).next() % 100;\n    this.previousRandom = 0;\n\n    this.GoToStart();\n  }\n\n  public GoToStart() {\n    this.callStack.currentElement.currentPointer = Pointer.StartOf(\n      this.story.mainContentContainer\n    );\n  }\n\n  public SwitchFlow_Internal(flowName: string | null) {\n    if (flowName === null)\n      throw new Error(\"Must pass a non-null string to Story.SwitchFlow\");\n\n    if (this._namedFlows === null) {\n      this._namedFlows = new Map();\n      this._namedFlows.set(this.kDefaultFlowName, this._currentFlow);\n    }\n\n    if (flowName === this._currentFlow.name) {\n      return;\n    }\n\n    let flow: Flow;\n    let content = tryGetValueFromMap(this._namedFlows, flowName, null);\n    if (content.exists) {\n      flow = content.result!;\n    } else {\n      flow = new Flow(flowName, this.story);\n      this._namedFlows.set(flowName, flow);\n    }\n\n    this._currentFlow = flow;\n    this.variablesState.callStack = this._currentFlow.callStack;\n\n    this.OutputStreamDirty();\n  }\n\n  public SwitchToDefaultFlow_Internal() {\n    if (this._namedFlows === null) return;\n    this.SwitchFlow_Internal(this.kDefaultFlowName);\n  }\n\n  public RemoveFlow_Internal(flowName: string | null) {\n    if (flowName === null)\n      throw new Error(\"Must pass a non-null string to Story.DestroyFlow\");\n    if (flowName === this.kDefaultFlowName)\n      throw new Error(\"Cannot destroy default flow\");\n\n    if (this._currentFlow.name === flowName) {\n      this.SwitchToDefaultFlow_Internal();\n    }\n\n    if (this._namedFlows === null)\n      return throwNullException(\"this._namedFlows\");\n    this._namedFlows.delete(flowName);\n  }\n\n  public CopyAndStartPatching() {\n    let copy = new StoryState(this.story);\n\n    copy._patch = new StatePatch(this._patch);\n\n    copy._currentFlow.name = this._currentFlow.name;\n    copy._currentFlow.callStack = new CallStack(this._currentFlow.callStack);\n    copy._currentFlow.currentChoices.push(...this._currentFlow.currentChoices);\n    copy._currentFlow.outputStream.push(...this._currentFlow.outputStream);\n    copy.OutputStreamDirty();\n\n    if (this._namedFlows !== null) {\n      copy._namedFlows = new Map();\n      for (let [namedFlowKey, namedFlowValue] of this._namedFlows) {\n        copy._namedFlows.set(namedFlowKey, namedFlowValue);\n      }\n      copy._namedFlows.set(this._currentFlow.name, copy._currentFlow);\n    }\n\n    if (this.hasError) {\n      copy._currentErrors = [];\n      copy._currentErrors.push(...(this.currentErrors || []));\n    }\n\n    if (this.hasWarning) {\n      copy._currentWarnings = [];\n      copy._currentWarnings.push(...(this.currentWarnings || []));\n    }\n\n    copy.variablesState = this.variablesState;\n    copy.variablesState.callStack = copy.callStack;\n    copy.variablesState.patch = copy._patch;\n\n    copy.evaluationStack.push(...this.evaluationStack);\n\n    if (!this.divertedPointer.isNull)\n      copy.divertedPointer = this.divertedPointer.copy();\n\n    copy.previousPointer = this.previousPointer.copy();\n\n    copy._visitCounts = this._visitCounts;\n    copy._turnIndices = this._turnIndices;\n\n    copy.currentTurnIndex = this.currentTurnIndex;\n    copy.storySeed = this.storySeed;\n    copy.previousRandom = this.previousRandom;\n\n    copy.didSafeExit = this.didSafeExit;\n\n    return copy;\n  }\n\n  public RestoreAfterPatch() {\n    this.variablesState.callStack = this.callStack;\n    this.variablesState.patch = this._patch;\n  }\n\n  public ApplyAnyPatch() {\n    if (this._patch === null) return;\n\n    this.variablesState.ApplyPatch();\n\n    for (let [key, value] of this._patch.visitCounts)\n      this.ApplyCountChanges(key, value, true);\n\n    for (let [key, value] of this._patch.turnIndices)\n      this.ApplyCountChanges(key, value, false);\n\n    this._patch = null;\n  }\n\n  public ApplyCountChanges(\n    container: Container,\n    newCount: number,\n    isVisit: boolean\n  ) {\n    let counts = isVisit ? this._visitCounts : this._turnIndices;\n    counts.set(container.path.toString(), newCount);\n  }\n\n  public WriteJson(writer: SimpleJson.Writer) {\n    writer.WriteObjectStart();\n\n    writer.WritePropertyStart(\"flows\");\n    writer.WriteObjectStart();\n\n    // NOTE: Never pass `WriteJson` directly as an argument to `WriteProperty`.\n    // Call it inside a function to make sure `this` is correctly bound\n    // and passed down the call hierarchy.\n\n    if (this._namedFlows !== null) {\n      for (let [namedFlowKey, namedFlowValue] of this._namedFlows) {\n        writer.WriteProperty(namedFlowKey, (w) => namedFlowValue.WriteJson(w));\n      }\n    } else {\n      writer.WriteProperty(this._currentFlow.name, (w) =>\n        this._currentFlow.WriteJson(w)\n      );\n    }\n\n    writer.WriteObjectEnd();\n    writer.WritePropertyEnd();\n\n    writer.WriteProperty(\"currentFlowName\", this._currentFlow.name);\n\n    writer.WriteProperty(\"variablesState\", (w) =>\n      this.variablesState.WriteJson(w)\n    );\n\n    writer.WriteProperty(\"evalStack\", (w) =>\n      JsonSerialisation.WriteListRuntimeObjs(w, this.evaluationStack)\n    );\n\n    if (!this.divertedPointer.isNull) {\n      if (this.divertedPointer.path === null) {\n        return throwNullException(\"divertedPointer\");\n      }\n      writer.WriteProperty(\n        \"currentDivertTarget\",\n        this.divertedPointer.path.componentsString\n      );\n    }\n\n    writer.WriteProperty(\"visitCounts\", (w) =>\n      JsonSerialisation.WriteIntDictionary(w, this._visitCounts)\n    );\n    writer.WriteProperty(\"turnIndices\", (w) =>\n      JsonSerialisation.WriteIntDictionary(w, this._turnIndices)\n    );\n\n    writer.WriteIntProperty(\"turnIdx\", this.currentTurnIndex);\n    writer.WriteIntProperty(\"storySeed\", this.storySeed);\n    writer.WriteIntProperty(\"previousRandom\", this.previousRandom);\n\n    writer.WriteIntProperty(\"inkSaveVersion\", this.kInkSaveStateVersion);\n\n    writer.WriteIntProperty(\"inkFormatVersion\", Story.inkVersionCurrent);\n\n    writer.WriteObjectEnd();\n  }\n\n  public LoadJsonObj(value: Record<string, any>) {\n    let jObject = value;\n\n    let jSaveVersion = jObject[\"inkSaveVersion\"];\n    if (jSaveVersion == null) {\n      throw new Error(\"ink save format incorrect, can't load.\");\n    } else if (parseInt(jSaveVersion) < this.kMinCompatibleLoadVersion) {\n      throw new Error(\n        \"Ink save format isn't compatible with the current version (saw '\" +\n          jSaveVersion +\n          \"', but minimum is \" +\n          this.kMinCompatibleLoadVersion +\n          \"), so can't load.\"\n      );\n    }\n\n    let flowsObj = jObject[\"flows\"];\n    if (flowsObj != null) {\n      let flowsObjDict = flowsObj as Record<string, any>;\n\n      // Single default flow\n      if (Object.keys(flowsObjDict).length === 1) {\n        this._namedFlows = null;\n      } else if (this._namedFlows === null) {\n        this._namedFlows = new Map();\n      } else {\n        this._namedFlows.clear();\n      }\n\n      let flowsObjDictEntries = Object.entries(flowsObjDict);\n      for (let [namedFlowObjKey, namedFlowObjValue] of flowsObjDictEntries) {\n        let name = namedFlowObjKey;\n        let flowObj = namedFlowObjValue as Record<string, any>;\n\n        let flow = new Flow(name, this.story, flowObj);\n\n        if (Object.keys(flowsObjDict).length === 1) {\n          this._currentFlow = new Flow(name, this.story, flowObj);\n        } else {\n          if (this._namedFlows === null)\n            return throwNullException(\"this._namedFlows\");\n          this._namedFlows.set(name, flow);\n        }\n      }\n\n      if (this._namedFlows != null && this._namedFlows.size > 1) {\n        let currFlowName = jObject[\"currentFlowName\"] as string;\n        // Adding a bang at the end, because we're trusting the save, as\n        // done in upstream.  If the save is corrupted, the execution\n        // is undefined.\n        this._currentFlow = this._namedFlows.get(currFlowName)!;\n      }\n    } else {\n      this._namedFlows = null;\n      this._currentFlow.name = this.kDefaultFlowName;\n      this._currentFlow.callStack.SetJsonToken(\n        jObject[\"callstackThreads\"] as Record<string, any>,\n        this.story\n      );\n      this._currentFlow.outputStream = JsonSerialisation.JArrayToRuntimeObjList(\n        jObject[\"outputStream\"] as any[]\n      );\n      this._currentFlow.currentChoices = JsonSerialisation.JArrayToRuntimeObjList(\n        jObject[\"currentChoices\"] as any[]\n      ) as Choice[];\n\n      let jChoiceThreadsObj = jObject[\"choiceThreads\"];\n      this._currentFlow.LoadFlowChoiceThreads(jChoiceThreadsObj, this.story);\n    }\n\n    this.OutputStreamDirty();\n\n    this.variablesState.SetJsonToken(jObject[\"variablesState\"]);\n    this.variablesState.callStack = this._currentFlow.callStack;\n\n    this._evaluationStack = JsonSerialisation.JArrayToRuntimeObjList(\n      jObject[\"evalStack\"]\n    );\n\n    let currentDivertTargetPath = jObject[\"currentDivertTarget\"];\n    if (currentDivertTargetPath != null) {\n      let divertPath = new Path(currentDivertTargetPath.toString());\n      this.divertedPointer = this.story.PointerAtPath(divertPath);\n    }\n\n    this._visitCounts = JsonSerialisation.JObjectToIntDictionary(\n      jObject[\"visitCounts\"]\n    );\n    this._turnIndices = JsonSerialisation.JObjectToIntDictionary(\n      jObject[\"turnIndices\"]\n    );\n    this.currentTurnIndex = parseInt(jObject[\"turnIdx\"]);\n    this.storySeed = parseInt(jObject[\"storySeed\"]);\n    this.previousRandom = parseInt(jObject[\"previousRandom\"]);\n  }\n\n  public ResetErrors() {\n    this._currentErrors = null;\n    this._currentWarnings = null;\n  }\n  public ResetOutput(objs: InkObject[] | null = null) {\n    this.outputStream.length = 0;\n    if (objs !== null) this.outputStream.push(...objs);\n    this.OutputStreamDirty();\n  }\n\n  public PushToOutputStream(obj: InkObject | null) {\n    // var text = obj as StringValue;\n    let text = asOrNull(obj, StringValue);\n    if (text !== null) {\n      let listText = this.TrySplittingHeadTailWhitespace(text);\n      if (listText !== null) {\n        for (let textObj of listText) {\n          this.PushToOutputStreamIndividual(textObj);\n        }\n        this.OutputStreamDirty();\n        return;\n      }\n    }\n\n    this.PushToOutputStreamIndividual(obj);\n    this.OutputStreamDirty();\n  }\n\n  public PopFromOutputStream(count: number) {\n    this.outputStream.splice(this.outputStream.length - count, count);\n    this.OutputStreamDirty();\n  }\n\n  public TrySplittingHeadTailWhitespace(single: StringValue) {\n    let str = single.value;\n    if (str === null) {\n      return throwNullException(\"single.value\");\n    }\n\n    let headFirstNewlineIdx = -1;\n    let headLastNewlineIdx = -1;\n    for (let i = 0; i < str.length; i++) {\n      let c = str[i];\n      if (c == \"\\n\") {\n        if (headFirstNewlineIdx == -1) headFirstNewlineIdx = i;\n        headLastNewlineIdx = i;\n      } else if (c == \" \" || c == \"\\t\") continue;\n      else break;\n    }\n\n    let tailLastNewlineIdx = -1;\n    let tailFirstNewlineIdx = -1;\n    for (let i = str.length - 1; i >= 0; i--) {\n      let c = str[i];\n      if (c == \"\\n\") {\n        if (tailLastNewlineIdx == -1) tailLastNewlineIdx = i;\n        tailFirstNewlineIdx = i;\n      } else if (c == \" \" || c == \"\\t\") continue;\n      else break;\n    }\n\n    // No splitting to be done?\n    if (headFirstNewlineIdx == -1 && tailLastNewlineIdx == -1) return null;\n\n    let listTexts: StringValue[] = [];\n    let innerStrStart = 0;\n    let innerStrEnd = str.length;\n\n    if (headFirstNewlineIdx != -1) {\n      if (headFirstNewlineIdx > 0) {\n        let leadingSpaces = new StringValue(\n          str.substring(0, headFirstNewlineIdx)\n        );\n        listTexts.push(leadingSpaces);\n      }\n      listTexts.push(new StringValue(\"\\n\"));\n      innerStrStart = headLastNewlineIdx + 1;\n    }\n\n    if (tailLastNewlineIdx != -1) {\n      innerStrEnd = tailFirstNewlineIdx;\n    }\n\n    if (innerStrEnd > innerStrStart) {\n      let innerStrText = str.substring(\n        innerStrStart,\n        innerStrEnd - innerStrStart\n      );\n      listTexts.push(new StringValue(innerStrText));\n    }\n\n    if (tailLastNewlineIdx != -1 && tailFirstNewlineIdx > headLastNewlineIdx) {\n      listTexts.push(new StringValue(\"\\n\"));\n      if (tailLastNewlineIdx < str.length - 1) {\n        let numSpaces = str.length - tailLastNewlineIdx - 1;\n        let trailingSpaces = new StringValue(\n          str.substring(tailLastNewlineIdx + 1, numSpaces)\n        );\n        listTexts.push(trailingSpaces);\n      }\n    }\n\n    return listTexts;\n  }\n\n  public PushToOutputStreamIndividual(obj: InkObject | null) {\n    let glue = asOrNull(obj, Glue);\n    let text = asOrNull(obj, StringValue);\n\n    let includeInOutput = true;\n\n    if (glue) {\n      this.TrimNewlinesFromOutputStream();\n      includeInOutput = true;\n    } else if (text) {\n      let functionTrimIndex = -1;\n      let currEl = this.callStack.currentElement;\n      if (currEl.type == PushPopType.Function) {\n        functionTrimIndex = currEl.functionStartInOutputStream;\n      }\n\n      let glueTrimIndex = -1;\n      for (let i = this.outputStream.length - 1; i >= 0; i--) {\n        let o = this.outputStream[i];\n        let c = o instanceof ControlCommand ? o : null;\n        let g = o instanceof Glue ? o : null;\n\n        if (g != null) {\n          glueTrimIndex = i;\n          break;\n        } else if (\n          c != null &&\n          c.commandType == ControlCommand.CommandType.BeginString\n        ) {\n          if (i >= functionTrimIndex) {\n            functionTrimIndex = -1;\n          }\n          break;\n        }\n      }\n\n      let trimIndex = -1;\n      if (glueTrimIndex != -1 && functionTrimIndex != -1)\n        trimIndex = Math.min(functionTrimIndex, glueTrimIndex);\n      else if (glueTrimIndex != -1) trimIndex = glueTrimIndex;\n      else trimIndex = functionTrimIndex;\n\n      if (trimIndex != -1) {\n        if (text.isNewline) {\n          includeInOutput = false;\n        } else if (text.isNonWhitespace) {\n          if (glueTrimIndex > -1) this.RemoveExistingGlue();\n\n          if (functionTrimIndex > -1) {\n            let callStackElements = this.callStack.elements;\n            for (let i = callStackElements.length - 1; i >= 0; i--) {\n              let el = callStackElements[i];\n              if (el.type == PushPopType.Function) {\n                el.functionStartInOutputStream = -1;\n              } else {\n                break;\n              }\n            }\n          }\n        }\n      } else if (text.isNewline) {\n        if (this.outputStreamEndsInNewline || !this.outputStreamContainsContent)\n          includeInOutput = false;\n      }\n    }\n\n    if (includeInOutput) {\n      if (obj === null) {\n        return throwNullException(\"obj\");\n      }\n      this.outputStream.push(obj);\n      this.OutputStreamDirty();\n    }\n  }\n\n  public TrimNewlinesFromOutputStream() {\n    let removeWhitespaceFrom = -1;\n\n    let i = this.outputStream.length - 1;\n    while (i >= 0) {\n      let obj = this.outputStream[i];\n      let cmd = asOrNull(obj, ControlCommand);\n      let txt = asOrNull(obj, StringValue);\n\n      if (cmd != null || (txt != null && txt.isNonWhitespace)) {\n        break;\n      } else if (txt != null && txt.isNewline) {\n        removeWhitespaceFrom = i;\n      }\n      i--;\n    }\n\n    // Remove the whitespace\n    if (removeWhitespaceFrom >= 0) {\n      i = removeWhitespaceFrom;\n      while (i < this.outputStream.length) {\n        let text = asOrNull(this.outputStream[i], StringValue);\n        if (text) {\n          this.outputStream.splice(i, 1);\n        } else {\n          i++;\n        }\n      }\n    }\n\n    this.OutputStreamDirty();\n  }\n\n  public RemoveExistingGlue() {\n    for (let i = this.outputStream.length - 1; i >= 0; i--) {\n      let c = this.outputStream[i];\n      if (c instanceof Glue) {\n        this.outputStream.splice(i, 1);\n      } else if (c instanceof ControlCommand) {\n        break;\n      }\n    }\n\n    this.OutputStreamDirty();\n  }\n\n  get outputStreamEndsInNewline() {\n    if (this.outputStream.length > 0) {\n      for (let i = this.outputStream.length - 1; i >= 0; i--) {\n        let obj = this.outputStream[i];\n        if (obj instanceof ControlCommand) break;\n        let text = this.outputStream[i];\n        if (text instanceof StringValue) {\n          if (text.isNewline) return true;\n          else if (text.isNonWhitespace) break;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  get outputStreamContainsContent() {\n    for (let content of this.outputStream) {\n      if (content instanceof StringValue) return true;\n    }\n    return false;\n  }\n\n  get inStringEvaluation() {\n    for (let i = this.outputStream.length - 1; i >= 0; i--) {\n      let cmd = asOrNull(this.outputStream[i], ControlCommand);\n      if (\n        cmd instanceof ControlCommand &&\n        cmd.commandType == ControlCommand.CommandType.BeginString\n      ) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  public PushEvaluationStack(obj: InkObject | null) {\n    // var listValue = obj as ListValue;\n    let listValue = asOrNull(obj, ListValue);\n    if (listValue) {\n      // Update origin when list is has something to indicate the list origin\n      let rawList = listValue.value;\n      if (rawList === null) {\n        return throwNullException(\"rawList\");\n      }\n\n      if (rawList.originNames != null) {\n        if (!rawList.origins) rawList.origins = [];\n        rawList.origins.length = 0;\n\n        for (let n of rawList.originNames) {\n          if (this.story.listDefinitions === null)\n            return throwNullException(\"StoryState.story.listDefinitions\");\n          let def = this.story.listDefinitions.TryListGetDefinition(n, null);\n          if (def.result === null)\n            return throwNullException(\"StoryState def.result\");\n          if (rawList.origins.indexOf(def.result) < 0)\n            rawList.origins.push(def.result);\n        }\n      }\n    }\n\n    if (obj === null) {\n      return throwNullException(\"obj\");\n    }\n    this.evaluationStack.push(obj);\n  }\n\n  public PopEvaluationStack(): InkObject;\n  public PopEvaluationStack(numberOfObjects: number): InkObject[];\n  public PopEvaluationStack(numberOfObjects?: number) {\n    if (typeof numberOfObjects === \"undefined\") {\n      let obj = this.evaluationStack.pop();\n      return nullIfUndefined(obj);\n    } else {\n      if (numberOfObjects > this.evaluationStack.length) {\n        throw new Error(\"trying to pop too many objects\");\n      }\n\n      let popped = this.evaluationStack.splice(\n        this.evaluationStack.length - numberOfObjects,\n        numberOfObjects\n      );\n      return nullIfUndefined(popped);\n    }\n  }\n\n  public PeekEvaluationStack() {\n    return this.evaluationStack[this.evaluationStack.length - 1];\n  }\n\n  public ForceEnd() {\n    this.callStack.Reset();\n\n    this._currentFlow.currentChoices.length = 0;\n\n    this.currentPointer = Pointer.Null;\n    this.previousPointer = Pointer.Null;\n\n    this.didSafeExit = true;\n  }\n\n  public TrimWhitespaceFromFunctionEnd() {\n    Debug.Assert(this.callStack.currentElement.type == PushPopType.Function);\n    let functionStartPoint = this.callStack.currentElement\n      .functionStartInOutputStream;\n\n    if (functionStartPoint == -1) {\n      functionStartPoint = 0;\n    }\n\n    for (let i = this.outputStream.length - 1; i >= functionStartPoint; i--) {\n      let obj = this.outputStream[i];\n      let txt = asOrNull(obj, StringValue);\n      let cmd = asOrNull(obj, ControlCommand);\n\n      if (txt == null) continue;\n      if (cmd) break;\n\n      if (txt.isNewline || txt.isInlineWhitespace) {\n        this.outputStream.splice(i, 1);\n        this.OutputStreamDirty();\n      } else {\n        break;\n      }\n    }\n  }\n\n  public PopCallStack(popType: PushPopType | null = null) {\n    if (this.callStack.currentElement.type == PushPopType.Function)\n      this.TrimWhitespaceFromFunctionEnd();\n\n    this.callStack.Pop(popType);\n  }\n\n  public SetChosenPath(path: Path, incrementingTurnIndex: boolean) {\n    // Changing direction, assume we need to clear current set of choices\n    this._currentFlow.currentChoices.length = 0;\n\n    let newPointer = this.story.PointerAtPath(path);\n    if (!newPointer.isNull && newPointer.index == -1) newPointer.index = 0;\n\n    this.currentPointer = newPointer;\n\n    if (incrementingTurnIndex) {\n      this.currentTurnIndex++;\n    }\n  }\n\n  public StartFunctionEvaluationFromGame(\n    funcContainer: Container,\n    args: any[]\n  ) {\n    this.callStack.Push(\n      PushPopType.FunctionEvaluationFromGame,\n      this.evaluationStack.length\n    );\n    this.callStack.currentElement.currentPointer = Pointer.StartOf(\n      funcContainer\n    );\n\n    this.PassArgumentsToEvaluationStack(args);\n  }\n\n  public PassArgumentsToEvaluationStack(args: any[] | null) {\n    if (args !== null) {\n      for (let i = 0; i < args.length; i++) {\n        if (\n          !(typeof args[i] === \"number\" || typeof args[i] === \"string\") ||\n          args[i] instanceof InkList\n        ) {\n          throw new Error(\n            \"ink arguments when calling EvaluateFunction / ChoosePathStringWithParameters must be\" +\n            \"number, string or InkList. Argument was \" +\n            (nullIfUndefined(arguments[i]) === null)\n              ? \"null\"\n              : arguments[i].constructor.name\n          );\n        }\n\n        this.PushEvaluationStack(Value.Create(args[i]));\n      }\n    }\n  }\n\n  public TryExitFunctionEvaluationFromGame() {\n    if (\n      this.callStack.currentElement.type ==\n      PushPopType.FunctionEvaluationFromGame\n    ) {\n      this.currentPointer = Pointer.Null;\n      this.didSafeExit = true;\n      return true;\n    }\n\n    return false;\n  }\n\n  public CompleteFunctionEvaluationFromGame() {\n    if (\n      this.callStack.currentElement.type !=\n      PushPopType.FunctionEvaluationFromGame\n    ) {\n      throw new Error(\n        \"Expected external function evaluation to be complete. Stack trace: \" +\n          this.callStack.callStackTrace\n      );\n    }\n\n    let originalEvaluationStackHeight = this.callStack.currentElement\n      .evaluationStackHeightWhenPushed;\n\n    let returnedObj: InkObject | null = null;\n    while (this.evaluationStack.length > originalEvaluationStackHeight) {\n      let poppedObj = this.PopEvaluationStack();\n      if (returnedObj === null) returnedObj = poppedObj;\n    }\n\n    this.PopCallStack(PushPopType.FunctionEvaluationFromGame);\n\n    if (returnedObj) {\n      if (returnedObj instanceof Void) return null;\n\n      // Some kind of value, if not void\n      // var returnVal = returnedObj as Runtime.Value;\n      let returnVal = asOrThrows(returnedObj, Value);\n\n      // DivertTargets get returned as the string of components\n      // (rather than a Path, which isn't public)\n      if (returnVal.valueType == ValueType.DivertTarget) {\n        return returnVal.valueObject.toString();\n      }\n\n      // Other types can just have their exact object type:\n      // int, float, string. VariablePointers get returned as strings.\n      return returnVal.valueObject;\n    }\n\n    return null;\n  }\n\n  public AddError(message: string, isWarning: boolean) {\n    if (!isWarning) {\n      if (this._currentErrors == null) this._currentErrors = [];\n      this._currentErrors.push(message);\n    } else {\n      if (this._currentWarnings == null) this._currentWarnings = [];\n      this._currentWarnings.push(message);\n    }\n  }\n\n  public OutputStreamDirty() {\n    this._outputStreamTextDirty = true;\n    this._outputStreamTagsDirty = true;\n  }\n\n  private _visitCounts: Map<string, number>;\n  private _turnIndices: Map<string, number>;\n\n  private _outputStreamTextDirty = true;\n  private _outputStreamTagsDirty = true;\n\n  private _patch: StatePatch | null = null;\n\n  private _currentFlow: Flow;\n  private _namedFlows: Map<string, Flow> | null = null;\n  private readonly kDefaultFlowName = \"DEFAULT_FLOW\";\n}\n","// This is simple replacement of the Stopwatch class from the .NET Framework.\n// The original class can count time with much more accuracy than the Javascript version.\n// It might be worth considering using `window.performance` in the browser\n// or `process.hrtime()` in node.\nexport class Stopwatch {\n  private startTime: number | undefined;\n\n  constructor() {\n    this.startTime = undefined;\n  }\n\n  get ElapsedMilliseconds(): number {\n    if (typeof this.startTime === \"undefined\") {\n      return 0;\n    }\n    return new Date().getTime() - this.startTime;\n  }\n\n  public Start() {\n    this.startTime = new Date().getTime();\n  }\n  public Stop() {\n    this.startTime = undefined;\n  }\n}\n","import { Container } from \"./Container\";\nimport { InkObject } from \"./Object\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { StoryState } from \"./StoryState\";\nimport { ControlCommand } from \"./ControlCommand\";\nimport { PushPopType } from \"./PushPop\";\nimport { ChoicePoint } from \"./ChoicePoint\";\nimport { Choice } from \"./Choice\";\nimport { Divert } from \"./Divert\";\nimport {\n  Value,\n  StringValue,\n  IntValue,\n  DivertTargetValue,\n  VariablePointerValue,\n  ListValue,\n} from \"./Value\";\nimport { Path } from \"./Path\";\nimport { Void } from \"./Void\";\nimport { Tag } from \"./Tag\";\nimport { VariableAssignment } from \"./VariableAssignment\";\nimport { VariableReference } from \"./VariableReference\";\nimport { NativeFunctionCall } from \"./NativeFunctionCall\";\nimport { StoryException } from \"./StoryException\";\nimport { PRNG } from \"./PRNG\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { ListDefinitionsOrigin } from \"./ListDefinitionsOrigin\";\nimport { ListDefinition } from \"./ListDefinition\";\nimport { Stopwatch } from \"./StopWatch\";\nimport { Pointer } from \"./Pointer\";\nimport { InkList, InkListItem, KeyValuePair } from \"./InkList\";\nimport { asOrNull, asOrThrows } from \"./TypeAssertion\";\nimport { DebugMetadata } from \"./DebugMetadata\";\nimport { throwNullException } from \"./NullException\";\nimport { SimpleJson } from \"./SimpleJson\";\nimport { ErrorHandler, ErrorType } from \"./Error\";\n\nexport { InkList } from \"./InkList\";\n\nif (!Number.isInteger) {\n  Number.isInteger = function isInteger(nVal: any) {\n    return (\n      typeof nVal === \"number\" &&\n      isFinite(nVal) &&\n      nVal > -9007199254740992 &&\n      nVal < 9007199254740992 &&\n      Math.floor(nVal) === nVal\n    );\n  };\n}\n\nexport class Story extends InkObject {\n  public static inkVersionCurrent = 20;\n\n  public inkVersionMinimumCompatible = 18;\n\n  get currentChoices() {\n    let choices: Choice[] = [];\n\n    if (this._state === null) {\n      return throwNullException(\"this._state\");\n    }\n    for (let c of this._state.currentChoices) {\n      if (!c.isInvisibleDefault) {\n        c.index = choices.length;\n        choices.push(c);\n      }\n    }\n\n    return choices;\n  }\n\n  get currentText() {\n    this.IfAsyncWeCant(\"call currentText since it's a work in progress\");\n    return this.state.currentText;\n  }\n\n  get currentTags() {\n    this.IfAsyncWeCant(\"call currentTags since it's a work in progress\");\n    return this.state.currentTags;\n  }\n\n  get currentErrors() {\n    return this.state.currentErrors;\n  }\n\n  get currentWarnings() {\n    return this.state.currentWarnings;\n  }\n\n  get currentFlowName() {\n    return this.state.currentFlowName;\n  }\n\n  get hasError() {\n    return this.state.hasError;\n  }\n\n  get hasWarning() {\n    return this.state.hasWarning;\n  }\n\n  get variablesState() {\n    return this.state.variablesState;\n  }\n\n  get listDefinitions() {\n    return this._listDefinitions;\n  }\n\n  get state() {\n    return this._state;\n  }\n\n  public onError: ErrorHandler | null = null;\n\n  public onDidContinue: (() => void) | null = null;\n\n  public onMakeChoice: ((arg1: Choice) => void) | null = null;\n\n  public onEvaluateFunction:\n    | ((arg1: string, arg2: any[]) => void)\n    | null = null;\n\n  public onCompleteEvaluateFunction:\n    | ((arg1: string, arg2: any[], arg3: string, arg4: any) => void)\n    | null = null;\n\n  public onChoosePathString:\n    | ((arg1: string, arg2: any[]) => void)\n    | null = null;\n\n  // TODO: Implement Profiler\n  public StartProfiling() {\n    /* */\n  }\n  public EndProfiling() {\n    /* */\n  }\n\n  constructor(contentContainer: Container, lists: ListDefinition[] | null);\n  constructor(jsonString: string);\n  constructor(json: Record<string, any>);\n  constructor() {\n    super();\n\n    // Discrimination between constructors\n    let contentContainer: Container;\n    let lists: ListDefinition[] | null = null;\n    let json: Record<string, any> | null = null;\n\n    if (arguments[0] instanceof Container) {\n      contentContainer = arguments[0] as Container;\n\n      if (typeof arguments[1] !== \"undefined\") {\n        lists = arguments[1] as ListDefinition[];\n      }\n\n      // ------ Story (Container contentContainer, List<Runtime.ListDefinition> lists = null)\n      this._mainContentContainer = contentContainer;\n      // ------\n    } else {\n      if (typeof arguments[0] === \"string\") {\n        let jsonString = arguments[0] as string;\n        json = SimpleJson.TextToDictionary(jsonString);\n      } else {\n        json = arguments[0] as Record<string, any>;\n      }\n    }\n\n    // ------ Story (Container contentContainer, List<Runtime.ListDefinition> lists = null)\n    if (lists != null) this._listDefinitions = new ListDefinitionsOrigin(lists);\n\n    this._externals = new Map();\n    // ------\n\n    // ------ Story(string jsonString) : this((Container)null)\n    if (json !== null) {\n      let rootObject: Record<string, any> = json;\n\n      let versionObj = rootObject[\"inkVersion\"];\n      if (versionObj == null)\n        throw new Error(\n          \"ink version number not found. Are you sure it's a valid .ink.json file?\"\n        );\n\n      let formatFromFile = parseInt(versionObj);\n      if (formatFromFile > Story.inkVersionCurrent) {\n        throw new Error(\n          \"Version of ink used to build story was newer than the current version of the engine\"\n        );\n      } else if (formatFromFile < this.inkVersionMinimumCompatible) {\n        throw new Error(\n          \"Version of ink used to build story is too old to be loaded by this version of the engine\"\n        );\n      } else if (formatFromFile != Story.inkVersionCurrent) {\n        console.warn(\n          \"WARNING: Version of ink used to build story doesn't match current version of engine. Non-critical, but recommend synchronising.\"\n        );\n      }\n\n      let rootToken = rootObject[\"root\"];\n      if (rootToken == null)\n        throw new Error(\n          \"Root node for ink not found. Are you sure it's a valid .ink.json file?\"\n        );\n\n      let listDefsObj;\n      if ((listDefsObj = rootObject[\"listDefs\"])) {\n        this._listDefinitions = JsonSerialisation.JTokenToListDefinitions(\n          listDefsObj\n        );\n      }\n\n      this._mainContentContainer = asOrThrows(\n        JsonSerialisation.JTokenToRuntimeObject(rootToken),\n        Container\n      );\n\n      this.ResetState();\n    }\n    // ------\n  }\n\n  // Merge together `public string ToJson()` and `void ToJson(SimpleJson.Writer writer)`.\n  // Will only return a value if writer was not provided.\n  public ToJson(writer?: SimpleJson.Writer): string | void {\n    let shouldReturn = false;\n\n    if (!writer) {\n      shouldReturn = true;\n      writer = new SimpleJson.Writer();\n    }\n\n    writer.WriteObjectStart();\n\n    writer.WriteIntProperty(\"inkVersion\", Story.inkVersionCurrent);\n\n    writer.WriteProperty(\"root\", (w) =>\n      JsonSerialisation.WriteRuntimeContainer(w, this._mainContentContainer)\n    );\n\n    if (this._listDefinitions != null) {\n      writer.WritePropertyStart(\"listDefs\");\n      writer.WriteObjectStart();\n\n      for (let def of this._listDefinitions.lists) {\n        writer.WritePropertyStart(def.name);\n        writer.WriteObjectStart();\n\n        for (let [key, value] of def.items) {\n          let item = InkListItem.fromSerializedKey(key);\n          let val = value;\n          writer.WriteIntProperty(item.itemName, val);\n        }\n\n        writer.WriteObjectEnd();\n        writer.WritePropertyEnd();\n      }\n\n      writer.WriteObjectEnd();\n      writer.WritePropertyEnd();\n    }\n\n    writer.WriteObjectEnd();\n\n    if (shouldReturn) return writer.toString();\n  }\n\n  public ResetState() {\n    this.IfAsyncWeCant(\"ResetState\");\n\n    this._state = new StoryState(this);\n    this._state.variablesState.ObserveVariableChange(\n      this.VariableStateDidChangeEvent.bind(this)\n    );\n\n    this.ResetGlobals();\n  }\n\n  public ResetErrors() {\n    if (this._state === null) {\n      return throwNullException(\"this._state\");\n    }\n    this._state.ResetErrors();\n  }\n\n  public ResetCallstack() {\n    this.IfAsyncWeCant(\"ResetCallstack\");\n    if (this._state === null) {\n      return throwNullException(\"this._state\");\n    }\n    this._state.ForceEnd();\n  }\n\n  public ResetGlobals() {\n    if (this._mainContentContainer.namedContent.get(\"global decl\")) {\n      let originalPointer = this.state.currentPointer.copy();\n\n      this.ChoosePath(new Path(\"global decl\"), false);\n\n      this.ContinueInternal();\n\n      this.state.currentPointer = originalPointer;\n    }\n\n    this.state.variablesState.SnapshotDefaultGlobals();\n  }\n\n  public SwitchFlow(flowName: string) {\n    this.IfAsyncWeCant(\"switch flow\");\n    if (this._asyncSaving) {\n      throw new Error(\n        \"Story is already in background saving mode, can't switch flow to \" +\n          flowName\n      );\n    }\n\n    this.state.SwitchFlow_Internal(flowName);\n  }\n\n  public RemoveFlow(flowName: string) {\n    this.state.RemoveFlow_Internal(flowName);\n  }\n\n  public SwitchToDefaultFlow() {\n    this.state.SwitchToDefaultFlow_Internal();\n  }\n\n  public Continue() {\n    this.ContinueAsync(0);\n    return this.currentText;\n  }\n\n  get canContinue() {\n    return this.state.canContinue;\n  }\n\n  get asyncContinueComplete() {\n    return !this._asyncContinueActive;\n  }\n\n  public ContinueAsync(millisecsLimitAsync: number) {\n    if (!this._hasValidatedExternals) this.ValidateExternalBindings();\n\n    this.ContinueInternal(millisecsLimitAsync);\n  }\n\n  public ContinueInternal(millisecsLimitAsync = 0) {\n    if (this._profiler != null) this._profiler.PreContinue();\n\n    let isAsyncTimeLimited = millisecsLimitAsync > 0;\n    this._recursiveContinueCount++;\n\n    if (!this._asyncContinueActive) {\n      this._asyncContinueActive = isAsyncTimeLimited;\n\n      if (!this.canContinue) {\n        throw new Error(\n          \"Can't continue - should check canContinue before calling Continue\"\n        );\n      }\n\n      this._state.didSafeExit = false;\n      this._state.ResetOutput();\n\n      if (this._recursiveContinueCount == 1)\n        this._state.variablesState.batchObservingVariableChanges = true;\n    }\n\n    let durationStopwatch = new Stopwatch();\n    durationStopwatch.Start();\n\n    let outputStreamEndsInNewline = false;\n    this._sawLookaheadUnsafeFunctionAfterNewline = false;\n    do {\n      try {\n        outputStreamEndsInNewline = this.ContinueSingleStep();\n      } catch (e) {\n        if (!(e instanceof StoryException)) throw e;\n\n        this.AddError(e.message, undefined, e.useEndLineNumber);\n        break;\n      }\n\n      if (outputStreamEndsInNewline) break;\n\n      if (\n        this._asyncContinueActive &&\n        durationStopwatch.ElapsedMilliseconds > millisecsLimitAsync\n      ) {\n        break;\n      }\n    } while (this.canContinue);\n\n    durationStopwatch.Stop();\n\n    if (outputStreamEndsInNewline || !this.canContinue) {\n      if (this._stateSnapshotAtLastNewline !== null) {\n        this.RestoreStateSnapshot();\n      }\n\n      if (!this.canContinue) {\n        if (this.state.callStack.canPopThread)\n          this.AddError(\n            \"Thread available to pop, threads should always be flat by the end of evaluation?\"\n          );\n\n        if (\n          this.state.generatedChoices.length == 0 &&\n          !this.state.didSafeExit &&\n          this._temporaryEvaluationContainer == null\n        ) {\n          if (this.state.callStack.CanPop(PushPopType.Tunnel))\n            this.AddError(\n              \"unexpectedly reached end of content. Do you need a '->->' to return from a tunnel?\"\n            );\n          else if (this.state.callStack.CanPop(PushPopType.Function))\n            this.AddError(\n              \"unexpectedly reached end of content. Do you need a '~ return'?\"\n            );\n          else if (!this.state.callStack.canPop)\n            this.AddError(\n              \"ran out of content. Do you need a '-> DONE' or '-> END'?\"\n            );\n          else\n            this.AddError(\n              \"unexpectedly reached end of content for unknown reason. Please debug compiler!\"\n            );\n        }\n      }\n\n      this.state.didSafeExit = false;\n      this._sawLookaheadUnsafeFunctionAfterNewline = false;\n\n      if (this._recursiveContinueCount == 1)\n        this._state.variablesState.batchObservingVariableChanges = false;\n\n      this._asyncContinueActive = false;\n      if (this.onDidContinue !== null) this.onDidContinue();\n    }\n\n    this._recursiveContinueCount--;\n\n    if (this._profiler != null) this._profiler.PostContinue();\n\n    // In the following code, we're masking a lot of non-null assertion,\n    // because testing for against `hasError` or `hasWarning` makes sure\n    // the arrays are present and contain at least one element.\n    if (this.state.hasError || this.state.hasWarning) {\n      if (this.onError !== null) {\n        if (this.state.hasError) {\n          for (let err of this.state.currentErrors!) {\n            this.onError(err, ErrorType.Error);\n          }\n        }\n        if (this.state.hasWarning) {\n          for (let err of this.state.currentWarnings!) {\n            this.onError(err, ErrorType.Warning);\n          }\n        }\n        this.ResetErrors();\n      } else {\n        let sb = new StringBuilder();\n        sb.Append(\"Ink had \");\n        if (this.state.hasError) {\n          sb.Append(`${this.state.currentErrors!.length}`);\n          sb.Append(\n            this.state.currentErrors!.length == 1 ? \" error\" : \"errors\"\n          );\n          if (this.state.hasWarning) sb.Append(\" and \");\n        }\n        if (this.state.hasWarning) {\n          sb.Append(`${this.state.currentWarnings!.length}`);\n          sb.Append(\n            this.state.currentWarnings!.length == 1 ? \" warning\" : \"warnings\"\n          );\n          if (this.state.hasWarning) sb.Append(\" and \");\n        }\n        sb.Append(\n          \". It is strongly suggested that you assign an error handler to story.onError. The first issue was: \"\n        );\n        sb.Append(\n          this.state.hasError\n            ? this.state.currentErrors![0]\n            : this.state.currentWarnings![0]\n        );\n\n        throw new StoryException(sb.toString());\n      }\n    }\n  }\n\n  public ContinueSingleStep() {\n    if (this._profiler != null) this._profiler.PreStep();\n\n    this.Step();\n\n    if (this._profiler != null) this._profiler.PostStep();\n\n    if (!this.canContinue && !this.state.callStack.elementIsEvaluateFromGame) {\n      this.TryFollowDefaultInvisibleChoice();\n    }\n\n    if (this._profiler != null) this._profiler.PreSnapshot();\n\n    if (!this.state.inStringEvaluation) {\n      if (this._stateSnapshotAtLastNewline !== null) {\n        if (this._stateSnapshotAtLastNewline.currentTags === null) {\n          return throwNullException(\"this._stateAtLastNewline.currentTags\");\n        }\n        if (this.state.currentTags === null) {\n          return throwNullException(\"this.state.currentTags\");\n        }\n\n        let change = this.CalculateNewlineOutputStateChange(\n          this._stateSnapshotAtLastNewline.currentText,\n          this.state.currentText,\n          this._stateSnapshotAtLastNewline.currentTags.length,\n          this.state.currentTags.length\n        );\n\n        if (\n          change == Story.OutputStateChange.ExtendedBeyondNewline ||\n          this._sawLookaheadUnsafeFunctionAfterNewline\n        ) {\n          this.RestoreStateSnapshot();\n\n          return true;\n        } else if (change == Story.OutputStateChange.NewlineRemoved) {\n          this.DiscardSnapshot();\n        }\n      }\n\n      if (this.state.outputStreamEndsInNewline) {\n        if (this.canContinue) {\n          if (this._stateSnapshotAtLastNewline == null) this.StateSnapshot();\n        } else {\n          this.DiscardSnapshot();\n        }\n      }\n    }\n\n    if (this._profiler != null) this._profiler.PostSnapshot();\n\n    return false;\n  }\n\n  public CalculateNewlineOutputStateChange(\n    prevText: string | null,\n    currText: string | null,\n    prevTagCount: number,\n    currTagCount: number\n  ) {\n    if (prevText === null) {\n      return throwNullException(\"prevText\");\n    }\n    if (currText === null) {\n      return throwNullException(\"currText\");\n    }\n\n    let newlineStillExists =\n      currText.length >= prevText.length &&\n      currText.charAt(prevText.length - 1) == \"\\n\";\n    if (\n      prevTagCount == currTagCount &&\n      prevText.length == currText.length &&\n      newlineStillExists\n    )\n      return Story.OutputStateChange.NoChange;\n\n    if (!newlineStillExists) {\n      return Story.OutputStateChange.NewlineRemoved;\n    }\n\n    if (currTagCount > prevTagCount)\n      return Story.OutputStateChange.ExtendedBeyondNewline;\n\n    for (let i = prevText.length; i < currText.length; i++) {\n      let c = currText.charAt(i);\n      if (c != \" \" && c != \"\\t\") {\n        return Story.OutputStateChange.ExtendedBeyondNewline;\n      }\n    }\n\n    return Story.OutputStateChange.NoChange;\n  }\n\n  public ContinueMaximally() {\n    this.IfAsyncWeCant(\"ContinueMaximally\");\n\n    let sb = new StringBuilder();\n\n    while (this.canContinue) {\n      sb.Append(this.Continue());\n    }\n\n    return sb.toString();\n  }\n\n  public ContentAtPath(path: Path) {\n    return this.mainContentContainer.ContentAtPath(path);\n  }\n\n  public KnotContainerWithName(name: string) {\n    let namedContainer = this.mainContentContainer.namedContent.get(name);\n    if (namedContainer instanceof Container) return namedContainer;\n    else return null;\n  }\n\n  public PointerAtPath(path: Path) {\n    if (path.length == 0) return Pointer.Null;\n\n    let p = new Pointer();\n\n    let pathLengthToUse = path.length;\n\n    let result = null;\n    if (path.lastComponent === null) {\n      return throwNullException(\"path.lastComponent\");\n    }\n\n    if (path.lastComponent.isIndex) {\n      pathLengthToUse = path.length - 1;\n      result = this.mainContentContainer.ContentAtPath(\n        path,\n        undefined,\n        pathLengthToUse\n      );\n      p.container = result.container;\n      p.index = path.lastComponent.index;\n    } else {\n      result = this.mainContentContainer.ContentAtPath(path);\n      p.container = result.container;\n      p.index = -1;\n    }\n\n    if (\n      result.obj == null ||\n      (result.obj == this.mainContentContainer && pathLengthToUse > 0)\n    ) {\n      this.Error(\n        \"Failed to find content at path '\" +\n          path +\n          \"', and no approximation of it was possible.\"\n      );\n    } else if (result.approximate)\n      this.Warning(\n        \"Failed to find content at path '\" +\n          path +\n          \"', so it was approximated to: '\" +\n          result.obj.path +\n          \"'.\"\n      );\n\n    return p;\n  }\n\n  public StateSnapshot() {\n    this._stateSnapshotAtLastNewline = this._state;\n    this._state = this._state.CopyAndStartPatching();\n  }\n\n  public RestoreStateSnapshot() {\n    if (this._stateSnapshotAtLastNewline === null) {\n      throwNullException(\"_stateSnapshotAtLastNewline\");\n    }\n    this._stateSnapshotAtLastNewline.RestoreAfterPatch();\n\n    this._state = this._stateSnapshotAtLastNewline;\n    this._stateSnapshotAtLastNewline = null;\n\n    if (!this._asyncSaving) {\n      this._state.ApplyAnyPatch();\n    }\n  }\n\n  public DiscardSnapshot() {\n    if (!this._asyncSaving) this._state.ApplyAnyPatch();\n\n    this._stateSnapshotAtLastNewline = null;\n  }\n\n  public CopyStateForBackgroundThreadSave() {\n    this.IfAsyncWeCant(\"start saving on a background thread\");\n\n    if (this._asyncSaving)\n      throw new Error(\n        \"Story is already in background saving mode, can't call CopyStateForBackgroundThreadSave again!\"\n      );\n\n    let stateToSave = this._state;\n    this._state = this._state.CopyAndStartPatching();\n    this._asyncSaving = true;\n    return stateToSave;\n  }\n\n  public BackgroundSaveComplete() {\n    if (this._stateSnapshotAtLastNewline === null) {\n      this._state.ApplyAnyPatch();\n    }\n\n    this._asyncSaving = false;\n  }\n\n  public Step() {\n    let shouldAddToStream = true;\n\n    let pointer = this.state.currentPointer.copy();\n    if (pointer.isNull) {\n      return;\n    }\n\n    // Container containerToEnter = pointer.Resolve () as Container;\n    let containerToEnter = asOrNull(pointer.Resolve(), Container);\n\n    while (containerToEnter) {\n      this.VisitContainer(containerToEnter, true);\n\n      // No content? the most we can do is step past it\n      if (containerToEnter.content.length == 0) {\n        break;\n      }\n\n      pointer = Pointer.StartOf(containerToEnter);\n      // containerToEnter = pointer.Resolve() as Container;\n      containerToEnter = asOrNull(pointer.Resolve(), Container);\n    }\n\n    this.state.currentPointer = pointer.copy();\n\n    if (this._profiler != null) this._profiler.Step(this.state.callStack);\n\n    // Is the current content object:\n    //  - Normal content\n    //  - Or a logic/flow statement - if so, do it\n    // Stop flow if we hit a stack pop when we're unable to pop (e.g. return/done statement in knot\n    // that was diverted to rather than called as a function)\n    let currentContentObj = pointer.Resolve();\n    let isLogicOrFlowControl = this.PerformLogicAndFlowControl(\n      currentContentObj\n    );\n\n    // Has flow been forced to end by flow control above?\n    if (this.state.currentPointer.isNull) {\n      return;\n    }\n\n    if (isLogicOrFlowControl) {\n      shouldAddToStream = false;\n    }\n\n    // Choice with condition?\n    // var choicePoint = currentContentObj as ChoicePoint;\n    let choicePoint = asOrNull(currentContentObj, ChoicePoint);\n    if (choicePoint) {\n      let choice = this.ProcessChoice(choicePoint);\n      if (choice) {\n        this.state.generatedChoices.push(choice);\n      }\n\n      currentContentObj = null;\n      shouldAddToStream = false;\n    }\n\n    // If the container has no content, then it will be\n    // the \"content\" itself, but we skip over it.\n    if (currentContentObj instanceof Container) {\n      shouldAddToStream = false;\n    }\n\n    // Content to add to evaluation stack or the output stream\n    if (shouldAddToStream) {\n      // If we're pushing a variable pointer onto the evaluation stack, ensure that it's specific\n      // to our current (possibly temporary) context index. And make a copy of the pointer\n      // so that we're not editing the original runtime object.\n      // var varPointer = currentContentObj as VariablePointerValue;\n      let varPointer = asOrNull(currentContentObj, VariablePointerValue);\n      if (varPointer && varPointer.contextIndex == -1) {\n        // Create new object so we're not overwriting the story's own data\n        let contextIdx = this.state.callStack.ContextForVariableNamed(\n          varPointer.variableName\n        );\n        currentContentObj = new VariablePointerValue(\n          varPointer.variableName,\n          contextIdx\n        );\n      }\n\n      // Expression evaluation content\n      if (this.state.inExpressionEvaluation) {\n        this.state.PushEvaluationStack(currentContentObj);\n      }\n      // Output stream content (i.e. not expression evaluation)\n      else {\n        this.state.PushToOutputStream(currentContentObj);\n      }\n    }\n\n    // Increment the content pointer, following diverts if necessary\n    this.NextContent();\n\n    // Starting a thread should be done after the increment to the content pointer,\n    // so that when returning from the thread, it returns to the content after this instruction.\n    // var controlCmd = currentContentObj as ;\n    let controlCmd = asOrNull(currentContentObj, ControlCommand);\n    if (\n      controlCmd &&\n      controlCmd.commandType == ControlCommand.CommandType.StartThread\n    ) {\n      this.state.callStack.PushThread();\n    }\n  }\n\n  public VisitContainer(container: Container, atStart: boolean) {\n    if (!container.countingAtStartOnly || atStart) {\n      if (container.visitsShouldBeCounted)\n        this.state.IncrementVisitCountForContainer(container);\n\n      if (container.turnIndexShouldBeCounted)\n        this.state.RecordTurnIndexVisitToContainer(container);\n    }\n  }\n\n  private _prevContainers: Container[] = [];\n  public VisitChangedContainersDueToDivert() {\n    let previousPointer = this.state.previousPointer.copy();\n    let pointer = this.state.currentPointer.copy();\n\n    if (pointer.isNull || pointer.index == -1) return;\n\n    this._prevContainers.length = 0;\n    if (!previousPointer.isNull) {\n      // Container prevAncestor = previousPointer.Resolve() as Container ?? previousPointer.container as Container;\n      let resolvedPreviousAncestor = previousPointer.Resolve();\n      let prevAncestor =\n        asOrNull(resolvedPreviousAncestor, Container) ||\n        asOrNull(previousPointer.container, Container);\n      while (prevAncestor) {\n        this._prevContainers.push(prevAncestor);\n        // prevAncestor = prevAncestor.parent as Container;\n        prevAncestor = asOrNull(prevAncestor.parent, Container);\n      }\n    }\n\n    let currentChildOfContainer = pointer.Resolve();\n\n    if (currentChildOfContainer == null) return;\n\n    // Container currentContainerAncestor = currentChildOfContainer.parent as Container;\n    let currentContainerAncestor = asOrNull(\n      currentChildOfContainer.parent,\n      Container\n    );\n    let allChildrenEnteredAtStart = true;\n    while (\n      currentContainerAncestor &&\n      (this._prevContainers.indexOf(currentContainerAncestor) < 0 ||\n        currentContainerAncestor.countingAtStartOnly)\n    ) {\n      // Check whether this ancestor container is being entered at the start,\n      // by checking whether the child object is the first.\n      let enteringAtStart =\n        currentContainerAncestor.content.length > 0 &&\n        currentChildOfContainer == currentContainerAncestor.content[0] &&\n        allChildrenEnteredAtStart;\n\n      if (!enteringAtStart) allChildrenEnteredAtStart = false;\n\n      // Mark a visit to this container\n      this.VisitContainer(currentContainerAncestor, enteringAtStart);\n\n      currentChildOfContainer = currentContainerAncestor;\n      // currentContainerAncestor = currentContainerAncestor.parent as Container;\n      currentContainerAncestor = asOrNull(\n        currentContainerAncestor.parent,\n        Container\n      );\n    }\n  }\n\n  public ProcessChoice(choicePoint: ChoicePoint) {\n    let showChoice = true;\n\n    // Don't create choice if choice point doesn't pass conditional\n    if (choicePoint.hasCondition) {\n      let conditionValue = this.state.PopEvaluationStack();\n      if (!this.IsTruthy(conditionValue)) {\n        showChoice = false;\n      }\n    }\n\n    let startText = \"\";\n    let choiceOnlyText = \"\";\n\n    if (choicePoint.hasChoiceOnlyContent) {\n      // var choiceOnlyStrVal = state.PopEvaluationStack () as StringValue;\n      let choiceOnlyStrVal = asOrThrows(\n        this.state.PopEvaluationStack(),\n        StringValue\n      );\n      choiceOnlyText = choiceOnlyStrVal.value || \"\";\n    }\n\n    if (choicePoint.hasStartContent) {\n      // var startStrVal = state.PopEvaluationStack () as StringValue;\n      let startStrVal = asOrThrows(\n        this.state.PopEvaluationStack(),\n        StringValue\n      );\n      startText = startStrVal.value || \"\";\n    }\n\n    // Don't create choice if player has already read this content\n    if (choicePoint.onceOnly) {\n      let visitCount = this.state.VisitCountForContainer(\n        choicePoint.choiceTarget\n      );\n      if (visitCount > 0) {\n        showChoice = false;\n      }\n    }\n\n    // We go through the full process of creating the choice above so\n    // that we consume the content for it, since otherwise it'll\n    // be shown on the output stream.\n    if (!showChoice) {\n      return null;\n    }\n\n    let choice = new Choice();\n    choice.targetPath = choicePoint.pathOnChoice;\n    choice.sourcePath = choicePoint.path.toString();\n    choice.isInvisibleDefault = choicePoint.isInvisibleDefault;\n    choice.threadAtGeneration = this.state.callStack.ForkThread();\n\n    choice.text = (startText + choiceOnlyText).replace(/^[ \\t]+|[ \\t]+$/g, \"\");\n\n    return choice;\n  }\n\n  public IsTruthy(obj: InkObject) {\n    let truthy = false;\n    if (obj instanceof Value) {\n      let val = obj;\n\n      if (val instanceof DivertTargetValue) {\n        let divTarget = val;\n        this.Error(\n          \"Shouldn't use a divert target (to \" +\n            divTarget.targetPath +\n            \") as a conditional value. Did you intend a function call 'likeThis()' or a read count check 'likeThis'? (no arrows)\"\n        );\n        return false;\n      }\n\n      return val.isTruthy;\n    }\n    return truthy;\n  }\n\n  public PerformLogicAndFlowControl(contentObj: InkObject | null) {\n    if (contentObj == null) {\n      return false;\n    }\n\n    // Divert\n    if (contentObj instanceof Divert) {\n      let currentDivert = contentObj;\n\n      if (currentDivert.isConditional) {\n        let conditionValue = this.state.PopEvaluationStack();\n\n        // False conditional? Cancel divert\n        if (!this.IsTruthy(conditionValue)) return true;\n      }\n\n      if (currentDivert.hasVariableTarget) {\n        let varName = currentDivert.variableDivertName;\n\n        let varContents = this.state.variablesState.GetVariableWithName(\n          varName\n        );\n\n        if (varContents == null) {\n          this.Error(\n            \"Tried to divert using a target from a variable that could not be found (\" +\n              varName +\n              \")\"\n          );\n        } else if (!(varContents instanceof DivertTargetValue)) {\n          // var intContent = varContents as IntValue;\n          let intContent = asOrNull(varContents, IntValue);\n\n          let errorMessage =\n            \"Tried to divert to a target from a variable, but the variable (\" +\n            varName +\n            \") didn't contain a divert target, it \";\n          if (intContent instanceof IntValue && intContent.value == 0) {\n            errorMessage += \"was empty/null (the value 0).\";\n          } else {\n            errorMessage += \"contained '\" + varContents + \"'.\";\n          }\n\n          this.Error(errorMessage);\n        }\n\n        let target = asOrThrows(varContents, DivertTargetValue);\n        this.state.divertedPointer = this.PointerAtPath(target.targetPath);\n      } else if (currentDivert.isExternal) {\n        this.CallExternalFunction(\n          currentDivert.targetPathString,\n          currentDivert.externalArgs\n        );\n        return true;\n      } else {\n        this.state.divertedPointer = currentDivert.targetPointer.copy();\n      }\n\n      if (currentDivert.pushesToStack) {\n        this.state.callStack.Push(\n          currentDivert.stackPushType,\n          undefined,\n          this.state.outputStream.length\n        );\n      }\n\n      if (this.state.divertedPointer.isNull && !currentDivert.isExternal) {\n        if (\n          currentDivert &&\n          currentDivert.debugMetadata &&\n          currentDivert.debugMetadata.sourceName != null\n        ) {\n          this.Error(\n            \"Divert target doesn't exist: \" +\n              currentDivert.debugMetadata.sourceName\n          );\n        } else {\n          this.Error(\"Divert resolution failed: \" + currentDivert);\n        }\n      }\n\n      return true;\n    }\n\n    // Start/end an expression evaluation? Or print out the result?\n    else if (contentObj instanceof ControlCommand) {\n      let evalCommand = contentObj;\n\n      switch (evalCommand.commandType) {\n        case ControlCommand.CommandType.EvalStart:\n          this.Assert(\n            this.state.inExpressionEvaluation === false,\n            \"Already in expression evaluation?\"\n          );\n          this.state.inExpressionEvaluation = true;\n          break;\n\n        case ControlCommand.CommandType.EvalEnd:\n          this.Assert(\n            this.state.inExpressionEvaluation === true,\n            \"Not in expression evaluation mode\"\n          );\n          this.state.inExpressionEvaluation = false;\n          break;\n\n        case ControlCommand.CommandType.EvalOutput:\n          // If the expression turned out to be empty, there may not be anything on the stack\n          if (this.state.evaluationStack.length > 0) {\n            let output = this.state.PopEvaluationStack();\n\n            // Functions may evaluate to Void, in which case we skip output\n            if (!(output instanceof Void)) {\n              // TODO: Should we really always blanket convert to string?\n              // It would be okay to have numbers in the output stream the\n              // only problem is when exporting text for viewing, it skips over numbers etc.\n              let text = new StringValue(output.toString());\n\n              this.state.PushToOutputStream(text);\n            }\n          }\n          break;\n\n        case ControlCommand.CommandType.NoOp:\n          break;\n\n        case ControlCommand.CommandType.Duplicate:\n          this.state.PushEvaluationStack(this.state.PeekEvaluationStack());\n          break;\n\n        case ControlCommand.CommandType.PopEvaluatedValue:\n          this.state.PopEvaluationStack();\n          break;\n\n        case ControlCommand.CommandType.PopFunction:\n        case ControlCommand.CommandType.PopTunnel:\n          let popType =\n            evalCommand.commandType == ControlCommand.CommandType.PopFunction\n              ? PushPopType.Function\n              : PushPopType.Tunnel;\n\n          let overrideTunnelReturnTarget: DivertTargetValue | null = null;\n          if (popType == PushPopType.Tunnel) {\n            let popped = this.state.PopEvaluationStack();\n            // overrideTunnelReturnTarget = popped as DivertTargetValue;\n            overrideTunnelReturnTarget = asOrNull(popped, DivertTargetValue);\n            if (overrideTunnelReturnTarget === null) {\n              this.Assert(\n                popped instanceof Void,\n                \"Expected void if ->-> doesn't override target\"\n              );\n            }\n          }\n\n          if (this.state.TryExitFunctionEvaluationFromGame()) {\n            break;\n          } else if (\n            this.state.callStack.currentElement.type != popType ||\n            !this.state.callStack.canPop\n          ) {\n            let names: Map<PushPopType, string> = new Map();\n            names.set(\n              PushPopType.Function,\n              \"function return statement (~ return)\"\n            );\n            names.set(PushPopType.Tunnel, \"tunnel onwards statement (->->)\");\n\n            let expected = names.get(this.state.callStack.currentElement.type);\n            if (!this.state.callStack.canPop) {\n              expected = \"end of flow (-> END or choice)\";\n            }\n\n            let errorMsg =\n              \"Found \" + names.get(popType) + \", when expected \" + expected;\n\n            this.Error(errorMsg);\n          } else {\n            this.state.PopCallStack();\n\n            if (overrideTunnelReturnTarget)\n              this.state.divertedPointer = this.PointerAtPath(\n                overrideTunnelReturnTarget.targetPath\n              );\n          }\n          break;\n\n        case ControlCommand.CommandType.BeginString:\n          this.state.PushToOutputStream(evalCommand);\n\n          this.Assert(\n            this.state.inExpressionEvaluation === true,\n            \"Expected to be in an expression when evaluating a string\"\n          );\n          this.state.inExpressionEvaluation = false;\n          break;\n\n        case ControlCommand.CommandType.EndString:\n          let contentStackForString: InkObject[] = [];\n\n          let outputCountConsumed = 0;\n          for (let i = this.state.outputStream.length - 1; i >= 0; --i) {\n            let obj = this.state.outputStream[i];\n\n            outputCountConsumed++;\n\n            // var command = obj as ControlCommand;\n            let command = asOrNull(obj, ControlCommand);\n            if (\n              command &&\n              command.commandType == ControlCommand.CommandType.BeginString\n            ) {\n              break;\n            }\n\n            if (obj instanceof StringValue) {\n              contentStackForString.push(obj);\n            }\n          }\n\n          // Consume the content that was produced for this string\n          this.state.PopFromOutputStream(outputCountConsumed);\n\n          // The C# version uses a Stack for contentStackForString, but we're\n          // using a simple array, so we need to reverse it before using it\n          contentStackForString = contentStackForString.reverse();\n\n          // Build string out of the content we collected\n          let sb = new StringBuilder();\n          for (let c of contentStackForString) {\n            sb.Append(c.toString());\n          }\n\n          // Return to expression evaluation (from content mode)\n          this.state.inExpressionEvaluation = true;\n          this.state.PushEvaluationStack(new StringValue(sb.toString()));\n          break;\n\n        case ControlCommand.CommandType.ChoiceCount:\n          let choiceCount = this.state.generatedChoices.length;\n          this.state.PushEvaluationStack(new IntValue(choiceCount));\n          break;\n\n        case ControlCommand.CommandType.Turns:\n          this.state.PushEvaluationStack(\n            new IntValue(this.state.currentTurnIndex + 1)\n          );\n          break;\n\n        case ControlCommand.CommandType.TurnsSince:\n        case ControlCommand.CommandType.ReadCount:\n          let target = this.state.PopEvaluationStack();\n          if (!(target instanceof DivertTargetValue)) {\n            let extraNote = \"\";\n            if (target instanceof IntValue)\n              extraNote =\n                \". Did you accidentally pass a read count ('knot_name') instead of a target ('-> knot_name')?\";\n            this.Error(\n              \"TURNS_SINCE / READ_COUNT expected a divert target (knot, stitch, label name), but saw \" +\n                target +\n                extraNote\n            );\n            break;\n          }\n\n          // var divertTarget = target as DivertTargetValue;\n          let divertTarget = asOrThrows(target, DivertTargetValue);\n          // var container = ContentAtPath (divertTarget.targetPath).correctObj as Container;\n          let container = asOrNull(\n            this.ContentAtPath(divertTarget.targetPath).correctObj,\n            Container\n          );\n\n          let eitherCount;\n          if (container != null) {\n            if (\n              evalCommand.commandType == ControlCommand.CommandType.TurnsSince\n            )\n              eitherCount = this.state.TurnsSinceForContainer(container);\n            else eitherCount = this.state.VisitCountForContainer(container);\n          } else {\n            if (\n              evalCommand.commandType == ControlCommand.CommandType.TurnsSince\n            )\n              eitherCount = -1;\n            else eitherCount = 0;\n\n            this.Warning(\n              \"Failed to find container for \" +\n                evalCommand.toString() +\n                \" lookup at \" +\n                divertTarget.targetPath.toString()\n            );\n          }\n\n          this.state.PushEvaluationStack(new IntValue(eitherCount));\n          break;\n\n        case ControlCommand.CommandType.Random: {\n          let maxInt = asOrNull(this.state.PopEvaluationStack(), IntValue);\n          let minInt = asOrNull(this.state.PopEvaluationStack(), IntValue);\n\n          if (minInt == null || minInt instanceof IntValue === false)\n            return this.Error(\n              \"Invalid value for minimum parameter of RANDOM(min, max)\"\n            );\n\n          if (maxInt == null || minInt instanceof IntValue === false)\n            return this.Error(\n              \"Invalid value for maximum parameter of RANDOM(min, max)\"\n            );\n\n          // Originally a primitive type, but here, can be null.\n          // TODO: Replace by default value?\n          if (maxInt.value === null) {\n            return throwNullException(\"maxInt.value\");\n          }\n          if (minInt.value === null) {\n            return throwNullException(\"minInt.value\");\n          }\n\n          // This code is differs a bit from the reference implementation, since\n          // JavaScript has no true integers. Hence integer arithmetics and\n          // interger overflows don't apply here. A loss of precision can\n          // happen with big numbers however.\n          //\n          // The case where 'randomRange' is lower than zero is handled below,\n          // so there's no need to test against Number.MIN_SAFE_INTEGER.\n          let randomRange = maxInt.value - minInt.value + 1;\n          if (!isFinite(randomRange) || randomRange > Number.MAX_SAFE_INTEGER) {\n            randomRange = Number.MAX_SAFE_INTEGER;\n            this.Error(\n              \"RANDOM was called with a range that exceeds the size that ink numbers can use.\"\n            );\n          }\n          if (randomRange <= 0)\n            this.Error(\n              \"RANDOM was called with minimum as \" +\n                minInt.value +\n                \" and maximum as \" +\n                maxInt.value +\n                \". The maximum must be larger\"\n            );\n\n          let resultSeed = this.state.storySeed + this.state.previousRandom;\n          let random = new PRNG(resultSeed);\n\n          let nextRandom = random.next();\n          let chosenValue = (nextRandom % randomRange) + minInt.value;\n          this.state.PushEvaluationStack(new IntValue(chosenValue));\n\n          // Next random number (rather than keeping the Random object around)\n          this.state.previousRandom = nextRandom;\n          break;\n        }\n\n        case ControlCommand.CommandType.SeedRandom:\n          let seed = asOrNull(this.state.PopEvaluationStack(), IntValue);\n          if (seed == null || seed instanceof IntValue === false)\n            return this.Error(\"Invalid value passed to SEED_RANDOM\");\n\n          // Originally a primitive type, but here, can be null.\n          // TODO: Replace by default value?\n          if (seed.value === null) {\n            return throwNullException(\"minInt.value\");\n          }\n\n          this.state.storySeed = seed.value;\n          this.state.previousRandom = 0;\n\n          this.state.PushEvaluationStack(new Void());\n          break;\n\n        case ControlCommand.CommandType.VisitIndex:\n          let count =\n            this.state.VisitCountForContainer(\n              this.state.currentPointer.container\n            ) - 1; // index not count\n          this.state.PushEvaluationStack(new IntValue(count));\n          break;\n\n        case ControlCommand.CommandType.SequenceShuffleIndex:\n          let shuffleIndex = this.NextSequenceShuffleIndex();\n          this.state.PushEvaluationStack(new IntValue(shuffleIndex));\n          break;\n\n        case ControlCommand.CommandType.StartThread:\n          // Handled in main step function\n          break;\n\n        case ControlCommand.CommandType.Done:\n          // We may exist in the context of the initial\n          // act of creating the thread, or in the context of\n          // evaluating the content.\n          if (this.state.callStack.canPopThread) {\n            this.state.callStack.PopThread();\n          }\n\n          // In normal flow - allow safe exit without warning\n          else {\n            this.state.didSafeExit = true;\n\n            // Stop flow in current thread\n            this.state.currentPointer = Pointer.Null;\n          }\n\n          break;\n\n        // Force flow to end completely\n        case ControlCommand.CommandType.End:\n          this.state.ForceEnd();\n          break;\n\n        case ControlCommand.CommandType.ListFromInt:\n          // var intVal = state.PopEvaluationStack () as IntValue;\n          let intVal = asOrNull(this.state.PopEvaluationStack(), IntValue);\n          // var listNameVal = state.PopEvaluationStack () as StringValue;\n          let listNameVal = asOrThrows(\n            this.state.PopEvaluationStack(),\n            StringValue\n          );\n\n          if (intVal === null) {\n            throw new StoryException(\n              \"Passed non-integer when creating a list element from a numerical value.\"\n            );\n          }\n\n          let generatedListValue = null;\n\n          if (this.listDefinitions === null) {\n            return throwNullException(\"this.listDefinitions\");\n          }\n          let foundListDef = this.listDefinitions.TryListGetDefinition(\n            listNameVal.value,\n            null\n          );\n          if (foundListDef.exists) {\n            // Originally a primitive type, but here, can be null.\n            // TODO: Replace by default value?\n            if (intVal.value === null) {\n              return throwNullException(\"minInt.value\");\n            }\n\n            let foundItem = foundListDef.result!.TryGetItemWithValue(\n              intVal.value,\n              InkListItem.Null\n            );\n            if (foundItem.exists) {\n              generatedListValue = new ListValue(\n                foundItem.result!,\n                intVal.value\n              );\n            }\n          } else {\n            throw new StoryException(\n              \"Failed to find LIST called \" + listNameVal.value\n            );\n          }\n\n          if (generatedListValue == null) generatedListValue = new ListValue();\n\n          this.state.PushEvaluationStack(generatedListValue);\n          break;\n\n        case ControlCommand.CommandType.ListRange:\n          let max = asOrNull(this.state.PopEvaluationStack(), Value);\n          let min = asOrNull(this.state.PopEvaluationStack(), Value);\n\n          // var targetList = state.PopEvaluationStack () as ListValue;\n          let targetList = asOrNull(this.state.PopEvaluationStack(), ListValue);\n\n          if (targetList === null || min === null || max === null)\n            throw new StoryException(\n              \"Expected list, minimum and maximum for LIST_RANGE\"\n            );\n\n          if (targetList.value === null) {\n            return throwNullException(\"targetList.value\");\n          }\n          let result = targetList.value.ListWithSubRange(\n            min.valueObject,\n            max.valueObject\n          );\n\n          this.state.PushEvaluationStack(new ListValue(result));\n          break;\n\n        case ControlCommand.CommandType.ListRandom: {\n          let listVal = this.state.PopEvaluationStack() as ListValue;\n          if (listVal === null)\n            throw new StoryException(\"Expected list for LIST_RANDOM\");\n\n          let list = listVal.value;\n\n          let newList: InkList | null = null;\n\n          if (list === null) {\n            throw throwNullException(\"list\");\n          }\n          if (list.Count == 0) {\n            newList = new InkList();\n          } else {\n            // Generate a random index for the element to take\n            let resultSeed = this.state.storySeed + this.state.previousRandom;\n            let random = new PRNG(resultSeed);\n\n            let nextRandom = random.next();\n            let listItemIndex = nextRandom % list.Count;\n\n            // This bit is a little different from the original\n            // C# code, since iterators do not work in the same way.\n            // First, we iterate listItemIndex - 1 times, calling next().\n            // The listItemIndex-th time is made outside of the loop,\n            // in order to retrieve the value.\n            let listEnumerator = list.entries();\n            for (let i = 0; i <= listItemIndex - 1; i++) {\n              listEnumerator.next();\n            }\n            let value = listEnumerator.next().value;\n            let randomItem: KeyValuePair<InkListItem, number> = {\n              Key: InkListItem.fromSerializedKey(value[0]),\n              Value: value[1],\n            };\n\n            // Origin list is simply the origin of the one element\n            if (randomItem.Key.originName === null) {\n              return throwNullException(\"randomItem.Key.originName\");\n            }\n            newList = new InkList(randomItem.Key.originName, this);\n            newList.Add(randomItem.Key, randomItem.Value);\n\n            this.state.previousRandom = nextRandom;\n          }\n\n          this.state.PushEvaluationStack(new ListValue(newList));\n          break;\n        }\n\n        default:\n          this.Error(\"unhandled ControlCommand: \" + evalCommand);\n          break;\n      }\n\n      return true;\n    }\n\n    // Variable assignment\n    else if (contentObj instanceof VariableAssignment) {\n      let varAss = contentObj;\n      let assignedVal = this.state.PopEvaluationStack();\n\n      this.state.variablesState.Assign(varAss, assignedVal);\n\n      return true;\n    }\n\n    // Variable reference\n    else if (contentObj instanceof VariableReference) {\n      let varRef = contentObj;\n      let foundValue = null;\n\n      // Explicit read count value\n      if (varRef.pathForCount != null) {\n        let container = varRef.containerForCount;\n        let count = this.state.VisitCountForContainer(container);\n        foundValue = new IntValue(count);\n      }\n\n      // Normal variable reference\n      else {\n        foundValue = this.state.variablesState.GetVariableWithName(varRef.name);\n\n        if (foundValue == null) {\n          this.Warning(\n            \"Variable not found: '\" +\n              varRef.name +\n              \"'. Using default value of 0 (false). This can happen with temporary variables if the declaration hasn't yet been hit. Globals are always given a default value on load if a value doesn't exist in the save state.\"\n          );\n          foundValue = new IntValue(0);\n        }\n      }\n\n      this.state.PushEvaluationStack(foundValue);\n\n      return true;\n    }\n\n    // Native function call\n    else if (contentObj instanceof NativeFunctionCall) {\n      let func = contentObj;\n      let funcParams = this.state.PopEvaluationStack(func.numberOfParameters);\n      let result = func.Call(funcParams);\n      this.state.PushEvaluationStack(result);\n      return true;\n    }\n\n    // No control content, must be ordinary content\n    return false;\n  }\n\n  public ChoosePathString(\n    path: string,\n    resetCallstack = true,\n    args: any[] = []\n  ) {\n    this.IfAsyncWeCant(\"call ChoosePathString right now\");\n    if (this.onChoosePathString !== null) this.onChoosePathString(path, args);\n\n    if (resetCallstack) {\n      this.ResetCallstack();\n    } else {\n      if (this.state.callStack.currentElement.type == PushPopType.Function) {\n        let funcDetail = \"\";\n        let container = this.state.callStack.currentElement.currentPointer\n          .container;\n        if (container != null) {\n          funcDetail = \"(\" + container.path.toString() + \") \";\n        }\n        throw new Error(\n          \"Story was running a function \" +\n            funcDetail +\n            \"when you called ChoosePathString(\" +\n            path +\n            \") - this is almost certainly not not what you want! Full stack trace: \\n\" +\n            this.state.callStack.callStackTrace\n        );\n      }\n    }\n\n    this.state.PassArgumentsToEvaluationStack(args);\n    this.ChoosePath(new Path(path));\n  }\n\n  public IfAsyncWeCant(activityStr: string) {\n    if (this._asyncContinueActive)\n      throw new Error(\n        \"Can't \" +\n          activityStr +\n          \". Story is in the middle of a ContinueAsync(). Make more ContinueAsync() calls or a single Continue() call beforehand.\"\n      );\n  }\n\n  public ChoosePath(p: Path, incrementingTurnIndex: boolean = true) {\n    this.state.SetChosenPath(p, incrementingTurnIndex);\n\n    // Take a note of newly visited containers for read counts etc\n    this.VisitChangedContainersDueToDivert();\n  }\n\n  public ChooseChoiceIndex(choiceIdx: number) {\n    choiceIdx = choiceIdx;\n    let choices = this.currentChoices;\n    this.Assert(\n      choiceIdx >= 0 && choiceIdx < choices.length,\n      \"choice out of range\"\n    );\n\n    let choiceToChoose = choices[choiceIdx];\n    if (this.onMakeChoice !== null) this.onMakeChoice(choiceToChoose);\n\n    if (choiceToChoose.threadAtGeneration === null) {\n      return throwNullException(\"choiceToChoose.threadAtGeneration\");\n    }\n    if (choiceToChoose.targetPath === null) {\n      return throwNullException(\"choiceToChoose.targetPath\");\n    }\n\n    this.state.callStack.currentThread = choiceToChoose.threadAtGeneration;\n\n    this.ChoosePath(choiceToChoose.targetPath);\n  }\n\n  public HasFunction(functionName: string) {\n    try {\n      return this.KnotContainerWithName(functionName) != null;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  public EvaluateFunction(\n    functionName: string,\n    args: any[] = [],\n    returnTextOutput: boolean = false\n  ): Story.EvaluateFunctionTextOutput | any {\n    // EvaluateFunction behaves slightly differently than the C# version.\n    // In C#, you can pass a (second) parameter `out textOutput` to get the\n    // text outputted by the function. This is not possible in js. Instead,\n    // we maintain the regular signature (functionName, args), plus an\n    // optional third parameter returnTextOutput. If set to true, we will\n    // return both the textOutput and the returned value, as an object.\n\n    if (this.onEvaluateFunction !== null)\n      this.onEvaluateFunction(functionName, args);\n\n    this.IfAsyncWeCant(\"evaluate a function\");\n\n    if (functionName == null) {\n      throw new Error(\"Function is null\");\n    } else if (functionName == \"\" || functionName.trim() == \"\") {\n      throw new Error(\"Function is empty or white space.\");\n    }\n\n    let funcContainer = this.KnotContainerWithName(functionName);\n    if (funcContainer == null) {\n      throw new Error(\"Function doesn't exist: '\" + functionName + \"'\");\n    }\n\n    let outputStreamBefore: InkObject[] = [];\n    outputStreamBefore.push(...this.state.outputStream);\n    this._state.ResetOutput();\n\n    this.state.StartFunctionEvaluationFromGame(funcContainer, args);\n\n    // Evaluate the function, and collect the string output\n    let stringOutput = new StringBuilder();\n    while (this.canContinue) {\n      stringOutput.Append(this.Continue());\n    }\n    let textOutput = stringOutput.toString();\n\n    this._state.ResetOutput(outputStreamBefore);\n\n    let result = this.state.CompleteFunctionEvaluationFromGame();\n    if (this.onCompleteEvaluateFunction != null)\n      this.onCompleteEvaluateFunction(functionName, args, textOutput, result);\n\n    return returnTextOutput ? { returned: result, output: textOutput } : result;\n  }\n\n  public EvaluateExpression(exprContainer: Container) {\n    let startCallStackHeight = this.state.callStack.elements.length;\n\n    this.state.callStack.Push(PushPopType.Tunnel);\n\n    this._temporaryEvaluationContainer = exprContainer;\n\n    this.state.GoToStart();\n\n    let evalStackHeight = this.state.evaluationStack.length;\n\n    this.Continue();\n\n    this._temporaryEvaluationContainer = null;\n\n    // Should have fallen off the end of the Container, which should\n    // have auto-popped, but just in case we didn't for some reason,\n    // manually pop to restore the state (including currentPath).\n    if (this.state.callStack.elements.length > startCallStackHeight) {\n      this.state.PopCallStack();\n    }\n\n    let endStackHeight = this.state.evaluationStack.length;\n    if (endStackHeight > evalStackHeight) {\n      return this.state.PopEvaluationStack();\n    } else {\n      return null;\n    }\n  }\n\n  public allowExternalFunctionFallbacks: boolean = false;\n\n  public CallExternalFunction(\n    funcName: string | null,\n    numberOfArguments: number\n  ) {\n    if (funcName === null) {\n      return throwNullException(\"funcName\");\n    }\n    let funcDef = this._externals.get(funcName);\n    let fallbackFunctionContainer = null;\n\n    let foundExternal = typeof funcDef !== \"undefined\";\n\n    if (\n      foundExternal &&\n      !funcDef!.lookAheadSafe &&\n      this._stateSnapshotAtLastNewline !== null\n    ) {\n      this._sawLookaheadUnsafeFunctionAfterNewline = true;\n      return;\n    }\n\n    if (!foundExternal) {\n      if (this.allowExternalFunctionFallbacks) {\n        fallbackFunctionContainer = this.KnotContainerWithName(funcName);\n        this.Assert(\n          fallbackFunctionContainer !== null,\n          \"Trying to call EXTERNAL function '\" +\n            funcName +\n            \"' which has not been bound, and fallback ink function could not be found.\"\n        );\n\n        // Divert direct into fallback function and we're done\n        this.state.callStack.Push(\n          PushPopType.Function,\n          undefined,\n          this.state.outputStream.length\n        );\n        this.state.divertedPointer = Pointer.StartOf(fallbackFunctionContainer);\n        return;\n      } else {\n        this.Assert(\n          false,\n          \"Trying to call EXTERNAL function '\" +\n            funcName +\n            \"' which has not been bound (and ink fallbacks disabled).\"\n        );\n      }\n    }\n\n    // Pop arguments\n    let args: any[] = [];\n    for (let i = 0; i < numberOfArguments; ++i) {\n      // var poppedObj = state.PopEvaluationStack () as Value;\n      let poppedObj = asOrThrows(this.state.PopEvaluationStack(), Value);\n      let valueObj = poppedObj.valueObject;\n      args.push(valueObj);\n    }\n\n    // Reverse arguments from the order they were popped,\n    // so they're the right way round again.\n    args.reverse();\n\n    // Run the function!\n    let funcResult = funcDef!.function(args);\n\n    // Convert return value (if any) to the a type that the ink engine can use\n    let returnObj = null;\n    if (funcResult != null) {\n      returnObj = Value.Create(funcResult);\n      this.Assert(\n        returnObj !== null,\n        \"Could not create ink value from returned object of type \" +\n          typeof funcResult\n      );\n    } else {\n      returnObj = new Void();\n    }\n\n    this.state.PushEvaluationStack(returnObj);\n  }\n\n  public BindExternalFunctionGeneral(\n    funcName: string,\n    func: Story.ExternalFunction,\n    lookaheadSafe: boolean\n  ) {\n    this.IfAsyncWeCant(\"bind an external function\");\n    this.Assert(\n      !this._externals.has(funcName),\n      \"Function '\" + funcName + \"' has already been bound.\"\n    );\n    this._externals.set(funcName, {\n      function: func,\n      lookAheadSafe: lookaheadSafe,\n    });\n  }\n\n  public TryCoerce(value: any) {\n    // We're skipping type coercition in this implementation. First of, js\n    // is loosely typed, so it's not that important. Secondly, there is no\n    // clean way (AFAIK) for the user to describe what type of parameters\n    // they expect.\n    return value;\n  }\n\n  public BindExternalFunction(\n    funcName: string,\n    func: Story.ExternalFunction,\n    lookaheadSafe: boolean\n  ) {\n    this.Assert(func != null, \"Can't bind a null function\");\n\n    this.BindExternalFunctionGeneral(\n      funcName,\n      (args: any) => {\n        this.Assert(\n          args.length >= func.length,\n          \"External function expected \" + func.length + \" arguments\"\n        );\n\n        let coercedArgs = [];\n        for (let i = 0, l = args.length; i < l; i++) {\n          coercedArgs[i] = this.TryCoerce(args[i]);\n        }\n        return func.apply(null, coercedArgs);\n      },\n      lookaheadSafe\n    );\n  }\n\n  public UnbindExternalFunction(funcName: string) {\n    this.IfAsyncWeCant(\"unbind an external a function\");\n    this.Assert(\n      this._externals.has(funcName),\n      \"Function '\" + funcName + \"' has not been bound.\"\n    );\n    this._externals.delete(funcName);\n  }\n\n  public ValidateExternalBindings(): void;\n  public ValidateExternalBindings(\n    c: Container | null,\n    missingExternals: Set<string>\n  ): void;\n  public ValidateExternalBindings(\n    o: InkObject | null,\n    missingExternals: Set<string>\n  ): void;\n  public ValidateExternalBindings() {\n    let c: Container | null = null;\n    let o: InkObject | null = null;\n    let missingExternals: Set<string> = arguments[1] || new Set();\n\n    if (arguments[0] instanceof Container) {\n      c = arguments[0];\n    }\n\n    if (arguments[0] instanceof InkObject) {\n      o = arguments[0];\n    }\n\n    if (c === null && o === null) {\n      this.ValidateExternalBindings(\n        this._mainContentContainer,\n        missingExternals\n      );\n      this._hasValidatedExternals = true;\n\n      // No problem! Validation complete\n      if (missingExternals.size == 0) {\n        this._hasValidatedExternals = true;\n      } else {\n        let message = \"Error: Missing function binding for external\";\n        message += missingExternals.size > 1 ? \"s\" : \"\";\n        message += \": '\";\n        message += Array.from(missingExternals).join(\"', '\");\n        message += \"' \";\n        message += this.allowExternalFunctionFallbacks\n          ? \", and no fallback ink function found.\"\n          : \" (ink fallbacks disabled)\";\n\n        this.Error(message);\n      }\n    } else if (c != null) {\n      for (let innerContent of c.content) {\n        let container = innerContent as Container;\n        if (container == null || !container.hasValidName)\n          this.ValidateExternalBindings(innerContent, missingExternals);\n      }\n      for (let [, value] of c.namedContent) {\n        this.ValidateExternalBindings(\n          asOrNull(value, InkObject),\n          missingExternals\n        );\n      }\n    } else if (o != null) {\n      let divert = asOrNull(o, Divert);\n      if (divert && divert.isExternal) {\n        let name = divert.targetPathString;\n        if (name === null) {\n          return throwNullException(\"name\");\n        }\n        if (!this._externals.has(name)) {\n          if (this.allowExternalFunctionFallbacks) {\n            let fallbackFound = this.mainContentContainer.namedContent.has(\n              name\n            );\n            if (!fallbackFound) {\n              missingExternals.add(name);\n            }\n          } else {\n            missingExternals.add(name);\n          }\n        }\n      }\n    }\n  }\n\n  public ObserveVariable(\n    variableName: string,\n    observer: Story.VariableObserver\n  ) {\n    this.IfAsyncWeCant(\"observe a new variable\");\n\n    if (this._variableObservers === null) this._variableObservers = new Map();\n\n    if (!this.state.variablesState.GlobalVariableExistsWithName(variableName))\n      throw new Error(\n        \"Cannot observe variable '\" +\n          variableName +\n          \"' because it wasn't declared in the ink story.\"\n      );\n\n    if (this._variableObservers.has(variableName)) {\n      this._variableObservers.get(variableName)!.push(observer);\n    } else {\n      this._variableObservers.set(variableName, [observer]);\n    }\n  }\n\n  public ObserveVariables(\n    variableNames: string[],\n    observers: Story.VariableObserver[]\n  ) {\n    for (let i = 0, l = variableNames.length; i < l; i++) {\n      this.ObserveVariable(variableNames[i], observers[i]);\n    }\n  }\n\n  public RemoveVariableObserver(\n    observer?: Story.VariableObserver,\n    specificVariableName?: string\n  ) {\n    // A couple of things to know about this method:\n    //\n    // 1. Since `RemoveVariableObserver` is exposed to the JavaScript world,\n    //    optionality is marked as `undefined` rather than `null`.\n    //    To keep things simple, null-checks are performed using regular\n    //    equality operators, where undefined == null.\n    //\n    // 2. Since C# delegates are translated to arrays of functions,\n    //    -= becomes a call to splice and null-checks are replaced by\n    //    emptiness-checks.\n    //\n    this.IfAsyncWeCant(\"remove a variable observer\");\n\n    if (this._variableObservers === null) return;\n\n    if (specificVariableName != null) {\n      if (this._variableObservers.has(specificVariableName)) {\n        if (observer != null) {\n          let variableObservers = this._variableObservers.get(\n            specificVariableName\n          );\n          if (variableObservers != null) {\n            variableObservers.splice(variableObservers.indexOf(observer), 1);\n            if (variableObservers.length === 0) {\n              this._variableObservers.delete(specificVariableName);\n            }\n          }\n        } else {\n          this._variableObservers.delete(specificVariableName);\n        }\n      }\n    } else if (observer != null) {\n      let keys = this._variableObservers.keys();\n      for (let varName of keys) {\n        let variableObservers = this._variableObservers.get(varName);\n        if (variableObservers != null) {\n          variableObservers.splice(variableObservers.indexOf(observer), 1);\n          if (variableObservers.length === 0) {\n            this._variableObservers.delete(varName);\n          }\n        }\n      }\n    }\n  }\n\n  public VariableStateDidChangeEvent(\n    variableName: string,\n    newValueObj: InkObject\n  ) {\n    if (this._variableObservers === null) return;\n\n    let observers = this._variableObservers.get(variableName);\n    if (typeof observers !== \"undefined\") {\n      if (!(newValueObj instanceof Value)) {\n        throw new Error(\n          \"Tried to get the value of a variable that isn't a standard type\"\n        );\n      }\n      // var val = newValueObj as Value;\n      let val = asOrThrows(newValueObj, Value);\n\n      for (let observer of observers) {\n        observer(variableName, val.valueObject);\n      }\n    }\n  }\n\n  get globalTags() {\n    return this.TagsAtStartOfFlowContainerWithPathString(\"\");\n  }\n\n  public TagsForContentAtPath(path: string) {\n    return this.TagsAtStartOfFlowContainerWithPathString(path);\n  }\n\n  public TagsAtStartOfFlowContainerWithPathString(pathString: string) {\n    let path = new Path(pathString);\n\n    let flowContainer = this.ContentAtPath(path).container;\n    if (flowContainer === null) {\n      return throwNullException(\"flowContainer\");\n    }\n    while (true) {\n      let firstContent: InkObject = flowContainer.content[0];\n      if (firstContent instanceof Container) flowContainer = firstContent;\n      else break;\n    }\n\n    let tags: string[] | null = null;\n\n    for (let c of flowContainer.content) {\n      // var tag = c as Runtime.Tag;\n      let tag = asOrNull(c, Tag);\n      if (tag) {\n        if (tags == null) tags = [];\n        tags.push(tag.text);\n      } else break;\n    }\n\n    return tags;\n  }\n\n  public BuildStringOfHierarchy() {\n    let sb = new StringBuilder();\n\n    this.mainContentContainer.BuildStringOfHierarchy(\n      sb,\n      0,\n      this.state.currentPointer.Resolve()\n    );\n\n    return sb.toString();\n  }\n\n  public BuildStringOfContainer(container: Container) {\n    let sb = new StringBuilder();\n    container.BuildStringOfHierarchy(\n      sb,\n      0,\n      this.state.currentPointer.Resolve()\n    );\n    return sb.toString();\n  }\n\n  public NextContent() {\n    this.state.previousPointer = this.state.currentPointer.copy();\n\n    if (!this.state.divertedPointer.isNull) {\n      this.state.currentPointer = this.state.divertedPointer.copy();\n      this.state.divertedPointer = Pointer.Null;\n\n      this.VisitChangedContainersDueToDivert();\n\n      if (!this.state.currentPointer.isNull) {\n        return;\n      }\n    }\n\n    let successfulPointerIncrement = this.IncrementContentPointer();\n\n    if (!successfulPointerIncrement) {\n      let didPop = false;\n\n      if (this.state.callStack.CanPop(PushPopType.Function)) {\n        this.state.PopCallStack(PushPopType.Function);\n\n        if (this.state.inExpressionEvaluation) {\n          this.state.PushEvaluationStack(new Void());\n        }\n\n        didPop = true;\n      } else if (this.state.callStack.canPopThread) {\n        this.state.callStack.PopThread();\n\n        didPop = true;\n      } else {\n        this.state.TryExitFunctionEvaluationFromGame();\n      }\n\n      if (didPop && !this.state.currentPointer.isNull) {\n        this.NextContent();\n      }\n    }\n  }\n\n  public IncrementContentPointer() {\n    let successfulIncrement = true;\n\n    let pointer = this.state.callStack.currentElement.currentPointer.copy();\n    pointer.index++;\n\n    if (pointer.container === null) {\n      return throwNullException(\"pointer.container\");\n    }\n    while (pointer.index >= pointer.container.content.length) {\n      successfulIncrement = false;\n\n      // Container nextAncestor = pointer.container.parent as Container;\n      let nextAncestor = asOrNull(pointer.container.parent, Container);\n      if (nextAncestor instanceof Container === false) {\n        break;\n      }\n\n      let indexInAncestor = nextAncestor!.content.indexOf(pointer.container);\n      if (indexInAncestor == -1) {\n        break;\n      }\n\n      pointer = new Pointer(nextAncestor, indexInAncestor);\n\n      pointer.index++;\n\n      successfulIncrement = true;\n      if (pointer.container === null) {\n        return throwNullException(\"pointer.container\");\n      }\n    }\n\n    if (!successfulIncrement) pointer = Pointer.Null;\n\n    this.state.callStack.currentElement.currentPointer = pointer.copy();\n\n    return successfulIncrement;\n  }\n\n  public TryFollowDefaultInvisibleChoice() {\n    let allChoices = this._state.currentChoices;\n\n    let invisibleChoices = allChoices.filter((c) => c.isInvisibleDefault);\n\n    if (\n      invisibleChoices.length == 0 ||\n      allChoices.length > invisibleChoices.length\n    )\n      return false;\n\n    let choice = invisibleChoices[0];\n\n    if (choice.targetPath === null) {\n      return throwNullException(\"choice.targetPath\");\n    }\n\n    if (choice.threadAtGeneration === null) {\n      return throwNullException(\"choice.threadAtGeneration\");\n    }\n\n    this.state.callStack.currentThread = choice.threadAtGeneration;\n\n    if (this._stateSnapshotAtLastNewline !== null) {\n      this.state.callStack.currentThread = this.state.callStack.ForkThread();\n    }\n\n    this.ChoosePath(choice.targetPath, false);\n\n    return true;\n  }\n\n  public NextSequenceShuffleIndex() {\n    // var numElementsIntVal = state.PopEvaluationStack () as IntValue;\n    let numElementsIntVal = asOrNull(this.state.PopEvaluationStack(), IntValue);\n    if (!(numElementsIntVal instanceof IntValue)) {\n      this.Error(\"expected number of elements in sequence for shuffle index\");\n      return 0;\n    }\n\n    let seqContainer = this.state.currentPointer.container;\n    if (seqContainer === null) {\n      return throwNullException(\"seqContainer\");\n    }\n\n    // Originally a primitive type, but here, can be null.\n    // TODO: Replace by default value?\n    if (numElementsIntVal.value === null) {\n      return throwNullException(\"numElementsIntVal.value\");\n    }\n    let numElements = numElementsIntVal.value;\n\n    // var seqCountVal = state.PopEvaluationStack () as IntValue;\n    let seqCountVal = asOrThrows(this.state.PopEvaluationStack(), IntValue);\n    let seqCount = seqCountVal.value;\n\n    // Originally a primitive type, but here, can be null.\n    // TODO: Replace by default value?\n    if (seqCount === null) {\n      return throwNullException(\"seqCount\");\n    }\n\n    let loopIndex = seqCount / numElements;\n    let iterationIndex = seqCount % numElements;\n\n    let seqPathStr = seqContainer.path.toString();\n    let sequenceHash = 0;\n    for (let i = 0, l = seqPathStr.length; i < l; i++) {\n      sequenceHash += seqPathStr.charCodeAt(i) || 0;\n    }\n    let randomSeed = sequenceHash + loopIndex + this.state.storySeed;\n    let random = new PRNG(Math.floor(randomSeed));\n\n    let unpickedIndices = [];\n    for (let i = 0; i < numElements; ++i) {\n      unpickedIndices.push(i);\n    }\n\n    for (let i = 0; i <= iterationIndex; ++i) {\n      let chosen = random.next() % unpickedIndices.length;\n      let chosenIndex = unpickedIndices[chosen];\n      unpickedIndices.splice(chosen, 1);\n\n      if (i == iterationIndex) {\n        return chosenIndex;\n      }\n    }\n\n    throw new Error(\"Should never reach here\");\n  }\n\n  public Error(message: string, useEndLineNumber = false): never {\n    let e = new StoryException(message);\n    e.useEndLineNumber = useEndLineNumber;\n    throw e;\n  }\n\n  public Warning(message: string) {\n    this.AddError(message, true);\n  }\n\n  public AddError(\n    message: string,\n    isWarning = false,\n    useEndLineNumber = false\n  ) {\n    let dm = this.currentDebugMetadata;\n\n    let errorTypeStr = isWarning ? \"WARNING\" : \"ERROR\";\n\n    if (dm != null) {\n      let lineNum = useEndLineNumber ? dm.endLineNumber : dm.startLineNumber;\n      message =\n        \"RUNTIME \" +\n        errorTypeStr +\n        \": '\" +\n        dm.fileName +\n        \"' line \" +\n        lineNum +\n        \": \" +\n        message;\n    } else if (!this.state.currentPointer.isNull) {\n      message =\n        \"RUNTIME \" +\n        errorTypeStr +\n        \": (\" +\n        this.state.currentPointer +\n        \"): \" +\n        message;\n    } else {\n      message = \"RUNTIME \" + errorTypeStr + \": \" + message;\n    }\n\n    this.state.AddError(message, isWarning);\n\n    // In a broken state don't need to know about any other errors.\n    if (!isWarning) this.state.ForceEnd();\n  }\n\n  public Assert(condition: boolean, message: string | null = null) {\n    if (condition == false) {\n      if (message == null) {\n        message = \"Story assert\";\n      }\n\n      throw new Error(message + \" \" + this.currentDebugMetadata);\n    }\n  }\n\n  get currentDebugMetadata(): DebugMetadata | null {\n    let dm: DebugMetadata | null;\n\n    let pointer = this.state.currentPointer;\n    if (!pointer.isNull && pointer.Resolve() !== null) {\n      dm = pointer.Resolve()!.debugMetadata;\n      if (dm !== null) {\n        return dm;\n      }\n    }\n\n    for (let i = this.state.callStack.elements.length - 1; i >= 0; --i) {\n      pointer = this.state.callStack.elements[i].currentPointer;\n      if (!pointer.isNull && pointer.Resolve() !== null) {\n        dm = pointer.Resolve()!.debugMetadata;\n        if (dm !== null) {\n          return dm;\n        }\n      }\n    }\n\n    for (let i = this.state.outputStream.length - 1; i >= 0; --i) {\n      let outputObj = this.state.outputStream[i];\n      dm = outputObj.debugMetadata;\n      if (dm !== null) {\n        return dm;\n      }\n    }\n\n    return null;\n  }\n\n  get mainContentContainer() {\n    if (this._temporaryEvaluationContainer) {\n      return this._temporaryEvaluationContainer;\n    } else {\n      return this._mainContentContainer;\n    }\n  }\n\n  /**\n   * `_mainContentContainer` is almost guaranteed to be set in the\n   * constructor, unless the json is malformed.\n   */\n  private _mainContentContainer!: Container;\n  private _listDefinitions: ListDefinitionsOrigin | null = null;\n\n  private _externals: Map<string, Story.ExternalFunctionDef>;\n  private _variableObservers: Map<\n    string,\n    Story.VariableObserver[]\n  > | null = null;\n  private _hasValidatedExternals: boolean = false;\n\n  private _temporaryEvaluationContainer: Container | null = null;\n\n  /**\n   * `state` is almost guaranteed to be set in the constructor, unless\n   * using the compiler-specific constructor which will likely not be used in\n   * the real world.\n   */\n  private _state!: StoryState;\n\n  private _asyncContinueActive: boolean = false;\n  private _stateSnapshotAtLastNewline: StoryState | null = null;\n  private _sawLookaheadUnsafeFunctionAfterNewline: boolean = false;\n\n  private _recursiveContinueCount: number = 0;\n\n  private _asyncSaving: boolean = false;\n\n  private _profiler: any | null = null; // TODO: Profiler\n}\n\nexport namespace Story {\n  export enum OutputStateChange {\n    NoChange = 0,\n    ExtendedBeyondNewline = 1,\n    NewlineRemoved = 2,\n  }\n\n  export interface EvaluateFunctionTextOutput {\n    returned: any;\n    output: string;\n  }\n\n  export interface ExternalFunctionDef {\n    function: ExternalFunction;\n    lookAheadSafe: boolean;\n  }\n\n  export type VariableObserver = (variableName: string, newValue: any) => void;\n  export type ExternalFunction = (...args: any) => any;\n}\n","import { AuthorWarning } from \"./AuthorWarning\";\nimport { ConstantDeclaration } from \"./Declaration/ConstantDeclaration\";\nimport { Container as RuntimeContainer } from \"../../../engine/Container\";\nimport { ControlCommand as RuntimeControlCommand } from \"../../../engine/ControlCommand\";\nimport { ErrorHandler } from \"../../../engine/Error\";\nimport { ErrorType } from \"../ErrorType\";\nimport { Expression } from \"./Expression/Expression\";\nimport { ExternalDeclaration } from \"./Declaration/ExternalDeclaration\";\nimport { FlowBase } from \"./Flow/FlowBase\";\nimport { FlowLevel } from \"./Flow/FlowLevel\";\nimport { IncludedFile } from \"./IncludedFile\";\nimport { ListDefinition } from \"./List/ListDefinition\";\nimport { ListElementDefinition } from \"./List/ListElementDefinition\";\nimport { ParsedObject } from \"./Object\";\nimport { Story as RuntimeStory } from \"../../../engine/Story\";\nimport { SymbolType } from \"./SymbolType\";\nimport { Text } from \"./Text\";\nimport { VariableAssignment as RuntimeVariableAssignment } from \"../../../engine/VariableAssignment\";\nimport { Identifier } from \"./Identifier\";\nimport { asOrNull } from \"../../../engine/TypeAssertion\";\nimport { ClosestFlowBase } from \"./Flow/ClosestFlowBase\";\nimport { FunctionCall } from \"./FunctionCall\";\nimport { Path } from \"./Path\";\nimport { VariableAssignment } from \"./Variable/VariableAssignment\";\n\nexport class Story extends FlowBase {\n  public static readonly IsReservedKeyword = (name?: string): boolean => {\n    switch (name) {\n      case \"true\":\n      case \"false\":\n      case \"not\":\n      case \"return\":\n      case \"else\":\n      case \"VAR\":\n      case \"CONST\":\n      case \"temp\":\n      case \"LIST\":\n      case \"function\":\n        return true;\n    }\n\n    return false;\n  };\n\n  private _errorHandler: ErrorHandler | null = null;\n  private _hadError: boolean = false;\n  private _hadWarning: boolean = false;\n  private _dontFlattenContainers: Set<RuntimeContainer> = new Set();\n  private _listDefs: Map<string, ListDefinition> = new Map();\n\n  get flowLevel(): FlowLevel {\n    return FlowLevel.Story;\n  }\n\n  get hadError(): boolean {\n    return this._hadError;\n  }\n\n  get hadWarning(): boolean {\n    return this._hadWarning;\n  }\n\n  public constants: Map<string, Expression> = new Map();\n  public externals: Map<string, ExternalDeclaration> = new Map();\n\n  // Build setting for exporting:\n  // When true, the visit count for *all* knots, stitches, choices,\n  // and gathers is counted. When false, only those that are direclty\n  // referenced by the ink are recorded. Use this flag to allow game-side\n  // querying of  arbitrary knots/stitches etc.\n  // Storing all counts is more robust and future proof (updates to the story file\n  // that reference previously uncounted visits are possible, but generates a much\n  // larger safe file, with a lot of potentially redundant counts.\n  public countAllVisits: boolean = false;\n\n  constructor(toplevelObjects: ParsedObject[], isInclude: boolean = false) {\n    // Don't do anything much on construction, leave it lightweight until\n    // the ExportRuntime method is called.\n    super(null, toplevelObjects, null, false, isInclude);\n  }\n\n  get typeName(): string {\n    return \"Story\";\n  }\n\n  // Before this function is called, we have IncludedFile objects interspersed\n  // in our content wherever an include statement was.\n  // So that the include statement can be added in a sensible place (e.g. the\n  // top of the file) without side-effects of jumping into a knot that was\n  // defined in that include, we separate knots and stitches from anything\n  // else defined at the top scope of the included file.\n  //\n  // Algorithm: For each IncludedFile we find, split its contents into\n  // knots/stiches and any other content. Insert the normal content wherever\n  // the include statement was, and append the knots/stitches to the very\n  // end of the main story.\n  public PreProcessTopLevelObjects(topLevelContent: ParsedObject[]): void {\n    super.PreProcessTopLevelObjects(topLevelContent);\n\n    const flowsFromOtherFiles = [];\n\n    // Inject included files\n    for (let obj of topLevelContent) {\n      if (obj instanceof IncludedFile) {\n        const file: IncludedFile = obj;\n\n        // Remove the IncludedFile itself\n        const posOfObj = topLevelContent.indexOf(obj);\n        topLevelContent.splice(posOfObj, 1);\n\n        // When an included story fails to load, the include\n        // line itself is still valid, so we have to handle it here\n        if (file.includedStory) {\n          const nonFlowContent: ParsedObject[] = [];\n          const subStory = file.includedStory;\n          // Allow empty file\n          if (subStory.content != null) {\n            for (const subStoryObj of subStory.content) {\n              if (subStoryObj instanceof FlowBase) {\n                flowsFromOtherFiles.push(subStoryObj);\n              } else {\n                nonFlowContent.push(subStoryObj);\n              }\n            }\n\n            // Add newline on the end of the include\n            nonFlowContent.push(new Text(\"\\n\"));\n\n            // Add contents of the file in its place\n            topLevelContent.splice(posOfObj, 0, ...nonFlowContent);\n\n            // Skip past the content of this sub story\n            // (since it will already have recursively included\n            //  any lines from other files)\n          }\n        }\n\n        // Include object has been removed, with possible content inserted,\n        // and position of 'i' will have been determined already.\n        continue;\n      }\n    }\n\n    // Add the flows we collected from the included files to the\n    // end of our list of our content\n    topLevelContent.splice(0, 0, ...flowsFromOtherFiles);\n  }\n\n  public readonly ExportRuntime = (\n    errorHandler: ErrorHandler | null = null\n  ): RuntimeStory | null => {\n    this._errorHandler = errorHandler;\n\n    // Find all constants before main export begins, so that VariableReferences know\n    // whether to generate a runtime variable reference or the literal value\n    this.constants = new Map();\n    for (const constDecl of this.FindAll(ConstantDeclaration)()) {\n      // Check for duplicate definitions\n      const existingDefinition:\n        | ConstantDeclaration\n        | null\n        | undefined = this.constants.get(constDecl.constantName!) as any;\n\n      if (existingDefinition) {\n        const runObj = existingDefinition.GenerateRuntimeObject() || {\n          Equals: () => false,\n        };\n        if (!runObj.Equals(constDecl.expression)) {\n          const errorMsg = `CONST '${constDecl.constantName}' has been redefined with a different value. Multiple definitions of the same CONST are valid so long as they contain the same value. Initial definition was on ${existingDefinition.debugMetadata}.`;\n          this.Error(errorMsg, constDecl, false);\n        }\n      }\n\n      this.constants.set(constDecl.constantName!, constDecl.expression);\n    }\n\n    // List definitions are treated like constants too - they should be usable\n    // from other variable declarations.\n    this._listDefs = new Map();\n    for (const listDef of this.FindAll<ListDefinition>(ListDefinition)()) {\n      if (listDef.identifier?.name) {\n        this._listDefs.set(listDef.identifier?.name, listDef);\n      }\n    }\n\n    this.externals = new Map();\n\n    // Resolution of weave point names has to come first, before any runtime code generation\n    // since names have to be ready before diverts start getting created.\n    // (It used to be done in the constructor for a weave, but didn't allow us to generate\n    // errors when name resolution failed.)\n    this.ResolveWeavePointNaming();\n\n    // Get default implementation of runtimeObject, which calls ContainerBase's generation method\n    const rootContainer = this.runtimeObject as RuntimeContainer;\n\n    // Export initialisation of global variables\n    // TODO: We *could* add this as a declarative block to the story itself...\n    const variableInitialisation = new RuntimeContainer();\n    variableInitialisation.AddContent(RuntimeControlCommand.EvalStart());\n\n    // Global variables are those that are local to the story and marked as global\n    const runtimeLists = [];\n    for (const [key, value] of this.variableDeclarations) {\n      if (value.isGlobalDeclaration) {\n        if (value.listDefinition) {\n          this._listDefs.set(key, value.listDefinition);\n          variableInitialisation.AddContent(\n            value.listDefinition.runtimeObject!\n          );\n\n          runtimeLists.push(value.listDefinition.runtimeListDefinition);\n        } else {\n          if (!value.expression) {\n            throw new Error();\n          }\n          value.expression.GenerateIntoContainer(variableInitialisation);\n        }\n\n        const runtimeVarAss = new RuntimeVariableAssignment(key, true);\n        runtimeVarAss.isGlobal = true;\n        variableInitialisation.AddContent(runtimeVarAss);\n      }\n    }\n\n    variableInitialisation.AddContent(RuntimeControlCommand.EvalEnd());\n    variableInitialisation.AddContent(RuntimeControlCommand.End());\n\n    if (this.variableDeclarations.size > 0) {\n      variableInitialisation.name = \"global decl\";\n      rootContainer.AddToNamedContentOnly(variableInitialisation);\n    }\n\n    // Signal that it's safe to exit without error, even if there are no choices generated\n    // (this only happens at the end of top level content that isn't in any particular knot)\n    rootContainer.AddContent(RuntimeControlCommand.Done());\n\n    // Replace runtimeObject with Story object instead of the Runtime.Container generated by Parsed.ContainerBase\n    const runtimeStory = new RuntimeStory(rootContainer, runtimeLists);\n\n    this.runtimeObject = runtimeStory;\n\n    if (this.hadError) {\n      return null;\n    }\n\n    // Optimisation step - inline containers that can be\n    this.FlattenContainersIn(rootContainer);\n\n    // Now that the story has been fulled parsed into a hierarchy,\n    // and the derived runtime hierarchy has been built, we can\n    // resolve referenced symbols such as variables and paths.\n    // e.g. for paths \" -> knotName --> stitchName\" into an INKPath (knotName.stitchName)\n    // We don't make any assumptions that the INKPath follows the same\n    // conventions as the script format, so we resolve to actual objects before\n    // translating into an INKPath. (This also allows us to choose whether\n    // we want the paths to be absolute)\n    this.ResolveReferences(this);\n\n    if (this.hadError) {\n      return null;\n    }\n\n    runtimeStory.ResetState();\n\n    return runtimeStory;\n  };\n\n  public readonly ResolveList = (listName: string): ListDefinition | null => {\n    let list: ListDefinition | null | undefined = this._listDefs.get(listName);\n    if (!list) {\n      return null;\n    }\n\n    return list;\n  };\n\n  public readonly ResolveListItem = (\n    listName: string | null,\n    itemName: string,\n    source: ParsedObject | null = null\n  ): ListElementDefinition | null => {\n    let listDef: ListDefinition | null | undefined = null;\n\n    // Search a specific list if we know its name (i.e. the form listName.itemName)\n    if (listName) {\n      if (!(listDef = this._listDefs.get(listName))) {\n        return null;\n      }\n\n      return listDef.ItemNamed(itemName);\n    } else {\n      // Otherwise, try to search all lists\n\n      let foundItem: ListElementDefinition | null = null;\n      let originalFoundList: ListDefinition | null = null;\n\n      for (const [_, value] of this._listDefs.entries()) {\n        const itemInThisList = value.ItemNamed(itemName);\n        if (itemInThisList) {\n          if (foundItem) {\n            this.Error(\n              `Ambiguous item name '${itemName}' found in multiple sets, including ${\n                originalFoundList!.identifier\n              } and ${value!.identifier}`,\n              source,\n              false\n            );\n          } else {\n            foundItem = itemInThisList;\n            originalFoundList = value!;\n          }\n        }\n      }\n\n      return foundItem;\n    }\n  };\n\n  public readonly FlattenContainersIn = (container: RuntimeContainer): void => {\n    // Need to create a collection to hold the inner containers\n    // because otherwise we'd end up modifying during iteration\n    const innerContainers = new Set<RuntimeContainer>();\n    if (container.content) {\n      for (const c of container.content) {\n        const innerContainer = asOrNull(c, RuntimeContainer);\n        if (innerContainer) {\n          innerContainers.add(innerContainer);\n        }\n      }\n    }\n\n    // Can't flatten the named inner containers, but we can at least\n    // iterate through their children\n    if (container.namedContent) {\n      for (const [_, value] of container.namedContent) {\n        const namedInnerContainer = asOrNull(value, RuntimeContainer);\n        if (namedInnerContainer) {\n          innerContainers.add(namedInnerContainer);\n        }\n      }\n    }\n\n    for (const innerContainer of innerContainers) {\n      this.TryFlattenContainer(innerContainer);\n      this.FlattenContainersIn(innerContainer);\n    }\n  };\n\n  public readonly TryFlattenContainer = (container: RuntimeContainer): void => {\n    if (\n      (container.namedContent && container.namedContent.size > 0) ||\n      container.hasValidName ||\n      this._dontFlattenContainers.has(container)\n    ) {\n      return;\n    }\n\n    // Inline all the content in container into the parent\n    const parentContainer = asOrNull(container.parent, RuntimeContainer);\n    if (parentContainer) {\n      let contentIdx = parentContainer.content.indexOf(container);\n      parentContainer.content.splice(contentIdx, 1);\n\n      const dm = container.ownDebugMetadata;\n\n      if (container.content) {\n        for (const innerContent of container.content) {\n          innerContent.parent = null;\n          if (dm !== null && innerContent.ownDebugMetadata === null) {\n            innerContent.debugMetadata = dm;\n          }\n\n          parentContainer.InsertContent(innerContent, contentIdx);\n          contentIdx += 1;\n        }\n      }\n    }\n  };\n\n  public readonly Error = (\n    message: string,\n    source: ParsedObject | null | undefined,\n    isWarning: boolean | null | undefined\n  ) => {\n    let errorType: ErrorType = isWarning ? ErrorType.Warning : ErrorType.Error;\n\n    let sb = \"\";\n    if (source instanceof AuthorWarning) {\n      sb += \"TODO: \";\n      errorType = ErrorType.Author;\n    } else if (isWarning) {\n      sb += \"WARNING: \";\n    } else {\n      sb += \"ERROR: \";\n    }\n\n    if (\n      source &&\n      source.debugMetadata !== null &&\n      source.debugMetadata.startLineNumber >= 1\n    ) {\n      if (source.debugMetadata.fileName != null) {\n        sb += `'${source.debugMetadata.fileName}' `;\n      }\n\n      sb += `line ${source.debugMetadata.startLineNumber}: `;\n    }\n\n    sb += message;\n\n    message = sb;\n\n    if (this._errorHandler !== null) {\n      this._errorHandler(message, errorType);\n    } else {\n      throw new Error(message);\n    }\n\n    this._hadError = errorType === ErrorType.Error;\n    this._hadWarning = errorType === ErrorType.Warning;\n  };\n\n  public readonly ResetError = (): void => {\n    this._hadError = false;\n    this._hadWarning = false;\n  };\n\n  public readonly IsExternal = (namedFuncTarget: string): boolean =>\n    this.externals.has(namedFuncTarget);\n\n  public readonly AddExternal = (decl: ExternalDeclaration): void => {\n    if (this.externals.has(decl.name!)) {\n      this.Error(\n        `Duplicate EXTERNAL definition of '${decl.name}'`,\n        decl,\n        false\n      );\n    } else if (decl.name) {\n      this.externals.set(decl.name, decl);\n    }\n  };\n\n  public readonly DontFlattenContainer = (\n    container: RuntimeContainer\n  ): void => {\n    this._dontFlattenContainers.add(container);\n  };\n\n  public readonly NameConflictError = (\n    obj: ParsedObject,\n    name: string,\n    existingObj: ParsedObject,\n    typeNameToPrint: string\n  ): void => {\n    obj.Error(\n      `${typeNameToPrint} '${name}': name has already been used for a ${existingObj.typeName.toLowerCase()} on ${\n        existingObj.debugMetadata\n      }`\n    );\n  };\n\n  // Check given symbol type against everything that's of a higher priority in the ordered SymbolType enum (above).\n  // When the given symbol type level is reached, we early-out / return.\n  public readonly CheckForNamingCollisions = (\n    obj: ParsedObject,\n    identifier: Identifier,\n    symbolType: SymbolType,\n    typeNameOverride: string = \"\"\n  ): void => {\n    const typeNameToPrint: string = typeNameOverride || obj.typeName;\n    if (Story.IsReservedKeyword(identifier?.name)) {\n      obj.Error(\n        `'${identifier}' cannot be used for the name of a ${typeNameToPrint.toLowerCase()} because it's a reserved keyword`\n      );\n      return;\n    } else if (FunctionCall.IsBuiltIn(identifier?.name || \"\")) {\n      obj.Error(\n        `'${identifier}' cannot be used for the name of a ${typeNameToPrint.toLowerCase()} because it's a built in function`\n      );\n\n      return;\n    }\n\n    // Top level knots\n    const maybeKnotOrFunction = this.ContentWithNameAtLevel(\n      identifier?.name || \"\",\n      FlowLevel.Knot\n    );\n\n    const knotOrFunction = asOrNull(maybeKnotOrFunction, FlowBase);\n\n    if (\n      knotOrFunction &&\n      (knotOrFunction !== obj || symbolType === SymbolType.Arg)\n    ) {\n      this.NameConflictError(\n        obj,\n        identifier?.name || \"\",\n        knotOrFunction,\n        typeNameToPrint\n      );\n      return;\n    }\n\n    if (symbolType < SymbolType.List) {\n      return;\n    }\n\n    // Lists\n    for (const [key, value] of this._listDefs) {\n      if (\n        identifier?.name === key &&\n        obj !== value &&\n        value.variableAssignment !== obj\n      ) {\n        this.NameConflictError(obj, identifier?.name, value, typeNameToPrint);\n      }\n\n      // We don't check for conflicts between individual elements in\n      // different lists because they are namespaced.\n      if (!(obj instanceof ListElementDefinition)) {\n        for (const item of value.itemDefinitions) {\n          if (identifier?.name === item.name) {\n            this.NameConflictError(\n              obj,\n              identifier?.name || \"\",\n              item,\n              typeNameToPrint\n            );\n          }\n        }\n      }\n    }\n\n    // Don't check for VAR->VAR conflicts because that's handled separately\n    // (necessary since checking looks up in a dictionary)\n    if (symbolType <= SymbolType.Var) {\n      return;\n    }\n\n    // Global variable collision\n    const varDecl: VariableAssignment | null =\n      (identifier?.name && this.variableDeclarations.get(identifier?.name)) ||\n      null;\n    if (\n      varDecl &&\n      varDecl !== obj &&\n      varDecl.isGlobalDeclaration &&\n      varDecl.listDefinition == null\n    ) {\n      this.NameConflictError(\n        obj,\n        identifier?.name || \"\",\n        varDecl,\n        typeNameToPrint\n      );\n    }\n\n    if (symbolType < SymbolType.SubFlowAndWeave) {\n      return;\n    }\n\n    // Stitches, Choices and Gathers\n    const path = new Path(this.identifier!);\n    const targetContent = path.ResolveFromContext(obj);\n    if (targetContent && targetContent !== obj) {\n      this.NameConflictError(\n        obj,\n        identifier?.name || \"\",\n        targetContent,\n        typeNameToPrint\n      );\n      return;\n    }\n\n    if (symbolType < SymbolType.Arg) {\n      return;\n    }\n\n    // Arguments to the current flow\n    if (symbolType !== SymbolType.Arg) {\n      let flow: FlowBase | null = asOrNull(obj, FlowBase);\n      if (!flow) {\n        flow = ClosestFlowBase(obj);\n      }\n\n      if (flow && flow.hasParameters && flow.args) {\n        for (const arg of flow.args) {\n          if (arg.identifier?.name === identifier?.name) {\n            obj.Error(\n              `${typeNameToPrint} '${identifier}': Name has already been used for a argument to ${flow.identifier} on ${flow.debugMetadata}`\n            );\n\n            return;\n          }\n        }\n      }\n    }\n  };\n}\n","import { Argument } from \"./ParsedHierarchy/Argument\";\nimport { AuthorWarning } from \"./ParsedHierarchy/AuthorWarning\";\nimport { BinaryExpression } from \"./ParsedHierarchy/Expression/BinaryExpression\";\nimport { CharacterRange } from \"./CharacterRange\";\nimport { CharacterSet } from \"./CharacterSet\";\nimport { Choice } from \"./ParsedHierarchy/Choice\";\nimport { CommentEliminator } from \"./CommentEliminator\";\nimport { Conditional } from \"./ParsedHierarchy/Conditional/Conditional\";\nimport { ConditionalSingleBranch } from \"./ParsedHierarchy/Conditional/ConditionalSingleBranch\";\nimport { ContentList } from \"./ParsedHierarchy/ContentList\";\nimport { ConstantDeclaration } from \"./ParsedHierarchy/Declaration/ConstantDeclaration\";\nimport { CustomFlags } from \"./CustomFlags\";\nimport { DebugMetadata } from \"../../engine/DebugMetadata\";\nimport { Divert } from \"./ParsedHierarchy/Divert/Divert\";\nimport { DivertTarget } from \"./ParsedHierarchy/Divert/DivertTarget\";\nimport { Expression } from \"./ParsedHierarchy/Expression/Expression\";\nimport { ErrorHandler } from \"../../engine/Error\";\nimport { ExternalDeclaration } from \"./ParsedHierarchy/Declaration/ExternalDeclaration\";\nimport { FlowDecl } from \"./FlowDecl\";\nimport { FunctionCall } from \"./ParsedHierarchy/FunctionCall\";\nimport { Gather } from \"./ParsedHierarchy/Gather/Gather\";\nimport { Glue } from \"./ParsedHierarchy/Glue\";\nimport { Glue as RuntimeGlue } from \"../../engine/Glue\";\nimport { IFileHandler } from \"../IFileHandler\";\nimport { IncDecExpression } from \"./ParsedHierarchy/Expression/IncDecExpression\";\nimport { IncludedFile } from \"./ParsedHierarchy/IncludedFile\";\nimport { InfixOperator } from \"./InfixOperator\";\nimport { Knot } from \"./ParsedHierarchy/Knot\";\nimport { List } from \"./ParsedHierarchy/List/List\";\nimport { ListDefinition } from \"./ParsedHierarchy/List/ListDefinition\";\nimport { ListElementDefinition } from \"./ParsedHierarchy/List/ListElementDefinition\";\nimport { MultipleConditionExpression } from \"./ParsedHierarchy/Expression/MultipleConditionExpression\";\nimport { ParsedObject } from \"./ParsedHierarchy/Object\";\nimport { Path } from \"./ParsedHierarchy/Path\";\nimport { ReturnType } from \"./ParsedHierarchy/ReturnType\";\nimport { Sequence } from \"./ParsedHierarchy/Sequence/Sequence\";\nimport { SequenceType } from \"./ParsedHierarchy/Sequence/SequenceType\";\nimport { StatementLevel } from \"./StatementLevel\";\nimport { Stitch } from \"./ParsedHierarchy/Stitch\";\nimport { Story } from \"./ParsedHierarchy/Story\";\nimport { StringExpression } from \"./ParsedHierarchy/Expression/StringExpression\";\nimport {\n  StringParser,\n  SpecificParseRule,\n  ParseRule,\n  ParseRuleReturn,\n  ParseSuccess,\n} from \"./StringParser/StringParser\";\nimport { StringParserElement } from \"./StringParser/StringParserElement\";\nimport { Tag } from \"./ParsedHierarchy/Tag\";\nimport { Tag as RuntimeTag } from \"../../engine/Tag\";\nimport { Text } from \"./ParsedHierarchy/Text\";\nimport { TunnelOnwards } from \"./ParsedHierarchy/TunnelOnwards\";\nimport { VariableAssignment } from \"./ParsedHierarchy/Variable/VariableAssignment\";\nimport { VariableReference } from \"./ParsedHierarchy/Variable/VariableReference\";\nimport { UnaryExpression } from \"./ParsedHierarchy/Expression/UnaryExpression\";\nimport { asOrNull, filterUndef } from \"../../engine/TypeAssertion\";\nimport { Identifier } from \"./ParsedHierarchy/Identifier\";\nimport { NumberExpression } from \"./ParsedHierarchy/Expression/NumberExpression\";\n\nexport enum ErrorType {\n  Author,\n  Error,\n  Warning,\n}\n\nexport class InkParser extends StringParser {\n  /**\n   * Begin base InkParser section.\n   */\n\n  get fileHandler(): IFileHandler {\n    if (!this._fileHandler) {\n      throw new Error(\"No FileHandler defined\");\n    }\n    return this._fileHandler;\n  }\n\n  set fileHandler(value: IFileHandler) {\n    this._fileHandler = value;\n  }\n\n  constructor(\n    str: string,\n    private _filename: string | null = null,\n    private _externalErrorHandler: ErrorHandler | null = null,\n    rootParser: InkParser | null = null,\n    private _fileHandler: IFileHandler | null = null\n  ) {\n    super(str);\n\n    this.RegisterExpressionOperators();\n    this.GenerateStatementLevelRules();\n\n    this.errorHandler = this.OnStringParserError;\n\n    if (rootParser === null) {\n      this._rootParser = this;\n      this._openFilenames = [];\n\n      if (this._filename !== null) {\n        const fullRootInkPath = this.fileHandler.ResolveInkFilename(\n          this._filename\n        );\n        this._openFilenames.push(fullRootInkPath);\n      }\n    } else {\n      this._rootParser = rootParser;\n    }\n  }\n\n  // Main entry point\n  public readonly ParseStory = (): Story => {\n    const topLevelContent: ParsedObject[] = this.StatementsAtLevel(\n      StatementLevel.Top\n    );\n\n    // Note we used to return null if there were any errors, but this would mean\n    // that include files would return completely empty rather than attempting to\n    // continue with errors. Returning an empty include files meant that anything\n    // that *did* compile successfully would otherwise be ignored, generating way\n    // more errors than necessary.\n    return new Story(topLevelContent, this._rootParser !== this);\n  };\n\n  public readonly SeparatedList = <T extends ParseRule>(\n    mainRule: SpecificParseRule<T>,\n    separatorRule: ParseRule\n  ): ParseRuleReturn[] | null => {\n    const firstElement: ParseRuleReturn = this.Parse(mainRule);\n    if (firstElement === null) {\n      return null;\n    }\n\n    const allElements = [];\n    allElements.push(firstElement);\n\n    do {\n      const nextElementRuleId: number = this.BeginRule();\n      let sep = separatorRule();\n      if (sep === null) {\n        this.FailRule(nextElementRuleId);\n        break;\n      }\n\n      const nextElement = this.Parse(mainRule);\n      if (nextElement === null) {\n        this.FailRule(nextElementRuleId);\n        break;\n      }\n\n      this.SucceedRule(nextElementRuleId);\n      allElements.push(nextElement);\n    } while (true);\n\n    return allElements;\n  };\n\n  public PreProcessInputString(str: string): string {\n    const commentEliminator = new CommentEliminator(str);\n    return commentEliminator.Process();\n  }\n\n  public readonly CreateDebugMetadata = (\n    stateAtStart: StringParserElement | null,\n    stateAtEnd: StringParserElement\n  ): DebugMetadata => {\n    const md = new DebugMetadata();\n    md.startLineNumber = (stateAtStart?.lineIndex || 0) + 1;\n    md.endLineNumber = stateAtEnd.lineIndex + 1;\n    md.startCharacterNumber = (stateAtStart?.characterInLineIndex || 0) + 1;\n    md.endCharacterNumber = stateAtEnd.characterInLineIndex + 1;\n    md.fileName = this._filename;\n\n    return md;\n  };\n\n  public readonly RuleDidSucceed = (\n    result: ParseRuleReturn,\n    stateAtStart: StringParserElement | null,\n    stateAtEnd: StringParserElement\n  ): void => {\n    // Apply DebugMetadata based on the state at the start of the rule\n    // (i.e. use line number as it was at the start of the rule)\n    const parsedObj = asOrNull(result, ParsedObject);\n    if (parsedObj) {\n      parsedObj.debugMetadata = this.CreateDebugMetadata(\n        stateAtStart,\n        stateAtEnd\n      );\n    }\n\n    // A list of objects that doesn't already have metadata?\n    const parsedListObjs: ParsedObject[] | null = Array.isArray(result)\n      ? (result as ParsedObject[])\n      : null;\n    if (parsedListObjs !== null) {\n      for (const parsedListObj of parsedListObjs) {\n        const singleObj = asOrNull(parsedListObj, ParsedObject);\n        if (!singleObj) continue;\n        if (!parsedListObj.hasOwnDebugMetadata) {\n          parsedListObj.debugMetadata = this.CreateDebugMetadata(\n            stateAtStart,\n            stateAtEnd\n          );\n        }\n      }\n    }\n\n    const id = asOrNull(result, Identifier);\n    if (id != null) {\n      id.debugMetadata = this.CreateDebugMetadata(stateAtStart, stateAtEnd);\n    }\n  };\n\n  get parsingStringExpression(): boolean {\n    return this.GetFlag(Number(CustomFlags.ParsingString));\n  }\n\n  set parsingStringExpression(value: boolean) {\n    this.SetFlag(Number(CustomFlags.ParsingString), value);\n  }\n\n  public readonly OnStringParserError = (\n    message: string,\n    index: number,\n    lineIndex: number = 0,\n    isWarning: boolean = false\n  ): void => {\n    const warningType: string = isWarning ? \"WARNING:\" : \"ERROR:\";\n    let fullMessage: string = warningType;\n\n    if (this._filename !== null) {\n      fullMessage += ` '${this._filename}'`;\n    }\n\n    fullMessage += ` line ${lineIndex + 1}: ${message}`;\n\n    if (this._externalErrorHandler !== null) {\n      this._externalErrorHandler(\n        fullMessage,\n        isWarning ? ErrorType.Warning : ErrorType.Error\n      );\n    } else {\n      throw new Error(fullMessage);\n    }\n  };\n\n  public readonly AuthorWarning = (): AuthorWarning | null => {\n    this.Whitespace();\n\n    const identifier = (this.Parse(\n      this.IdentifierWithMetadata\n    ) as unknown) as Identifier | null;\n    if (identifier === null || identifier.name !== \"TODO\") {\n      return null;\n    }\n\n    this.Whitespace();\n    this.ParseString(\":\");\n    this.Whitespace();\n\n    const message = this.ParseUntilCharactersFromString(\"\\n\\r\");\n\n    if (message) {\n      return new AuthorWarning(message);\n    }\n\n    return null;\n  };\n\n  /**\n   * End base InkParser section.\n   */\n\n  /**\n   * Begin CharacterRanges section.\n   */\n\n  public static readonly LatinBasic: CharacterRange = CharacterRange.Define(\n    \"\\u0041\",\n    \"\\u007A\",\n    new CharacterSet().AddRange(\"\\u005B\", \"\\u0060\")\n  );\n\n  public static readonly LatinExtendedA: CharacterRange = CharacterRange.Define(\n    \"\\u0100\",\n    \"\\u017F\"\n    // no excludes here\n  );\n\n  public static readonly LatinExtendedB: CharacterRange = CharacterRange.Define(\n    \"\\u0180\",\n    \"\\u024F\"\n    // no excludes here\n  );\n\n  public static readonly Greek: CharacterRange = CharacterRange.Define(\n    \"\\u0370\",\n    \"\\u03FF\",\n    new CharacterSet()\n      .AddRange(\"\\u0378\", \"\\u0385\")\n      .AddCharacters(\"\\u0374\\u0375\\u0378\\u0387\\u038B\\u038D\\u03A2\")\n  );\n\n  public static readonly Cyrillic: CharacterRange = CharacterRange.Define(\n    \"\\u0400\",\n    \"\\u04FF\",\n    new CharacterSet().AddRange(\"\\u0482\", \"\\u0489\")\n  );\n\n  public static readonly Armenian: CharacterRange = CharacterRange.Define(\n    \"\\u0530\",\n    \"\\u058F\",\n    new CharacterSet()\n      .AddCharacters(\"\\u0530\")\n      .AddRange(\"\\u0557\", \"\\u0560\")\n      .AddRange(\"\\u0588\", \"\\u058E\")\n  );\n\n  public static readonly Hebrew: CharacterRange = CharacterRange.Define(\n    \"\\u0590\",\n    \"\\u05FF\",\n    new CharacterSet()\n  );\n\n  public static readonly Arabic: CharacterRange = CharacterRange.Define(\n    \"\\u0600\",\n    \"\\u06FF\",\n    new CharacterSet()\n  );\n\n  public static readonly Korean: CharacterRange = CharacterRange.Define(\n    \"\\uAC00\",\n    \"\\uD7AF\",\n    new CharacterSet()\n  );\n\n  private readonly ExtendIdentifierCharacterRanges = (\n    identifierCharSet: CharacterSet\n  ): void => {\n    const characterRanges = InkParser.ListAllCharacterRanges();\n    for (const charRange of characterRanges) {\n      identifierCharSet.AddCharacters(charRange.ToCharacterSet());\n    }\n  };\n\n  /// <summary>\n  /// Gets an array of <see cref=\"CharacterRange\" /> representing all of the currently supported\n  /// non-ASCII character ranges that can be used in identifier names.\n  /// </summary>\n  /// <returns>\n  /// An array of <see cref=\"CharacterRange\" /> representing all of the currently supported\n  /// non-ASCII character ranges that can be used in identifier names.\n  /// </returns>\n  public static readonly ListAllCharacterRanges = (): CharacterRange[] => [\n    InkParser.LatinBasic,\n    InkParser.LatinExtendedA,\n    InkParser.LatinExtendedB,\n    InkParser.Arabic,\n    InkParser.Armenian,\n    InkParser.Cyrillic,\n    InkParser.Greek,\n    InkParser.Hebrew,\n    InkParser.Korean,\n  ];\n\n  /**\n   * End CharacterRanges section.\n   */\n\n  /**\n   * Begin Choices section.\n   */\n\n  public _parsingChoice: boolean = false;\n\n  public readonly Choice = (): Choice | null => {\n    let onceOnlyChoice: boolean = true;\n    let bullets = this.Interleave<string>(\n      this.OptionalExclude(this.Whitespace),\n      this.String(\"*\")\n    );\n\n    if (!bullets) {\n      bullets = this.Interleave<string>(\n        this.OptionalExclude(this.Whitespace),\n        this.String(\"+\")\n      );\n\n      if (bullets === null) {\n        return null;\n      }\n\n      onceOnlyChoice = false;\n    }\n\n    // Optional name for the choice\n    const optionalName: Identifier = this.Parse(\n      this.BracketedName\n    ) as Identifier;\n\n    this.Whitespace();\n\n    // Optional condition for whether the choice should be shown to the player\n    const conditionExpr: Expression = this.Parse(\n      this.ChoiceCondition\n    ) as Expression;\n\n    this.Whitespace();\n\n    // Ordinarily we avoid parser state variables like these, since\n    // nesting would require us to store them in a stack. But since you should\n    // never be able to nest choices within choice content, it's fine here.\n    if (this._parsingChoice) {\n      throw new Error(\n        \"Already parsing a choice - shouldn't have nested choices\"\n      );\n    }\n\n    this._parsingChoice = true;\n\n    let startContent: ContentList | null = null;\n    const startTextAndLogic = this.Parse(\n      this.MixedTextAndLogic\n    ) as ParsedObject[];\n    if (startTextAndLogic) {\n      startContent = new ContentList(startTextAndLogic);\n    }\n\n    let optionOnlyContent: ContentList | null = null;\n    let innerContent: ContentList | null = null;\n\n    // Check for a the weave style format:\n    //   * \"Hello[.\"],\" he said.\n    const hasWeaveStyleInlineBrackets: boolean = this.ParseString(\"[\") !== null;\n    if (hasWeaveStyleInlineBrackets) {\n      const optionOnlyTextAndLogic = this.Parse(\n        this.MixedTextAndLogic\n      ) as ParsedObject[];\n\n      if (optionOnlyTextAndLogic !== null) {\n        optionOnlyContent = new ContentList(optionOnlyTextAndLogic);\n      }\n\n      this.Expect(this.String(\"]\"), \"closing ']' for weave-style option\");\n\n      let innerTextAndLogic = this.Parse(\n        this.MixedTextAndLogic\n      ) as ParsedObject[];\n      if (innerTextAndLogic !== null) {\n        innerContent = new ContentList(innerTextAndLogic);\n      }\n    }\n\n    this.Whitespace();\n\n    // Finally, now we know we're at the end of the main choice body, parse\n    // any diverts separately.\n    const diverts: ParsedObject[] = this.Parse(\n      this.MultiDivert\n    ) as ParsedObject[];\n\n    this._parsingChoice = false;\n\n    this.Whitespace();\n\n    // Completely empty choice without even an empty divert?\n    const emptyContent: boolean =\n      !startContent && !innerContent && !optionOnlyContent;\n\n    if (emptyContent && diverts === null) {\n      this.Warning(\n        \"Choice is completely empty. Interpretting as a default fallback choice. Add a divert arrow to remove this warning: * ->\"\n      );\n    }\n\n    if (!startContent && hasWeaveStyleInlineBrackets && !optionOnlyContent) {\n      // * [] some text\n      this.Warning(\n        \"Blank choice - if you intended a default fallback choice, use the `* ->` syntax\"\n      );\n    }\n\n    if (!innerContent) {\n      innerContent = new ContentList();\n    }\n\n    const tags = this.Parse(this.Tags) as ParsedObject[];\n    if (tags !== null) {\n      innerContent.AddContent(tags);\n    }\n\n    // Normal diverts on the end of a choice - simply add to the normal content\n    if (diverts !== null) {\n      for (const divObj of diverts) {\n        // may be TunnelOnwards\n        const div = asOrNull(divObj, Divert);\n\n        // Empty divert serves no purpose other than to say\n        // \"this choice is intentionally left blank\"\n        // (as an invisible default choice)\n        if (div && div.isEmpty) {\n          continue;\n        }\n\n        innerContent.AddContent(divObj);\n      }\n    }\n\n    // Terminate main content with a newline since this is the end of the line\n    // Note that this will be redundant if the diverts above definitely take\n    // the flow away permanently.\n    innerContent.AddContent(new Text(\"\\n\"));\n\n    const choice = new Choice(startContent!, optionOnlyContent!, innerContent);\n    if (optionalName) choice.identifier = optionalName;\n    choice.indentationDepth = bullets.length;\n    choice.hasWeaveStyleInlineBrackets = hasWeaveStyleInlineBrackets;\n    choice.condition = conditionExpr;\n    choice.onceOnly = onceOnlyChoice;\n    choice.isInvisibleDefault = emptyContent;\n    return choice;\n  };\n\n  public readonly ChoiceCondition = (): Expression | null => {\n    const conditions = this.Interleave<Expression>(\n      this.ChoiceSingleCondition,\n      this.ChoiceConditionsSpace\n    );\n\n    if (conditions === null) {\n      return null;\n    } else if (conditions.length === 1) {\n      return conditions[0];\n    }\n\n    return new MultipleConditionExpression(conditions);\n  };\n\n  public readonly ChoiceConditionsSpace = (): typeof ParseSuccess => {\n    // Both optional\n    // Newline includes initial end of line whitespace\n    this.Newline();\n    this.Whitespace();\n\n    return ParseSuccess;\n  };\n\n  public readonly ChoiceSingleCondition = (): Expression | null => {\n    if (this.ParseString(\"{\") === null) {\n      return null;\n    }\n\n    const condExpr = this.Expect(\n      this.Expression,\n      \"choice condition inside { }\"\n    ) as Expression;\n\n    this.DisallowIncrement(condExpr);\n    this.Expect(this.String(\"}\"), \"closing '}' for choice condition\");\n\n    return condExpr;\n  };\n\n  public readonly Gather = (): Gather | null => {\n    const gatherDashCountObj: number = this.Parse(this.GatherDashes) as number;\n    if (gatherDashCountObj === null) {\n      return null;\n    }\n\n    const gatherDashCount: number = Number(gatherDashCountObj);\n\n    // Optional name for the gather\n    const optionalName: Identifier = this.Parse(\n      this.BracketedName\n    ) as Identifier;\n\n    const gather = new Gather(optionalName, gatherDashCount);\n\n    // Optional newline before gather's content begins\n    this.Newline();\n\n    return gather;\n  };\n\n  public readonly GatherDashes = (): number | null => {\n    this.Whitespace();\n\n    let gatherDashCount: number = 0;\n    while (this.ParseDashNotArrow() !== null) {\n      gatherDashCount += 1;\n      this.Whitespace();\n    }\n\n    if (gatherDashCount === 0) {\n      return null;\n    }\n\n    return gatherDashCount as number;\n  };\n\n  public readonly ParseDashNotArrow = () => {\n    const ruleId = this.BeginRule();\n\n    if (\n      this.ParseString(\"->\") === null &&\n      this.ParseSingleCharacter() === \"-\"\n    ) {\n      return this.SucceedRule(ruleId);\n    }\n\n    return this.FailRule(ruleId);\n  };\n\n  public readonly BracketedName = (): Identifier | null => {\n    if (this.ParseString(\"(\") === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const name = this.Parse(this.IdentifierWithMetadata) as Identifier | null;\n    if (name === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    this.Expect(this.String(\")\"), \"closing ')' for bracketed name\");\n\n    return name;\n  };\n\n  /**\n   * End Choices section.\n   */\n\n  /**\n   * Begin Conditional section.\n   */\n\n  public readonly InnerConditionalContent = (\n    initialQueryExpression: Expression\n  ): Conditional | null => {\n    if (initialQueryExpression === undefined) {\n      const initialQueryExpression = this.Parse(this.ConditionExpression);\n      const conditional = this.Parse(() =>\n        this.InnerConditionalContent(initialQueryExpression as Expression)\n      ) as Conditional;\n\n      if (conditional === null) {\n        return null;\n      }\n\n      return conditional;\n    }\n\n    let alternatives: ConditionalSingleBranch[] | null;\n    const canBeInline: boolean = initialQueryExpression !== null;\n    const isInline: boolean = this.Parse(this.Newline) === null;\n\n    if (isInline && !canBeInline) {\n      return null;\n    }\n\n    if (isInline) {\n      // Inline innards\n      alternatives = this.InlineConditionalBranches();\n    } else {\n      // Multiline innards\n      alternatives = this.MultilineConditionalBranches();\n\n      if (alternatives === null) {\n        // Allow single piece of content within multi-line expression, e.g.:\n        // { true:\n        //    Some content that isn't preceded by '-'\n        // }\n        if (initialQueryExpression) {\n          let soleContent: ParsedObject[] = this.StatementsAtLevel(\n            StatementLevel.InnerBlock\n          );\n          if (soleContent !== null) {\n            const soleBranch = new ConditionalSingleBranch(soleContent);\n            alternatives = [soleBranch];\n\n            // Also allow a final \"- else:\" clause\n            const elseBranch = this.Parse(\n              this.SingleMultilineCondition\n            ) as ConditionalSingleBranch;\n            if (elseBranch) {\n              if (!elseBranch.isElse) {\n                this.ErrorWithParsedObject(\n                  \"Expected an '- else:' clause here rather than an extra condition\",\n                  elseBranch\n                );\n\n                elseBranch.isElse = true;\n              }\n\n              alternatives.push(elseBranch);\n            }\n          }\n        }\n\n        // Still null?\n        if (alternatives === null) {\n          return null;\n        }\n      } else if (\n        alternatives.length === 1 &&\n        alternatives[0].isElse &&\n        initialQueryExpression\n      ) {\n        // Empty true branch - didn't get parsed, but should insert one for semantic correctness,\n        // and to make sure that any evaluation stack values get tidied up correctly.\n        const emptyTrueBranch = new ConditionalSingleBranch(null);\n        emptyTrueBranch.isTrueBranch = true;\n        alternatives.unshift(emptyTrueBranch);\n      }\n\n      // Like a switch statement\n      // { initialQueryExpression:\n      //    ... match the expression\n      // }\n      if (initialQueryExpression) {\n        let earlierBranchesHaveOwnExpression: boolean = false;\n        for (let ii = 0; ii < alternatives.length; ++ii) {\n          const branch = alternatives[ii];\n          const isLast: boolean = ii === alternatives.length - 1;\n\n          // Matching equality with initial query expression\n          // We set this flag even for the \"else\" clause so that\n          // it knows to tidy up the evaluation stack at the end\n\n          // Match query\n          if (branch.ownExpression) {\n            branch.matchingEquality = true;\n            earlierBranchesHaveOwnExpression = true;\n          } else if (earlierBranchesHaveOwnExpression && isLast) {\n            // Else (final branch)\n            branch.matchingEquality = true;\n            branch.isElse = true;\n          } else {\n            // Binary condition:\n            // { trueOrFalse:\n            //    - when true\n            //    - when false\n            // }\n            if (!isLast && alternatives.length > 2) {\n              this.ErrorWithParsedObject(\n                \"Only final branch can be an 'else'. Did you miss a ':'?\",\n                branch\n              );\n            } else {\n              if (ii === 0) {\n                branch.isTrueBranch = true;\n              } else {\n                branch.isElse = true;\n              }\n            }\n          }\n        }\n      } else {\n        // No initial query, so just a multi-line conditional. e.g.:\n        // {\n        //   - x > 3:  greater than three\n        //   - x == 3: equal to three\n        //   - x < 3:  less than three\n        // }\n\n        for (let ii = 0; ii < alternatives.length; ++ii) {\n          const alt = alternatives[ii];\n          const isLast: boolean = ii === alternatives.length - 1;\n\n          if (alt.ownExpression === null) {\n            if (isLast) {\n              alt.isElse = true;\n            } else {\n              if (alt.isElse) {\n                // Do we ALSO have a valid \"else\" at the end? Let's report the error there.\n                const finalClause = alternatives[alternatives.length - 1];\n                if (finalClause.isElse) {\n                  this.ErrorWithParsedObject(\n                    \"Multiple 'else' cases. Can have a maximum of one, at the end.\",\n                    finalClause\n                  );\n                } else {\n                  this.ErrorWithParsedObject(\n                    \"'else' case in conditional should always be the final one\",\n                    alt\n                  );\n                }\n              } else {\n                this.ErrorWithParsedObject(\n                  \"Branch doesn't have condition. Are you missing a ':'? \",\n                  alt\n                );\n              }\n            }\n          }\n        }\n\n        if (\n          alternatives.length === 1 &&\n          alternatives[0].ownExpression === null\n        ) {\n          this.ErrorWithParsedObject(\n            \"Condition block with no conditions\",\n            alternatives[0]\n          );\n        }\n      }\n    }\n\n    // TODO: Come up with water-tight error conditions... it's quite a flexible system!\n    // e.g.\n    //   - inline conditionals must have exactly 1 or 2 alternatives\n    //   - multiline expression shouldn't have mixed existence of branch-conditions?\n    if (alternatives === null) {\n      return null;\n    }\n\n    for (const branch of alternatives) {\n      branch.isInline = isInline;\n    }\n\n    const cond = new Conditional(initialQueryExpression, alternatives);\n\n    return cond;\n  };\n\n  public readonly InlineConditionalBranches = ():\n    | ConditionalSingleBranch[]\n    | null => {\n    const listOfLists = this.Interleave<ParsedObject[]>(\n      this.MixedTextAndLogic,\n      this.Exclude(this.String(\"|\")),\n      null,\n      false\n    );\n\n    if (listOfLists === null || listOfLists.length === 0) {\n      return null;\n    }\n\n    const result: ConditionalSingleBranch[] = [];\n\n    if (listOfLists.length > 2) {\n      this.Error(\n        \"Expected one or two alternatives separated by '|' in inline conditional\"\n      );\n    } else {\n      const trueBranch = new ConditionalSingleBranch(listOfLists[0]);\n      trueBranch.isTrueBranch = true;\n      result.push(trueBranch);\n\n      if (listOfLists.length > 1) {\n        const elseBranch = new ConditionalSingleBranch(listOfLists[1]);\n        elseBranch.isElse = true;\n        result.push(elseBranch);\n      }\n    }\n\n    return result;\n  };\n\n  public readonly MultilineConditionalBranches = ():\n    | ConditionalSingleBranch[]\n    | null => {\n    this.MultilineWhitespace();\n\n    const multipleConditions = this.OneOrMore(this.SingleMultilineCondition);\n    if (multipleConditions === null) {\n      return null;\n    }\n\n    this.MultilineWhitespace();\n\n    return multipleConditions as ConditionalSingleBranch[];\n  };\n\n  public readonly SingleMultilineCondition = (): ConditionalSingleBranch | null => {\n    this.Whitespace();\n\n    if (\n      // Make sure we're not accidentally parsing a divert\n      this.ParseString(\"->\") !== null ||\n      this.ParseString(\"-\") === null\n    ) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    let expr: Expression | null = null;\n    const isElse: boolean = this.Parse(this.ElseExpression) !== null;\n\n    if (!isElse) {\n      expr = this.Parse(this.ConditionExpression) as Expression;\n    }\n\n    let content: ParsedObject[] = this.StatementsAtLevel(\n      StatementLevel.InnerBlock\n    );\n    if (expr === null && content === null) {\n      this.Error(\"expected content for the conditional branch following '-'\");\n\n      // Recover\n      content = [new Text(\"\")];\n    }\n\n    // Allow additional multiline whitespace, if the statements were empty (valid)\n    // then their surrounding multiline whitespacce needs to be handled manually.\n    // e.g.\n    // { x:\n    //   - 1:    // intentionally left blank, but newline needs to be parsed\n    //   - 2: etc\n    // }\n    this.MultilineWhitespace();\n\n    const branch = new ConditionalSingleBranch(content);\n    branch.ownExpression = expr;\n    branch.isElse = isElse;\n\n    return branch;\n  };\n\n  public readonly ConditionExpression = (): ParsedObject | null => {\n    const expr = this.Parse(this.Expression) as ParsedObject;\n    if (expr === null) {\n      return null;\n    }\n\n    this.DisallowIncrement(expr);\n\n    this.Whitespace();\n\n    if (this.ParseString(\":\") === null) {\n      return null;\n    }\n\n    return expr;\n  };\n\n  public readonly ElseExpression = (): typeof ParseSuccess | null => {\n    if (this.ParseString(\"else\") === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    if (this.ParseString(\":\") === null) {\n      return null;\n    }\n\n    return ParseSuccess;\n  };\n\n  /**\n   * End Conditional section.\n   */\n\n  /**\n   * Begin Content section.\n   */\n\n  public _nonTextPauseCharacters: CharacterSet | null = null;\n  public _nonTextEndCharacters: CharacterSet | null = null;\n  public _notTextEndCharactersChoice: CharacterSet | null = null;\n  public _notTextEndCharactersString: CharacterSet | null = null;\n\n  public readonly TrimEndWhitespace = (\n    mixedTextAndLogicResults: ParsedObject[],\n    terminateWithSpace: boolean\n  ): void => {\n    // Trim whitespace from end\n    if (mixedTextAndLogicResults.length > 0) {\n      const lastObjIdx = mixedTextAndLogicResults.length - 1;\n      const lastObj = mixedTextAndLogicResults[lastObjIdx];\n      if (lastObj instanceof Text) {\n        const textObj: Text = lastObj;\n        textObj.text = textObj.text.replace(new RegExp(/[ \\t]+$/g), \"\");\n\n        if (terminateWithSpace) {\n          textObj.text += \" \";\n        } else if (textObj.text.length === 0) {\n          // No content left at all? trim the whole object\n          mixedTextAndLogicResults.splice(lastObjIdx, 1);\n\n          // Recurse in case there's more whitespace\n          this.TrimEndWhitespace(mixedTextAndLogicResults, false);\n        }\n      }\n    }\n  };\n\n  public readonly LineOfMixedTextAndLogic = (): ParsedObject[] | null => {\n    // Consume any whitespace at the start of the line\n    // (Except for escaped whitespace)\n    this.Parse(this.Whitespace);\n\n    let result: ParsedObject[] = this.Parse(\n      this.MixedTextAndLogic\n    ) as ParsedObject[];\n\n    // Terminating tag\n    let onlyTags: boolean = false;\n    const tags = this.Parse(this.Tags) as ParsedObject[];\n    if (tags) {\n      if (!result) {\n        result = tags;\n        onlyTags = true;\n      } else {\n        for (const tag of tags) {\n          result.push(tag);\n        }\n      }\n    }\n\n    if (!result || !result.length) {\n      return null;\n    }\n\n    // Warn about accidentally writing \"return\" without \"~\"\n    const firstText = result[0] as Text;\n    if (firstText && firstText.text && firstText.text.startsWith(\"return\")) {\n      this.Warning(\n        \"Do you need a '~' before 'return'? If not, perhaps use a glue: <> (since it's lowercase) or rewrite somehow?\"\n      );\n    }\n\n    if (result.length === 0) {\n      return null;\n    }\n\n    const lastObj = result[result.length - 1];\n    if (!(lastObj instanceof Divert)) {\n      this.TrimEndWhitespace(result, false);\n    }\n\n    // Add newline since it's the end of the line\n    // (so long as it's a line with only tags)\n    if (!onlyTags) {\n      result.push(new Text(\"\\n\"));\n    }\n\n    this.Expect(this.EndOfLine, \"end of line\", this.SkipToNextLine);\n    return result;\n  };\n\n  public readonly MixedTextAndLogic = (): ParsedObject[] | null => {\n    // Check for disallowed \"~\" within this context\n    const disallowedTilde = this.ParseObject(this.Spaced(this.String(\"~\")));\n    if (disallowedTilde !== null) {\n      this.Error(\n        \"You shouldn't use a '~' here - tildas are for logic that's on its own line. To do inline logic, use { curly braces } instead\"\n      );\n    }\n\n    // Either, or both interleaved\n    let results: ParsedObject[] = this.Interleave<ParsedObject>(\n      this.Optional(this.ContentText),\n      this.Optional(this.InlineLogicOrGlue)\n    );\n\n    // Terminating divert?\n    // (When parsing content for the text of a choice, diverts aren't allowed.\n    //  The divert on the end of the body of a choice is handled specially.)\n    if (!this._parsingChoice) {\n      const diverts: ParsedObject[] = this.Parse(\n        this.MultiDivert\n      ) as ParsedObject[];\n      if (diverts !== null) {\n        // May not have had any results at all if there's *only* a divert!\n        if (results === null) {\n          results = [];\n        }\n\n        this.TrimEndWhitespace(results, true);\n\n        results.push(...diverts);\n      }\n    }\n\n    if (!results) {\n      return null;\n    }\n\n    return results;\n  };\n\n  public readonly ContentText = () => {\n    return this.ContentTextAllowingEscapeChar();\n  };\n\n  public readonly ContentTextAllowingEscapeChar = (): Text | null => {\n    let sb: string | null = null;\n\n    do {\n      let str = this.Parse(this.ContentTextNoEscape);\n      const gotEscapeChar: boolean = this.ParseString(\"\\\\\") !== null;\n\n      if (gotEscapeChar || str !== null) {\n        if (sb === null) {\n          sb = \"\";\n        }\n\n        if (str !== null) {\n          sb += String(str);\n        }\n\n        if (gotEscapeChar) {\n          const c: string = this.ParseSingleCharacter();\n          sb += c;\n        }\n      } else {\n        break;\n      }\n    } while (true);\n\n    if (sb !== null) {\n      return new Text(sb);\n    }\n\n    return null;\n  };\n\n  // Content text is an unusual parse rule compared with most since it's\n  // less about saying \"this is is the small selection of stuff that we parse\"\n  // and more \"we parse ANYTHING except this small selection of stuff\".\n  public readonly ContentTextNoEscape = (): string | null => {\n    // Eat through text, pausing at the following characters, and\n    // attempt to parse the nonTextRule.\n    // \"-\": possible start of divert or start of gather\n    // \"<\": possible start of glue\n    if (this._nonTextPauseCharacters === null) {\n      this._nonTextPauseCharacters = new CharacterSet(\"-<\");\n    }\n\n    // If we hit any of these characters, we stop *immediately* without bothering to even check the nonTextRule\n    // \"{\" for start of logic\n    // \"|\" for mid logic branch\n    if (this._nonTextEndCharacters === null) {\n      this._nonTextEndCharacters = new CharacterSet(\"{}|\\n\\r\\\\#\");\n      this._notTextEndCharactersChoice = new CharacterSet(\n        this._nonTextEndCharacters\n      );\n      this._notTextEndCharactersChoice.AddCharacters(\"[]\");\n      this._notTextEndCharactersString = new CharacterSet(\n        this._nonTextEndCharacters\n      );\n      this._notTextEndCharactersString.AddCharacters('\"');\n    }\n\n    // When the ParseUntil pauses, check these rules in case they evaluate successfully\n    const nonTextRule: ParseRule = () =>\n      this.OneOf([\n        this.ParseDivertArrow,\n        this.ParseThreadArrow,\n        this.EndOfLine,\n        this.Glue,\n      ]);\n\n    let endChars: CharacterSet | null = null;\n    if (this.parsingStringExpression) {\n      endChars = this._notTextEndCharactersString;\n    } else if (this._parsingChoice) {\n      endChars = this._notTextEndCharactersChoice;\n    } else {\n      endChars = this._nonTextEndCharacters;\n    }\n\n    const pureTextContent: string = this.ParseUntil(\n      nonTextRule,\n      this._nonTextPauseCharacters,\n      endChars\n    );\n\n    if (pureTextContent !== null) {\n      return pureTextContent;\n    }\n\n    return null;\n  };\n\n  /**\n   * End Content section.\n   */\n\n  /**\n   * Begin Divert section.\n   */\n\n  public readonly MultiDivert = (): ParsedObject[] | null => {\n    this.Whitespace();\n\n    let diverts: ParsedObject[] = [];\n\n    // Try single thread first\n    const threadDivert = this.Parse(this.StartThread) as ParsedObject;\n    if (threadDivert) {\n      diverts = [threadDivert];\n\n      return diverts;\n    }\n\n    // Normal diverts and tunnels\n    const arrowsAndDiverts = this.Interleave<ParsedObject>(\n      this.ParseDivertArrowOrTunnelOnwards,\n      this.DivertIdentifierWithArguments\n    );\n\n    if (!arrowsAndDiverts) {\n      return null;\n    }\n\n    diverts = [];\n\n    // Possible patterns:\n    //  ->                   -- explicit gather\n    //  ->->                 -- tunnel onwards\n    //  -> div               -- normal divert\n    //  ->-> div             -- tunnel onwards, followed by override divert\n    //  -> div ->            -- normal tunnel\n    //  -> div ->->          -- tunnel then tunnel continue\n    //  -> div -> div        -- tunnel then divert\n    //  -> div -> div ->     -- tunnel then tunnel\n    //  -> div -> div ->->\n    //  -> div -> div ->-> div    (etc)\n\n    // Look at the arrows and diverts\n    for (let ii = 0; ii < arrowsAndDiverts.length; ++ii) {\n      const isArrow: boolean = ii % 2 === 0;\n\n      // Arrow string\n      if (isArrow) {\n        // Tunnel onwards\n        if ((arrowsAndDiverts[ii] as any) === \"->->\") {\n          const tunnelOnwardsPlacementValid: boolean =\n            ii === 0 ||\n            ii === arrowsAndDiverts.length - 1 ||\n            ii === arrowsAndDiverts.length - 2;\n\n          if (!tunnelOnwardsPlacementValid) {\n            this.Error(\n              \"Tunnel onwards '->->' must only come at the begining or the start of a divert\"\n            );\n          }\n\n          const tunnelOnwards = new TunnelOnwards();\n          if (ii < arrowsAndDiverts.length - 1) {\n            const tunnelOnwardDivert = asOrNull(\n              arrowsAndDiverts[ii + 1],\n              Divert\n            );\n            tunnelOnwards.divertAfter = tunnelOnwardDivert;\n          }\n\n          diverts.push(tunnelOnwards);\n\n          // Not allowed to do anything after a tunnel onwards.\n          // If we had anything left it would be caused in the above Error for\n          // the positioning of a ->->\n          break;\n        }\n      } else {\n        // Divert\n        const divert = arrowsAndDiverts[ii] as Divert;\n        // More to come? (further arrows) Must be tunnelling.\n        if (ii < arrowsAndDiverts.length - 1) {\n          divert.isTunnel = true;\n        }\n\n        diverts.push(divert);\n      }\n    }\n\n    // Single -> (used for default choices)\n    if (diverts.length === 0 && arrowsAndDiverts.length === 1) {\n      const gatherDivert = new Divert(null);\n      gatherDivert.isEmpty = true;\n      diverts.push(gatherDivert);\n\n      if (!this._parsingChoice) {\n        this.Error(\"Empty diverts (->) are only valid on choices\");\n      }\n    }\n\n    return diverts;\n  };\n\n  public readonly StartThread = (): Divert | null => {\n    this.Whitespace();\n\n    if (this.ParseThreadArrow() === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const divert = this.Expect(\n      this.DivertIdentifierWithArguments,\n      \"target for new thread\",\n      () => new Divert(null)\n    ) as Divert;\n\n    divert.isThread = true;\n\n    return divert;\n  };\n\n  public readonly DivertIdentifierWithArguments = (): Divert | null => {\n    this.Whitespace();\n\n    const targetComponents: Identifier[] = this.Parse(\n      this.DotSeparatedDivertPathComponents\n    ) as Identifier[];\n\n    if (!targetComponents) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const optionalArguments = this.Parse(\n      this.ExpressionFunctionCallArguments\n    ) as Expression[];\n\n    this.Whitespace();\n\n    const targetPath = new Path(targetComponents);\n\n    return new Divert(targetPath, optionalArguments);\n  };\n\n  public readonly SingleDivert = (): Divert | null => {\n    const diverts = this.Parse(this.MultiDivert) as ParsedObject[];\n    if (!diverts) {\n      return null;\n    }\n\n    // Ideally we'd report errors if we get the\n    // wrong kind of divert, but unfortunately we\n    // have to hack around the fact that sequences use\n    // a very similar syntax.\n    // i.e. if you have a multi-divert at the start\n    // of a sequence, it initially tries to parse it\n    // as a divert target (part of an expression of\n    // a conditional) and gives errors. So instead\n    // we just have to blindly reject it as a single\n    // divert, and give a slightly less nice error\n    // when you DO use a multi divert as a divert taret.\n\n    if (diverts.length !== 1) {\n      return null;\n    }\n\n    const singleDivert = diverts[0];\n    if (singleDivert instanceof TunnelOnwards) {\n      return null;\n    }\n\n    const divert = diverts[0] as Divert;\n    if (divert.isTunnel) {\n      return null;\n    }\n\n    return divert;\n  };\n\n  public readonly DotSeparatedDivertPathComponents = (): Identifier[] =>\n    this.Interleave<Identifier>(\n      this.Spaced(this.IdentifierWithMetadata),\n      this.Exclude(this.String(\".\"))\n    );\n\n  public readonly ParseDivertArrowOrTunnelOnwards = (): string | null => {\n    let numArrows: number = 0;\n    while (this.ParseString(\"->\") !== null) {\n      numArrows += 1;\n    }\n\n    if (numArrows === 0) {\n      return null;\n    } else if (numArrows === 1) {\n      return \"->\";\n    } else if (numArrows === 2) {\n      return \"->->\";\n    }\n\n    this.Error(\n      \"Unexpected number of arrows in divert. Should only have '->' or '->->'\"\n    );\n\n    return \"->->\";\n  };\n\n  public readonly ParseDivertArrow = () => this.ParseString(\"->\");\n\n  public readonly ParseThreadArrow = () => this.ParseString(\"<-\");\n\n  /**\n   * End Divert section.\n   */\n\n  /**\n   * Begin Expressions section.\n   */\n\n  public _binaryOperators: InfixOperator[] = [];\n  public _maxBinaryOpLength: number = 0;\n\n  public readonly TempDeclarationOrAssignment = (): ParsedObject | null => {\n    this.Whitespace();\n\n    const isNewDeclaration: boolean = this.ParseTempKeyword();\n\n    this.Whitespace();\n\n    let varIdentifier: Identifier | null = null;\n    if (isNewDeclaration) {\n      varIdentifier = this.Expect(\n        this.IdentifierWithMetadata,\n        \"variable name\"\n      ) as Identifier;\n    } else {\n      varIdentifier = this.Parse(this.IdentifierWithMetadata) as Identifier;\n    }\n\n    if (varIdentifier === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    // += -=\n    const isIncrement: boolean = this.ParseString(\"+\") !== null;\n    const isDecrement: boolean = this.ParseString(\"-\") !== null;\n\n    if (isIncrement && isDecrement) {\n      this.Error(\"Unexpected sequence '+-'\");\n    }\n\n    if (this.ParseString(\"=\") === null) {\n      // Definitely in an assignment expression?\n      if (isNewDeclaration) {\n        this.Error(\"Expected '='\");\n      }\n\n      return null;\n    }\n\n    const assignedExpression: Expression = this.Expect(\n      this.Expression,\n      \"value expression to be assigned\"\n    ) as Expression;\n\n    if (isIncrement || isDecrement) {\n      const result = new IncDecExpression(\n        varIdentifier,\n        assignedExpression,\n        isIncrement\n      );\n      return result;\n    }\n\n    const result = new VariableAssignment({\n      variableIdentifier: varIdentifier,\n      assignedExpression,\n      isTemporaryNewDeclaration: isNewDeclaration,\n    });\n\n    return result;\n  };\n\n  public readonly DisallowIncrement = (expr: ParsedObject): void => {\n    if (expr instanceof IncDecExpression) {\n      this.Error(\n        \"Can't use increment/decrement here. It can only be used on a ~ line\"\n      );\n    }\n  };\n\n  public readonly ParseTempKeyword = () => {\n    const ruleId = this.BeginRule();\n\n    if (this.Parse(this.Identifier) === \"temp\") {\n      this.SucceedRule(ruleId);\n      return true;\n    }\n\n    this.FailRule(ruleId);\n    return false;\n  };\n\n  public readonly ReturnStatement = (): ReturnType | null => {\n    this.Whitespace();\n\n    const returnOrDone = this.Parse(this.Identifier);\n    if (returnOrDone !== \"return\") {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const expr = this.Parse(this.Expression) as Expression;\n\n    const returnObj = new ReturnType(expr);\n\n    return returnObj;\n  };\n\n  // Pratt Parser\n  // aka \"Top down operator precedence parser\"\n  // http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/\n  // Algorithm overview:\n  // The two types of precedence are handled in two different ways:\n  //   ((((a . b) . c) . d) . e)\t\t\t#1\n  //   (a . (b . (c . (d . e))))\t\t\t#2\n  // Where #1 is automatically handled by successive loops within the main 'while' in this function,\n  // so long as continuing operators have lower (or equal) precedence (e.g. imagine some series of \"*\"s then \"+\" above.\n  // ...and #2 is handled by recursion of the right hand term in the binary expression parser.\n  // (see link for advice on how to extend for postfix and mixfix operators)\n  public readonly Expression = (\n    minimumPrecedence: number = 0\n  ): Expression | null => {\n    this.Whitespace();\n\n    // First parse a unary expression e.g. \"-a\" or parethensised \"(1 + 2)\"\n    let expr = this.ExpressionUnary();\n    if (expr === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    // Attempt to parse (possibly multiple) continuing infix expressions (e.g. 1 + 2 + 3)\n    while (true) {\n      const ruleId = this.BeginRule();\n\n      // Operator\n      const infixOp = this.ParseInfixOperator();\n      if (infixOp !== null && infixOp.precedence > minimumPrecedence) {\n        // Expect right hand side of operator\n        const expectationMessage = `right side of '${infixOp.type}' expression`;\n        const multiaryExpr = this.Expect(\n          () => this.ExpressionInfixRight(expr, infixOp),\n          expectationMessage\n        );\n\n        if (multiaryExpr === null) {\n          // Fail for operator and right-hand side of multiary expression\n          this.FailRule(ruleId);\n\n          return null;\n        }\n\n        expr = this.SucceedRule(ruleId, multiaryExpr) as Expression;\n\n        continue;\n      }\n\n      this.FailRule(ruleId);\n      break;\n    }\n\n    this.Whitespace();\n\n    return expr;\n  };\n\n  public readonly ExpressionUnary = (): Expression | null => {\n    // Divert target is a special case - it can't have any other operators\n    // applied to it, and we also want to check for it first so that we don't\n    // confuse \"->\" for subtraction.\n    const divertTarget = this.Parse(this.ExpressionDivertTarget) as Expression;\n    if (divertTarget !== null) {\n      return divertTarget;\n    }\n\n    let prefixOp: Expression = this.OneOf([\n      this.String(\"-\"),\n      this.String(\"!\"),\n    ]) as Expression;\n\n    // Don't parse like the string rules above, in case its actually\n    // a variable that simply starts with \"not\", e.g. \"notable\".\n    // This rule uses the Identifier rule, which will scan as much text\n    // as possible before returning.\n    if (prefixOp === null) {\n      prefixOp = this.Parse(this.ExpressionNot) as Expression;\n    }\n\n    this.Whitespace();\n\n    // - Since we allow numbers at the start of variable names, variable names are checked before literals\n    // - Function calls before variable names in case we see parentheses\n    let expr = this.OneOf([\n      this.ExpressionList,\n      this.ExpressionParen,\n      this.ExpressionFunctionCall,\n      this.ExpressionVariableName,\n      this.ExpressionLiteral,\n    ]) as Expression | null;\n\n    // Only recurse immediately if we have one of the (usually optional) unary ops\n    if (expr === null && prefixOp !== null) {\n      expr = this.ExpressionUnary();\n    }\n\n    if (expr === null) {\n      return null;\n    } else if (prefixOp !== null) {\n      expr = UnaryExpression.WithInner(expr, prefixOp as any) as Expression;\n    }\n\n    this.Whitespace();\n\n    const postfixOp = this.OneOf([this.String(\"++\"), this.String(\"--\")]);\n\n    if (postfixOp !== null) {\n      const isInc: boolean = postfixOp === \"++\";\n\n      if (!(expr instanceof VariableReference)) {\n        this.Error(\n          `can only increment and decrement variables, but saw '${expr}'.`\n        );\n\n        // Drop down and succeed without the increment after reporting error\n      } else {\n        const varRef = expr as VariableReference;\n        expr = new IncDecExpression(varRef.identifier, isInc);\n      }\n    }\n\n    return expr;\n  };\n\n  public readonly ExpressionNot = (): string | null => {\n    const id = this.Identifier();\n    if (id === \"not\") {\n      return id;\n    }\n\n    return null;\n  };\n\n  public readonly ExpressionLiteral = (): Expression =>\n    this.OneOf([\n      this.ExpressionFloat,\n      this.ExpressionInt,\n      this.ExpressionBool,\n      this.ExpressionString,\n    ]) as Expression;\n\n  public readonly ExpressionDivertTarget = (): Expression | null => {\n    this.Whitespace();\n\n    const divert = this.Parse(this.SingleDivert) as Divert;\n    if (!divert || (divert && divert.isThread)) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    return new DivertTarget(divert);\n  };\n\n  public readonly ExpressionInt = (): NumberExpression | null => {\n    const intOrNull: number = this.ParseInt() as number;\n    if (intOrNull === null) {\n      return null;\n    }\n\n    return new NumberExpression(intOrNull, \"int\");\n  };\n\n  public readonly ExpressionFloat = (): NumberExpression | null => {\n    const floatOrNull: number = this.ParseFloat() as number;\n    if (floatOrNull === null) {\n      return null;\n    }\n\n    return new NumberExpression(floatOrNull, \"float\");\n  };\n\n  public readonly ExpressionString = (): StringExpression | null => {\n    const openQuote = this.ParseString('\"');\n    if (openQuote === null) {\n      return null;\n    }\n\n    // Set custom parser state flag so that within the text parser,\n    // it knows to treat the quote character (\") as an end character\n    this.parsingStringExpression = true;\n\n    let textAndLogic: ParsedObject[] = this.Parse(\n      this.MixedTextAndLogic\n    ) as ParsedObject[];\n\n    this.Expect(this.String('\"'), \"close quote for string expression\");\n\n    this.parsingStringExpression = false;\n\n    if (textAndLogic === null) {\n      textAndLogic = [new Text(\"\")];\n    } else if (textAndLogic.find((c) => c instanceof Divert)) {\n      this.Error(\"String expressions cannot contain diverts (->)\");\n    }\n\n    return new StringExpression(textAndLogic);\n  };\n\n  public readonly ExpressionBool = (): NumberExpression | null => {\n    const id = this.Parse(this.Identifier);\n    if (id === \"true\") {\n      return new NumberExpression(true, \"bool\");\n    } else if (id === \"false\") {\n      return new NumberExpression(false, \"bool\");\n    }\n\n    return null;\n  };\n\n  public readonly ExpressionFunctionCall = (): Expression | null => {\n    const iden = this.Parse(this.IdentifierWithMetadata);\n    if (iden === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const args = this.Parse(this.ExpressionFunctionCallArguments);\n    if (args === null) {\n      return null;\n    }\n\n    return new FunctionCall(iden as Identifier, args as any);\n  };\n\n  public readonly ExpressionFunctionCallArguments = (): Expression[] | null => {\n    if (this.ParseString(\"(\") === null) {\n      return null;\n    }\n\n    // \"Exclude\" requires the rule to succeed, but causes actual comma string to be excluded from the list of results\n    const commas: ParseRule = this.Exclude(this.String(\",\"));\n    let args = this.Interleave<Expression>(this.Expression, commas);\n    if (args === null) {\n      args = [];\n    }\n\n    this.Whitespace();\n\n    this.Expect(this.String(\")\"), \"closing ')' for function call\");\n\n    return args;\n  };\n\n  public readonly ExpressionVariableName = (): Expression | null => {\n    const path = this.Interleave<Identifier>(\n      this.IdentifierWithMetadata,\n      this.Exclude(this.Spaced(this.String(\".\")))\n    );\n\n    if (path === null || Story.IsReservedKeyword(path[0].name)) {\n      return null;\n    }\n\n    return new VariableReference(path);\n  };\n\n  public readonly ExpressionParen = (): Expression | null => {\n    if (this.ParseString(\"(\") === null) {\n      return null;\n    }\n\n    const innerExpr = this.Parse(this.Expression) as Expression;\n    if (innerExpr === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    this.Expect(this.String(\")\"), \"closing parenthesis ')' for expression\");\n\n    return innerExpr;\n  };\n\n  public readonly ExpressionInfixRight = (\n    left: Expression | null,\n    op: InfixOperator\n  ) => {\n    if (!left) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const right = this.Parse(() =>\n      this.Expression(op.precedence)\n    ) as Expression;\n    if (right) {\n      // We assume that the character we use for the operator's type is the same\n      // as that used internally by e.g. Runtime.Expression.Add, Runtime.Expression.Multiply etc\n      const expr = new BinaryExpression(left, right, op.type);\n      return expr;\n    }\n\n    return null;\n  };\n\n  private readonly ParseInfixOperator = (): InfixOperator | null => {\n    for (const op of this._binaryOperators) {\n      const ruleId: number = this.BeginRule();\n\n      if (this.ParseString(op.type) !== null) {\n        if (op.requireWhitespace) {\n          if (this.Whitespace() === null) {\n            this.FailRule(ruleId);\n\n            continue;\n          }\n        }\n\n        return this.SucceedRule(ruleId, op) as InfixOperator;\n      }\n\n      this.FailRule(ruleId);\n    }\n\n    return null;\n  };\n\n  public readonly ExpressionList = (): List | null => {\n    this.Whitespace();\n\n    if (this.ParseString(\"(\") === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    // When list has:\n    //  - 0 elements (null list) - this is okay, it's an empty list: \"()\"\n    //  - 1 element - it could be confused for a single non-list related\n    //    identifier expression in brackets, but this is a useless thing\n    //    to do, so we reserve that syntax for a list with one item.\n    //  - 2 or more elements - normal!\n    const memberNames: Identifier[] = this.SeparatedList(\n      this.ListMember,\n      this.Spaced(this.String(\",\"))\n    ) as Identifier[];\n\n    this.Whitespace();\n\n    // May have failed to parse the inner list - the parentheses may\n    // be for a normal expression\n    if (this.ParseString(\")\") === null) {\n      return null;\n    }\n    return new List(memberNames);\n  };\n\n  public readonly ListMember = (): Identifier | null => {\n    this.Whitespace();\n\n    let identifier: Identifier = this.Parse(\n      this.IdentifierWithMetadata\n    ) as Identifier;\n    if (identifier === null) {\n      return null;\n    }\n\n    const dot = this.ParseString(\".\");\n    if (dot !== null) {\n      const identifier2: Identifier = this.Expect(\n        this.IdentifierWithMetadata,\n        `element name within the set ${identifier}`\n      ) as Identifier;\n\n      identifier.name += `.${identifier2?.name}`;\n    }\n\n    this.Whitespace();\n\n    return identifier;\n  };\n\n  public readonly RegisterExpressionOperators = () => {\n    // These will be tried in order, so we need \"<=\" before \"<\"\n    // for correctness\n\n    this.RegisterBinaryOperator(\"&&\", 1);\n    this.RegisterBinaryOperator(\"||\", 1);\n    this.RegisterBinaryOperator(\"and\", 1, true);\n    this.RegisterBinaryOperator(\"or\", 1, true);\n    this.RegisterBinaryOperator(\"==\", 2);\n    this.RegisterBinaryOperator(\">=\", 2);\n    this.RegisterBinaryOperator(\"<=\", 2);\n    this.RegisterBinaryOperator(\"<\", 2);\n    this.RegisterBinaryOperator(\">\", 2);\n    this.RegisterBinaryOperator(\"!=\", 2);\n\n    // (apples, oranges) + cabbages has (oranges, cabbages) === true\n    this.RegisterBinaryOperator(\"?\", 3);\n    this.RegisterBinaryOperator(\"has\", 3, true);\n    this.RegisterBinaryOperator(\"!?\", 3);\n    this.RegisterBinaryOperator(\"hasnt\", 3, true);\n    this.RegisterBinaryOperator(\"^\", 3);\n\n    this.RegisterBinaryOperator(\"+\", 4);\n    this.RegisterBinaryOperator(\"-\", 5);\n    this.RegisterBinaryOperator(\"*\", 6);\n    this.RegisterBinaryOperator(\"/\", 7);\n\n    this.RegisterBinaryOperator(\"%\", 8);\n    this.RegisterBinaryOperator(\"mod\", 8, true);\n  };\n\n  public readonly RegisterBinaryOperator = (\n    op: string,\n    precedence: number,\n    requireWhitespace: boolean = false\n  ): void => {\n    const infix = new InfixOperator(op, precedence, requireWhitespace);\n    this._binaryOperators.push(infix);\n    this._maxBinaryOpLength = Math.max(this._maxBinaryOpLength, op.length);\n  };\n\n  /**\n   * End Expressions section.\n   */\n\n  /**\n   * Begin Include section.\n   */\n\n  private _rootParser: InkParser;\n  private _openFilenames: string[] = [];\n\n  public readonly IncludeStatement = () => {\n    this.Whitespace();\n\n    if (this.ParseString(\"INCLUDE\") === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    let filename: string = this.Expect(\n      () => this.ParseUntilCharactersFromString(\"\\n\\r\"),\n      \"filename for include statement\"\n    ) as string;\n\n    filename = filename.replace(new RegExp(/[ \\t]+$/g), \"\");\n\n    // Working directory should already have been set up relative to the root ink file.\n    const fullFilename = this.fileHandler.ResolveInkFilename(filename);\n\n    if (this.FilenameIsAlreadyOpen(fullFilename)) {\n      this.Error(\n        `Recursive INCLUDE detected: '${fullFilename}' is already open.`\n      );\n      this.ParseUntilCharactersFromString(\"\\r\\n\");\n      return new IncludedFile(null);\n    } else {\n      this.AddOpenFilename(fullFilename);\n    }\n\n    let includedStory: Story | null = null;\n    let includedString: string = \"\";\n    try {\n      includedString = this._rootParser.fileHandler.LoadInkFileContents(\n        fullFilename\n      );\n    } catch (err) {\n      this.Error(`Failed to load: '${filename}'.\\nError:${err}`);\n    }\n\n    if (includedString) {\n      const parser: InkParser = new InkParser(\n        includedString,\n        filename,\n        this._externalErrorHandler,\n        this._rootParser,\n        this.fileHandler\n      );\n\n      includedStory = parser.ParseStory();\n    }\n\n    this.RemoveOpenFilename(fullFilename);\n\n    // Return valid IncludedFile object even if there were errors when parsing.\n    // We don't want to attempt to re-parse the include line as something else,\n    // and we want to include the bits that *are* valid, so we don't generate\n    // more errors than necessary.\n    return new IncludedFile(includedStory);\n  };\n\n  public readonly FilenameIsAlreadyOpen = (fullFilename: string): boolean =>\n    this._rootParser._openFilenames.includes(fullFilename);\n\n  public readonly AddOpenFilename = (fullFilename: string): void => {\n    this._rootParser._openFilenames.push(fullFilename);\n  };\n\n  public readonly RemoveOpenFilename = (fullFilename: string) => {\n    this._rootParser._openFilenames.splice(\n      this._rootParser._openFilenames.indexOf(fullFilename),\n      1\n    );\n  };\n\n  /**\n   * End Include section.\n   */\n\n  /**\n   * Begin Knot section.\n   */\n\n  public readonly KnotDefinition = (): Knot | null => {\n    const knotDecl: FlowDecl = this.Parse(this.KnotDeclaration) as FlowDecl;\n    if (knotDecl === null) {\n      return null;\n    }\n\n    this.Expect(\n      this.EndOfLine,\n      \"end of line after knot name definition\",\n      this.SkipToNextLine\n    );\n\n    const innerKnotStatements: ParseRule = (): ParsedObject[] =>\n      this.StatementsAtLevel(StatementLevel.Knot);\n\n    const content = this.Expect(\n      innerKnotStatements,\n      \"at least one line within the knot\",\n      this.KnotStitchNoContentRecoveryRule\n    ) as ParsedObject[];\n\n    return new Knot(knotDecl.name, content, knotDecl.args, knotDecl.isFunction);\n  };\n\n  public readonly KnotDeclaration = (): FlowDecl | null => {\n    this.Whitespace();\n\n    if (this.KnotTitleEquals() === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const identifier: Identifier = this.Parse(\n      this.IdentifierWithMetadata\n    ) as Identifier;\n    let knotName: Identifier;\n\n    const isFunc: boolean = identifier?.name === \"function\";\n    if (isFunc) {\n      this.Expect(this.Whitespace, \"whitespace after the 'function' keyword\");\n\n      knotName = this.Parse(this.IdentifierWithMetadata) as Identifier;\n    } else {\n      knotName = identifier;\n    }\n\n    if (knotName === null) {\n      this.Error(`Expected the name of the ${isFunc ? \"function\" : \"knot\"}`);\n      knotName = new Identifier(\"\"); // prevent later null ref\n    }\n\n    this.Whitespace();\n\n    const parameterNames: Argument[] = this.Parse(\n      this.BracketedKnotDeclArguments\n    ) as Argument[];\n\n    this.Whitespace();\n\n    // Optional equals after name\n    this.Parse(this.KnotTitleEquals);\n\n    return new FlowDecl(knotName, parameterNames, isFunc);\n  };\n\n  public readonly KnotTitleEquals = (): string | null => {\n    // 2+ \"=\" starts a knot\n    const multiEquals = this.ParseCharactersFromString(\"=\");\n    if (multiEquals === null || multiEquals.length <= 1) {\n      return null;\n    }\n\n    return multiEquals;\n  };\n\n  public readonly StitchDefinition = (): ParseRuleReturn => {\n    const decl = this.Parse(this.StitchDeclaration) as FlowDecl;\n    if (decl === null) {\n      return null;\n    }\n\n    this.Expect(\n      this.EndOfLine,\n      \"end of line after stitch name\",\n      this.SkipToNextLine\n    );\n\n    const innerStitchStatements: ParseRule = () =>\n      this.StatementsAtLevel(StatementLevel.Stitch);\n\n    const content = this.Expect(\n      innerStitchStatements,\n      \"at least one line within the stitch\",\n      this.KnotStitchNoContentRecoveryRule\n    ) as ParsedObject[];\n\n    return new Stitch(decl.name, content, decl.args, decl.isFunction);\n  };\n\n  public readonly StitchDeclaration = (): FlowDecl | null => {\n    this.Whitespace();\n\n    // Single \"=\" to define a stitch\n    if (this.ParseString(\"=\") === null) {\n      return null;\n    }\n\n    // If there's more than one \"=\", that's actually a knot definition (or divert), so this rule should fail\n    if (this.ParseString(\"=\") !== null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    // Stitches aren't allowed to be functions, but we parse it anyway and report the error later\n    const isFunc: boolean = this.ParseString(\"function\") !== null;\n    if (isFunc) {\n      this.Whitespace();\n    }\n\n    const stitchName: Identifier = this.Parse(\n      this.IdentifierWithMetadata\n    ) as Identifier;\n    if (stitchName === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const flowArgs: Argument[] = this.Parse(\n      this.BracketedKnotDeclArguments\n    ) as Argument[];\n\n    this.Whitespace();\n\n    return new FlowDecl(stitchName, flowArgs, isFunc);\n  };\n\n  public readonly KnotStitchNoContentRecoveryRule = (): ParseRuleReturn => {\n    // Jump ahead to the next knot or the end of the file\n    this.ParseUntil(this.KnotDeclaration, new CharacterSet(\"=\"), null);\n\n    const recoveredFlowContent: ParsedObject[] = [new Text(\"<ERROR IN FLOW>\")];\n\n    return recoveredFlowContent;\n  };\n\n  public readonly BracketedKnotDeclArguments = (): Argument[] | null => {\n    if (this.ParseString(\"(\") === null) {\n      return null;\n    }\n\n    let flowArguments = this.Interleave<Argument>(\n      this.Spaced(this.FlowDeclArgument),\n      this.Exclude(this.String(\",\"))\n    );\n\n    this.Expect(this.String(\")\"), \"closing ')' for parameter list\");\n\n    // If no parameters, create an empty list so that this method is type safe and\n    // doesn't attempt to return the ParseSuccess object\n    if (flowArguments === null) {\n      flowArguments = [];\n    }\n\n    return flowArguments;\n  };\n\n  public readonly FlowDeclArgument = (): Argument | null => {\n    // Possible forms:\n    //  name\n    //  -> name      (variable divert target argument\n    //  ref name\n    //  ref -> name  (variable divert target by reference)\n    const firstIden = this.Parse(this.IdentifierWithMetadata) as Identifier;\n    this.Whitespace();\n\n    const divertArrow = this.ParseDivertArrow();\n\n    this.Whitespace();\n\n    const secondIden = this.Parse(this.IdentifierWithMetadata) as Identifier;\n\n    if (firstIden == null && secondIden === null) {\n      return null;\n    }\n\n    const flowArg = new Argument();\n    if (divertArrow !== null) {\n      flowArg.isDivertTarget = true;\n    }\n\n    // Passing by reference\n    if (firstIden !== null && firstIden.name === \"ref\") {\n      if (secondIden === null) {\n        this.Error(\"Expected an parameter name after 'ref'\");\n      }\n\n      flowArg.identifier = secondIden;\n      flowArg.isByReference = true;\n    } else {\n      // Simple argument name\n      if (flowArg.isDivertTarget) {\n        flowArg.identifier = secondIden;\n      } else {\n        flowArg.identifier = firstIden;\n      }\n\n      if (flowArg.identifier === null) {\n        this.Error(\"Expected an parameter name\");\n      }\n\n      flowArg.isByReference = false;\n    }\n\n    return flowArg;\n  };\n\n  public readonly ExternalDeclaration = (): ExternalDeclaration | null => {\n    this.Whitespace();\n\n    const external = this.Parse(\n      this.IdentifierWithMetadata\n    ) as Identifier | null;\n    if (external === null || external.name != \"EXTERNAL\") {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const funcIdentifier: Identifier =\n      (this.Expect(\n        this.IdentifierWithMetadata,\n        \"name of external function\"\n      ) as Identifier | null) || new Identifier(\"\");\n\n    this.Whitespace();\n\n    let parameterNames = this.Expect(\n      this.BracketedKnotDeclArguments,\n      `declaration of arguments for EXTERNAL, even if empty, i.e. 'EXTERNAL ${funcIdentifier}()'`\n    ) as Argument[];\n\n    if (parameterNames === null) {\n      parameterNames = [];\n    }\n\n    const argNames = parameterNames\n      .map((arg) => arg.identifier?.name)\n      .filter(filterUndef);\n\n    return new ExternalDeclaration(funcIdentifier, argNames);\n  };\n\n  /**\n   * End Knot section.\n   */\n\n  /**\n   * Start Logic section.\n   */\n\n  private _identifierCharSet: CharacterSet | null = null;\n\n  get identifierCharSet(): CharacterSet {\n    if (this._identifierCharSet === null) {\n      (this._identifierCharSet = new CharacterSet())\n        .AddRange(\"A\", \"Z\")\n        .AddRange(\"a\", \"z\")\n        .AddRange(\"0\", \"9\")\n        .Add(\"_\");\n\n      // Enable non-ASCII characters for story identifiers.\n      this.ExtendIdentifierCharacterRanges(this._identifierCharSet);\n    }\n\n    return this._identifierCharSet;\n  }\n\n  public readonly LogicLine = (): ParsedObject | null => {\n    this.Whitespace();\n\n    if (this.ParseString(\"~\") === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    // Some example lines we need to be able to distinguish between:\n    // ~ temp x = 5  -- var decl + assign\n    // ~ temp x      -- var decl\n    // ~ x = 5       -- var assign\n    // ~ x           -- expr (not var decl or assign)\n    // ~ f()         -- expr\n    // We don't treat variable decl/assign as an expression since we don't want an assignment\n    // to have a return value, or to be used in compound expressions.\n    const afterTilde: ParseRule = () =>\n      this.OneOf([\n        this.ReturnStatement,\n        this.TempDeclarationOrAssignment,\n        this.Expression,\n      ]);\n\n    let result = this.Expect(\n      afterTilde,\n      \"expression after '~'\",\n      this.SkipToNextLine\n    ) as ParsedObject;\n\n    // Prevent further errors, already reported expected expression and have skipped to next line.\n    if (result === null) {\n      return new ContentList();\n    }\n\n    // Parse all expressions, but tell the writer off if they did something useless like:\n    //  ~ 5 + 4\n    // And even:\n    //  ~ false && myFunction()\n    // ...since it's bad practice, and won't do what they expect if\n    // they're expecting C's lazy evaluation.\n    if (\n      result instanceof Expression &&\n      !(result instanceof FunctionCall || result instanceof IncDecExpression)\n    ) {\n      this.Error(\n        \"Logic following a '~' can't be that type of expression. It can only be something like:\\n\\t~ return\\n\\t~ var x = blah\\n\\t~ x++\\n\\t~ myFunction()\"\n      );\n    }\n\n    // Line is pure function call? e.g.\n    //  ~ f()\n    // Add extra pop to make sure we tidy up after ourselves.\n    // We no longer need anything on the evaluation stack.\n    const funCall = asOrNull(result, FunctionCall);\n    if (funCall) {\n      funCall.shouldPopReturnedValue = true;\n    }\n\n    // If the expression contains a function call, then it could produce a text side effect,\n    // in which case it needs a newline on the end. e.g.\n    //  ~ printMyName()\n    //  ~ x = 1 + returnAValueAndAlsoPrintStuff()\n    // If no text gets printed, then the extra newline will have to be culled later.\n    // Multiple newlines on the output will be removed, so there will be no \"leak\" for\n    // long running calculations. It's disappointingly messy though :-/\n    if (result.Find(FunctionCall)() !== null) {\n      result = new ContentList(result as any, new Text(\"\\n\"));\n    }\n\n    this.Expect(this.EndOfLine, \"end of line\", this.SkipToNextLine);\n\n    return result as ParsedObject;\n  };\n\n  public readonly VariableDeclaration = (): ParsedObject | null => {\n    this.Whitespace();\n\n    const id = this.Parse(this.Identifier);\n    if (id !== \"VAR\") {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const varName = this.Expect(\n      this.IdentifierWithMetadata,\n      \"variable name\"\n    ) as Identifier;\n\n    this.Whitespace();\n\n    this.Expect(\n      this.String(\"=\"),\n      \"the '=' for an assignment of a value, e.g. '= 5' (initial values are mandatory)\"\n    );\n\n    this.Whitespace();\n\n    const definition = this.Expect(this.Expression, \"initial value for \");\n\n    const expr = definition as Expression;\n\n    if (expr) {\n      const check =\n        expr instanceof NumberExpression ||\n        expr instanceof StringExpression ||\n        expr instanceof DivertTarget ||\n        expr instanceof VariableReference ||\n        expr instanceof List;\n\n      if (!check) {\n        this.Error(\n          \"initial value for a variable must be a number, constant, list or divert target\"\n        );\n      }\n\n      if (this.Parse(this.ListElementDefinitionSeparator) !== null) {\n        this.Error(\n          \"Unexpected ','. If you're trying to declare a new list, use the LIST keyword, not VAR\"\n        );\n      } else if (expr instanceof StringExpression) {\n        // Ensure string expressions are simple\n        const strExpr = expr as StringExpression;\n        if (!strExpr.isSingleString) {\n          this.Error(\"Constant strings cannot contain any logic.\");\n        }\n      }\n\n      const result = new VariableAssignment({\n        assignedExpression: expr,\n        isGlobalDeclaration: true,\n        variableIdentifier: varName,\n      });\n\n      return result;\n    }\n\n    return null;\n  };\n\n  public readonly ListDeclaration = (): VariableAssignment | null => {\n    this.Whitespace();\n\n    const id = this.Parse(this.Identifier);\n    if (id != \"LIST\") {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const varName = this.Expect(\n      this.IdentifierWithMetadata,\n      \"list name\"\n    ) as Identifier;\n\n    this.Whitespace();\n\n    this.Expect(\n      this.String(\"=\"),\n      \"the '=' for an assignment of the list definition\"\n    );\n\n    this.Whitespace();\n\n    const definition = this.Expect(\n      this.ListDefinition,\n      \"list item names\"\n    ) as ListDefinition;\n\n    if (definition) {\n      definition.identifier = new Identifier(varName.name);\n      return new VariableAssignment({\n        variableIdentifier: varName,\n        listDef: definition,\n      });\n    }\n\n    return null;\n  };\n\n  public readonly ListDefinition = (): ListDefinition | null => {\n    this.AnyWhitespace();\n\n    const allElements = this.SeparatedList(\n      this.ListElementDefinition,\n      this.ListElementDefinitionSeparator\n    ) as ListElementDefinition[];\n\n    if (allElements === null) {\n      return null;\n    }\n\n    return new ListDefinition(allElements);\n  };\n\n  public readonly ListElementDefinitionSeparator = (): string | null => {\n    this.AnyWhitespace();\n\n    if (this.ParseString(\",\") === null) {\n      return null;\n    }\n\n    this.AnyWhitespace();\n\n    return \",\";\n  };\n\n  public readonly ListElementDefinition = () => {\n    const inInitialList = this.ParseString(\"(\") !== null;\n    let needsToCloseParen = inInitialList;\n\n    this.Whitespace();\n\n    const name = this.Parse(this.IdentifierWithMetadata) as Identifier | null;\n    if (name === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    if (inInitialList) {\n      if (this.ParseString(\")\") != null) {\n        needsToCloseParen = false;\n        this.Whitespace();\n      }\n    }\n\n    let elementValue: number | null = null;\n    if (this.ParseString(\"=\") !== null) {\n      this.Whitespace();\n\n      const elementValueNum = this.Expect(\n        this.ExpressionInt,\n        \"value to be assigned to list item\"\n      ) as NumberExpression;\n\n      if (elementValueNum !== null) {\n        elementValue = elementValueNum.value as number;\n      }\n\n      if (needsToCloseParen) {\n        this.Whitespace();\n\n        if (this.ParseString(\")\") !== null) {\n          needsToCloseParen = false;\n        }\n      }\n    }\n\n    if (needsToCloseParen) {\n      this.Error(\"Expected closing ')'\");\n    }\n\n    return new ListElementDefinition(name, inInitialList, elementValue);\n  };\n\n  public readonly ConstDeclaration = (): ParsedObject | null => {\n    this.Whitespace();\n\n    const id = this.Parse(this.Identifier);\n    if (id !== \"CONST\") {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const varName = this.Expect(\n      this.IdentifierWithMetadata,\n      \"constant name\"\n    ) as Identifier;\n\n    this.Whitespace();\n\n    this.Expect(\n      this.String(\"=\"),\n      \"the '=' for an assignment of a value, e.g. '= 5' (initial values are mandatory)\"\n    );\n\n    this.Whitespace();\n\n    const expr = this.Expect(\n      this.Expression,\n      \"initial value for \"\n    ) as Expression;\n\n    const check =\n      expr instanceof NumberExpression ||\n      expr instanceof DivertTarget ||\n      expr instanceof StringExpression;\n\n    if (!check) {\n      this.Error(\n        \"initial value for a constant must be a number or divert target\"\n      );\n    } else if (expr instanceof StringExpression) {\n      // Ensure string expressions are simple\n      const strExpr = expr as StringExpression;\n      if (!strExpr.isSingleString) {\n        this.Error(\"Constant strings cannot contain any logic.\");\n      }\n    }\n\n    const result = new ConstantDeclaration(varName, expr);\n\n    return result;\n  };\n\n  public readonly InlineLogicOrGlue = (): ParsedObject =>\n    this.OneOf([this.InlineLogic, this.Glue]) as ParsedObject;\n\n  public readonly Glue = (): Glue | null => {\n    // Don't want to parse whitespace, since it might be important\n    // surrounding the glue.\n    const glueStr = this.ParseString(\"<>\");\n    if (glueStr !== null) {\n      return new Glue(new RuntimeGlue());\n    }\n\n    return null;\n  };\n\n  public readonly InlineLogic = () => {\n    if (this.ParseString(\"{\") === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const logic = this.Expect(\n      this.InnerLogic,\n      \"some kind of logic, conditional or sequence within braces: { ... }\"\n    ) as ParsedObject;\n\n    if (logic === null) {\n      return null;\n    }\n\n    this.DisallowIncrement(logic);\n\n    let contentList = asOrNull(logic, ContentList);\n    if (!contentList) {\n      contentList = new ContentList(logic as any);\n    }\n\n    this.Whitespace();\n\n    this.Expect(this.String(\"}\"), \"closing brace '}' for inline logic\");\n\n    return contentList;\n  };\n\n  public readonly InnerLogic = (): ParsedObject | null => {\n    this.Whitespace();\n\n    // Explicitly try the combinations of inner logic\n    // that could potentially have conflicts first.\n\n    // Explicit sequence annotation?\n    const explicitSeqType: SequenceType = this.ParseObject(\n      this.SequenceTypeAnnotation\n    ) as SequenceType;\n\n    if (explicitSeqType !== null) {\n      const contentLists = this.Expect(\n        this.InnerSequenceObjects,\n        \"sequence elements (for cycle/stoping etc)\"\n      ) as ContentList[];\n\n      if (contentLists === null) {\n        return null;\n      }\n\n      return new Sequence(contentLists, explicitSeqType);\n    }\n\n    // Conditional with expression?\n    const initialQueryExpression = this.Parse(\n      this.ConditionExpression\n    ) as Expression;\n    if (initialQueryExpression) {\n      const conditional = this.Expect(\n        () => this.InnerConditionalContent(initialQueryExpression),\n        \"conditional content following query\"\n      ) as Conditional;\n\n      return conditional;\n    }\n\n    // Now try to evaluate each of the \"full\" rules in turn\n    const rules: ParseRule[] = [\n      // Conditional still necessary, since you can have a multi-line conditional\n      // without an initial query expression:\n      // {\n      //   - true:  this is true\n      //   - false: this is false\n      // }\n      this.InnerConditionalContent as ParseRule,\n      this.InnerSequence,\n      this.InnerExpression,\n    ];\n\n    // Adapted from \"OneOf\" structuring rule except that in\n    // order for the rule to succeed, it has to maximally\n    // cover the entire string within the { }. Used to\n    // differentiate between:\n    //  {myVar}                 -- Expression (try first)\n    //  {my content is jolly}   -- sequence with single element\n    for (const rule of rules) {\n      const ruleId: number = this.BeginRule();\n\n      const result: ParsedObject = this.ParseObject(rule) as ParsedObject;\n      if (result) {\n        // Not yet at end?\n        if (this.Peek(this.Spaced(this.String(\"}\"))) === null) {\n          this.FailRule(ruleId);\n        } else {\n          // Full parse of content within braces\n          return this.SucceedRule(ruleId, result) as ParsedObject;\n        }\n      } else {\n        this.FailRule(ruleId);\n      }\n    }\n\n    return null;\n  };\n\n  public readonly InnerExpression = (): ParsedObject => {\n    const expr = this.Parse(this.Expression) as Expression;\n    if (expr) {\n      expr.outputWhenComplete = true;\n    }\n\n    return expr;\n  };\n\n  public readonly IdentifierWithMetadata = (): Identifier | null => {\n    const id = this.Identifier();\n    if (id === null) {\n      return null;\n    }\n    return new Identifier(id);\n  };\n\n  // Note: we allow identifiers that start with a number,\n  // but not if they *only* comprise numbers\n  public readonly Identifier = (): string | null => {\n    // Parse remaining characters (if any)\n    const name = this.ParseCharactersFromCharSet(this.identifierCharSet);\n    if (name === null) {\n      return null;\n    }\n\n    // Reject if it's just a number\n    let isNumberCharsOnly: boolean = true;\n    for (let c of name) {\n      if (!(c >= \"0\" && c <= \"9\")) {\n        isNumberCharsOnly = false;\n        break;\n      }\n    }\n\n    if (isNumberCharsOnly) {\n      return null;\n    }\n\n    return name;\n  };\n\n  /**\n   * End Logic section.\n   */\n\n  /**\n   * Begin Sequences section.\n   */\n\n  public _sequenceTypeSymbols: CharacterSet = new CharacterSet(\"!&~$\");\n\n  public readonly InnerSequence = (): Sequence | null => {\n    this.Whitespace();\n\n    // Default sequence type\n    let seqType: SequenceType = SequenceType.Stopping;\n\n    // Optional explicit sequence type\n    const parsedSeqType: SequenceType = this.Parse(\n      this.SequenceTypeAnnotation\n    ) as SequenceType;\n\n    if (parsedSeqType !== null) {\n      seqType = parsedSeqType;\n    }\n\n    const contentLists = this.Parse(this.InnerSequenceObjects) as ContentList[];\n    if (contentLists === null || contentLists.length <= 1) {\n      return null;\n    }\n\n    return new Sequence(contentLists, seqType);\n  };\n\n  public readonly SequenceTypeAnnotation = (): ParseRuleReturn => {\n    let annotation = this.Parse(\n      this.SequenceTypeSymbolAnnotation\n    ) as SequenceType;\n\n    if (annotation === null) {\n      annotation = this.Parse(this.SequenceTypeWordAnnotation) as SequenceType;\n    }\n\n    if (annotation === null) {\n      return null;\n    }\n\n    switch (annotation) {\n      case SequenceType.Once:\n      case SequenceType.Cycle:\n      case SequenceType.Stopping:\n      case SequenceType.Shuffle:\n      case SequenceType.Shuffle | SequenceType.Stopping:\n      case SequenceType.Shuffle | SequenceType.Once:\n        break;\n      default:\n        this.Error(`Sequence type combination not supported: ${annotation}`);\n        return SequenceType.Stopping;\n    }\n\n    return annotation;\n  };\n\n  public readonly SequenceTypeSymbolAnnotation = (): ParseRuleReturn => {\n    if (this._sequenceTypeSymbols === null) {\n      this._sequenceTypeSymbols = new CharacterSet(\"!&~$ \");\n    }\n\n    let sequenceType = 0 as SequenceType;\n    const sequenceAnnotations = this.ParseCharactersFromCharSet(\n      this._sequenceTypeSymbols\n    );\n\n    if (sequenceAnnotations === null) {\n      return null;\n    }\n\n    for (const symbolChar of sequenceAnnotations) {\n      switch (symbolChar) {\n        case \"!\":\n          sequenceType |= SequenceType.Once;\n          break;\n        case \"&\":\n          sequenceType |= SequenceType.Cycle;\n          break;\n        case \"~\":\n          sequenceType |= SequenceType.Shuffle;\n          break;\n        case \"$\":\n          sequenceType |= SequenceType.Stopping;\n          break;\n      }\n    }\n\n    if (sequenceType === (0 as SequenceType)) {\n      return null;\n    }\n\n    return sequenceType;\n  };\n\n  public readonly SequenceTypeWordAnnotation = (): ParseRuleReturn => {\n    const sequenceTypes = this.Interleave<SequenceType | null>(\n      this.SequenceTypeSingleWord,\n      this.Exclude(this.Whitespace)\n    );\n\n    if (sequenceTypes === null || sequenceTypes.length === 0) {\n      return null;\n    }\n\n    if (this.ParseString(\":\") === null) {\n      return null;\n    }\n\n    let combinedSequenceType = 0 as SequenceType;\n    for (const seqType of sequenceTypes) {\n      combinedSequenceType |= seqType!;\n    }\n\n    return combinedSequenceType;\n  };\n\n  public readonly SequenceTypeSingleWord = () => {\n    let seqType: SequenceType | null = null;\n\n    const word = this.Parse(this.IdentifierWithMetadata) as Identifier | null;\n\n    if (word !== null) {\n      switch (word.name) {\n        case \"once\":\n          seqType = SequenceType.Once;\n          break;\n        case \"cycle\":\n          seqType = SequenceType.Cycle;\n          break;\n        case \"shuffle\":\n          seqType = SequenceType.Shuffle;\n          break;\n        case \"stopping\":\n          seqType = SequenceType.Stopping;\n          break;\n      }\n    }\n\n    if (seqType === null) {\n      return null;\n    }\n\n    return seqType;\n  };\n\n  public readonly InnerSequenceObjects = (): ContentList[] => {\n    const multiline = this.Parse(this.Newline) !== null;\n\n    let result: ContentList[] | null = null;\n    if (multiline) {\n      result = this.Parse(this.InnerMultilineSequenceObjects) as ContentList[];\n    } else {\n      result = this.Parse(this.InnerInlineSequenceObjects) as ContentList[];\n    }\n\n    return result;\n  };\n\n  public readonly InnerInlineSequenceObjects = (): ContentList[] | null => {\n    const interleavedContentAndPipes = this.Interleave<ParsedObject>(\n      this.Optional(this.MixedTextAndLogic),\n      this.String(\"|\"),\n      null,\n      false\n    );\n\n    if (interleavedContentAndPipes === null) {\n      return null;\n    }\n\n    const result = [];\n\n    // The content and pipes won't necessarily be perfectly interleaved in the sense that\n    // the content can be missing, but in that case it's intended that there's blank content.\n    let justHadContent: boolean = false;\n    for (const contentOrPipe of interleavedContentAndPipes) {\n      // Pipe/separator\n      if ((contentOrPipe as any) === \"|\") {\n        // Expected content, saw pipe - need blank content now\n        if (!justHadContent) {\n          // Add blank content\n          result.push(new ContentList());\n        }\n\n        justHadContent = false;\n      } else {\n        // Real content\n        const content = contentOrPipe as any;\n        if (content === null) {\n          this.Error(\n            `Expected content, but got ${contentOrPipe} (this is an ink compiler bug!)`\n          );\n        } else {\n          result.push(new ContentList(content));\n        }\n\n        justHadContent = true;\n      }\n    }\n\n    // Ended in a pipe? Need to insert final blank content\n    if (!justHadContent) {\n      result.push(new ContentList());\n    }\n\n    return result;\n  };\n\n  public readonly InnerMultilineSequenceObjects = (): ContentList[] | null => {\n    this.MultilineWhitespace();\n\n    const contentLists = this.OneOrMore(\n      this.SingleMultilineSequenceElement\n    ) as ContentList[];\n    if (contentLists === null) {\n      return null;\n    }\n\n    return contentLists;\n  };\n\n  public readonly SingleMultilineSequenceElement = () => {\n    this.Whitespace();\n\n    // Make sure we're not accidentally parsing a divert\n    if (this.ParseString(\"->\") !== null) {\n      return null;\n    }\n\n    if (this.ParseString(\"-\") === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    const content: ParsedObject[] = this.StatementsAtLevel(\n      StatementLevel.InnerBlock\n    );\n\n    if (content === null) {\n      this.MultilineWhitespace();\n    } else {\n      // Add newline at the start of each branch\n      content.unshift(new Text(\"\\n\"));\n    }\n\n    return new ContentList(content);\n  };\n\n  /**\n   * End Sequences section.\n   */\n\n  /**\n   * Begin Statements section.\n   */\n\n  private _statementRulesAtLevel: ParseRule[][] = [];\n  private _statementBreakRulesAtLevel: ParseRule[][] = [];\n\n  public readonly StatementsAtLevel = (\n    level: StatementLevel\n  ): ParsedObject[] => {\n    // Check for error: Should not be allowed gather dashes within an inner block\n    if (level === StatementLevel.InnerBlock) {\n      const badGatherDashCount = this.Parse(this.GatherDashes) as ParsedObject;\n      if (badGatherDashCount !== null) {\n        this.Error(\n          \"You can't use a gather (the dashes) within the { curly braces } context. For multi-line sequences and conditions, you should only use one dash.\"\n        );\n      }\n    }\n\n    return this.Interleave<ParsedObject>(\n      this.Optional(this.MultilineWhitespace),\n      () => this.StatementAtLevel(level),\n      () => this.StatementsBreakForLevel(level)\n    );\n  };\n\n  public readonly StatementAtLevel = (level: StatementLevel): ParsedObject => {\n    const rulesAtLevel: ParseRule[] = this._statementRulesAtLevel[\n      level as number\n    ];\n    const statement = this.OneOf(rulesAtLevel) as ReturnType;\n\n    // For some statements, allow them to parse, but create errors, since\n    // writers may think they can use the statement, so it's useful to have\n    // the error message.\n    if (level === StatementLevel.Top) {\n      if (statement instanceof ReturnType) {\n        this.Error(\"should not have return statement outside of a knot\");\n      }\n    }\n\n    return statement;\n  };\n\n  public readonly StatementsBreakForLevel = (\n    level: StatementLevel\n  ): ParseRuleReturn => {\n    this.Whitespace();\n\n    const breakRules: ParseRule[] = this._statementBreakRulesAtLevel[\n      level as number\n    ];\n    const breakRuleResult = this.OneOf(breakRules);\n    if (breakRuleResult === null) {\n      return null;\n    }\n\n    return breakRuleResult;\n  };\n\n  public readonly GenerateStatementLevelRules = () => {\n    const levels = Object.values(StatementLevel);\n\n    this._statementRulesAtLevel = \"f\"\n      .repeat(levels.length)\n      .split(\"f\")\n      .map(() => []);\n\n    this._statementBreakRulesAtLevel = \"f\"\n      .repeat(levels.length)\n      .split(\"f\")\n      .map(() => []);\n\n    for (const level of levels) {\n      const rulesAtLevel: ParseRule[] = [];\n      const breakingRules: ParseRule[] = [];\n\n      // Diverts can go anywhere\n      rulesAtLevel.push(this.Line(this.MultiDivert));\n\n      // Knots can only be parsed at Top/Global scope\n      if (level >= StatementLevel.Top) {\n        rulesAtLevel.push(this.KnotDefinition);\n      }\n\n      rulesAtLevel.push(this.Line(this.Choice));\n\n      rulesAtLevel.push(this.Line(this.AuthorWarning));\n\n      // Gather lines would be confused with multi-line block separators, like\n      // within a multi-line if statement\n      if (level > StatementLevel.InnerBlock) {\n        rulesAtLevel.push(this.Gather);\n      }\n\n      // Stitches (and gathers) can (currently) only go in Knots and top level\n      if (level >= StatementLevel.Knot) {\n        rulesAtLevel.push(this.StitchDefinition);\n      }\n\n      // Global variable declarations can go anywhere\n      rulesAtLevel.push(this.Line(this.ListDeclaration));\n      rulesAtLevel.push(this.Line(this.VariableDeclaration));\n      rulesAtLevel.push(this.Line(this.ConstDeclaration));\n      rulesAtLevel.push(this.Line(this.ExternalDeclaration));\n\n      // Global include can go anywhere\n      rulesAtLevel.push(this.Line(this.IncludeStatement));\n\n      // Normal logic / text can go anywhere\n      rulesAtLevel.push(this.LogicLine);\n      rulesAtLevel.push(this.LineOfMixedTextAndLogic);\n\n      // --------\n      // Breaking rules\n\n      // Break current knot with a new knot\n      if (level <= StatementLevel.Knot) {\n        breakingRules.push(this.KnotDeclaration);\n      }\n\n      // Break current stitch with a new stitch\n      if (level <= StatementLevel.Stitch) {\n        breakingRules.push(this.StitchDeclaration);\n      }\n\n      // Breaking an inner block (like a multi-line condition statement)\n      if (level <= StatementLevel.InnerBlock) {\n        breakingRules.push(this.ParseDashNotArrow);\n        breakingRules.push(this.String(\"}\"));\n      }\n\n      this._statementRulesAtLevel[level as number] = rulesAtLevel;\n      this._statementBreakRulesAtLevel[level as number] = breakingRules;\n    }\n  };\n\n  public readonly SkipToNextLine = (): typeof ParseSuccess => {\n    this.ParseUntilCharactersFromString(\"\\n\\r\");\n    this.ParseNewline();\n\n    return ParseSuccess;\n  };\n\n  // Modifier to turn a rule into one that expects a newline on the end.\n  // e.g. anywhere you can use \"MixedTextAndLogic\" as a rule, you can use\n  // \"Line(MixedTextAndLogic)\" to specify that it expects a newline afterwards.\n  public readonly Line = (inlineRule: ParseRule): ParseRule => () => {\n    const result = this.ParseObject(inlineRule);\n    if (result === null) {\n      return null;\n    }\n\n    this.Expect(this.EndOfLine, \"end of line\", this.SkipToNextLine);\n\n    return result;\n  };\n\n  /**\n   * End Statements section.\n   */\n\n  /**\n   * Begin Tags section.\n   */\n\n  private _endOfTagCharSet: CharacterSet = new CharacterSet(\"#\\n\\r\\\\\");\n\n  public readonly Tag = (): Tag | null => {\n    this.Whitespace();\n\n    if (this.ParseString(\"#\") === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    let sb = \"\";\n    do {\n      // Read up to another #, end of input or newline\n      const tagText: string =\n        this.ParseUntilCharactersFromCharSet(this._endOfTagCharSet) || \"\";\n      sb += tagText;\n\n      // Escape character\n      if (this.ParseString(\"\\\\\") !== null) {\n        const c: string = this.ParseSingleCharacter();\n        if (c !== \"\\0\") {\n          sb += c;\n        }\n\n        continue;\n      }\n\n      break;\n    } while (true);\n\n    const fullTagText = sb.trim();\n\n    return new Tag(new RuntimeTag(fullTagText));\n  };\n\n  public readonly Tags = (): Tag[] | null => {\n    const tags = this.OneOrMore(this.Tag) as Tag[];\n    if (tags === null) {\n      return null;\n    }\n\n    return tags;\n  };\n\n  /**\n   * End Tags section.\n   */\n\n  /**\n   * Begin Whitespace section.\n   */\n\n  private _inlineWhitespaceChars: CharacterSet = new CharacterSet(\" \\t\");\n\n  // Handles both newline and endOfFile\n  public readonly EndOfLine = () => this.OneOf([this.Newline, this.EndOfFile]);\n\n  // Allow whitespace before the actual newline\n  public readonly Newline = (): typeof ParseSuccess | null => {\n    this.Whitespace();\n\n    const gotNewline: boolean = this.ParseNewline() !== null;\n\n    // Optional \\r, definite \\n to support Windows (\\r\\n) and Mac/Unix (\\n)\n\n    if (!gotNewline) {\n      return null;\n    }\n\n    return ParseSuccess;\n  };\n\n  public readonly EndOfFile = (): typeof ParseSuccess | null => {\n    this.Whitespace();\n\n    if (!this.endOfInput) return null;\n\n    return ParseSuccess;\n  };\n\n  // General purpose space, returns N-count newlines (fails if no newlines)\n  public readonly MultilineWhitespace = (): typeof ParseSuccess | null => {\n    let newlines: ParseRuleReturn[] | null = this.OneOrMore(this.Newline);\n    if (newlines === null) {\n      return null;\n    }\n\n    // Use content field of Token to say how many newlines there were\n    // (in most circumstances it's unimportant)\n    const numNewlines: number = newlines.length;\n    if (numNewlines >= 1) {\n      return ParseSuccess;\n    }\n\n    return null;\n  };\n\n  public readonly Whitespace = (): typeof ParseSuccess | null => {\n    const doneParsed = this.ParseCharactersFromCharSet(\n      this._inlineWhitespaceChars\n    );\n\n    if (doneParsed !== null) {\n      return ParseSuccess;\n    }\n\n    return null;\n  };\n\n  public readonly Spaced = (rule: ParseRule): ParseRule => () => {\n    this.Whitespace();\n\n    const result = this.ParseObject(rule);\n    if (result === null) {\n      return null;\n    }\n\n    this.Whitespace();\n\n    return result;\n  };\n\n  public readonly AnyWhitespace = (): typeof ParseSuccess | null => {\n    let anyWhitespace: boolean = false;\n\n    while (this.OneOf([this.Whitespace, this.MultilineWhitespace]) !== null) {\n      anyWhitespace = true;\n    }\n\n    return anyWhitespace ? ParseSuccess : null;\n  };\n\n  public readonly MultiSpaced = (rule: ParseRule): ParseRuleReturn => () => {\n    this.AnyWhitespace();\n\n    const result = this.ParseObject(rule);\n    if (result === null) {\n      return null;\n    }\n\n    this.AnyWhitespace();\n\n    return result;\n  };\n\n  /**\n   * End Whitespace section.\n   */\n}\n","import { Container as RuntimeContainer } from \"../../../../engine/Container\";\nimport { ControlCommand as RuntimeControlCommand } from \"../../../../engine/ControlCommand\";\nimport { Expression } from \"./Expression\";\nimport { ParsedObject } from \"../Object\";\nimport { Text } from \"../Text\";\nimport { asOrNull } from \"../../../../engine/TypeAssertion\";\n\nexport class StringExpression extends Expression {\n  get isSingleString() {\n    if (this.content.length !== 1) {\n      return false;\n    }\n\n    const c = this.content[0];\n    if (!(c instanceof Text)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  constructor(content: ParsedObject[]) {\n    super();\n\n    this.AddContent(content);\n  }\n\n  public readonly GenerateIntoContainer = (\n    container: RuntimeContainer\n  ): void => {\n    container.AddContent(RuntimeControlCommand.BeginString());\n\n    for (const c of this.content) {\n      container.AddContent(c.runtimeObject);\n    }\n\n    container.AddContent(RuntimeControlCommand.EndString());\n  };\n\n  public readonly toString = (): string => {\n    let sb = \"\";\n    for (const c of this.content) {\n      sb += c;\n    }\n\n    return sb;\n  };\n\n  // Equals override necessary in order to check for CONST multiple definition equality\n  public readonly Equals = (obj: ParsedObject): boolean => {\n    const otherStr = asOrNull(obj, StringExpression);\n    if (otherStr === null) {\n      return false;\n    }\n\n    // Can only compare direct equality on single strings rather than\n    // complex string expressions that contain dynamic logic\n    if (!this.isSingleString || !otherStr.isSingleString) {\n      return false;\n    }\n\n    const thisTxt = this.toString();\n    const otherTxt = otherStr.toString();\n    return thisTxt === otherTxt;\n  };\n}\n","import { Tag as RuntimeTag } from \"../../../engine/Tag\";\nimport { Wrap } from \"./Wrap\";\n\nexport class Tag extends Wrap<RuntimeTag> {\n  constructor(tag: RuntimeTag) {\n    super(tag);\n  }\n}\n","import { CompilerOptions } from \"./CompilerOptions\";\nimport { DebugSourceRange } from \"./DebugSourceRange\";\nimport { ErrorType } from \"./Parser/ErrorType\";\nimport { InkParser } from \"./Parser/InkParser\";\nimport { Story as RuntimeStory } from \"../engine/Story\";\nimport { Story as ParsedStory } from \"./Parser/ParsedHierarchy/Story\";\nimport { DebugMetadata } from \"../engine/DebugMetadata\";\nimport { StringValue } from \"../engine/Value\";\nimport { asOrNull } from \"../engine/TypeAssertion\";\n\nexport { CompilerOptions } from \"./CompilerOptions\";\nexport { InkList, Story } from \"../engine/Story\";\n\nexport class Compiler {\n  private _errors: string[] = [];\n  get errors(): string[] {\n    return this._errors;\n  }\n\n  private _warnings: string[] = [];\n  get warnings(): string[] {\n    return this._warnings;\n  }\n\n  private _authorMessages: string[] = [];\n  get authorMessages(): string[] {\n    return this._authorMessages;\n  }\n\n  private _inputString: string;\n  get inputString(): string {\n    return this._inputString;\n  }\n\n  private _options: CompilerOptions;\n  get options(): CompilerOptions {\n    return this._options;\n  }\n\n  private _parsedStory: ParsedStory | null = null;\n  get parsedStory(): ParsedStory {\n    if (!this._parsedStory) {\n      throw new Error();\n    }\n\n    return this._parsedStory;\n  }\n\n  private _runtimeStory: RuntimeStory | null = null;\n  get runtimeStory(): RuntimeStory {\n    if (!this._runtimeStory) {\n      throw new Error(\"Compilation failed.\");\n    }\n\n    return this._runtimeStory;\n  }\n\n  private _parser: InkParser | null = null;\n  get parser(): InkParser {\n    if (!this._parser) {\n      throw new Error();\n    }\n\n    return this._parser;\n  }\n\n  private _debugSourceRanges: DebugSourceRange[] = [];\n  get debugSourceRanges(): DebugSourceRange[] {\n    return this._debugSourceRanges;\n  }\n\n  constructor(inkSource: string, options: CompilerOptions | null = null) {\n    this._inputString = inkSource;\n    this._options = options || new CompilerOptions();\n  }\n\n  public readonly Compile = (): RuntimeStory => {\n    this._parser = new InkParser(\n      this.inputString,\n      this.options.sourceFilename || null,\n      this.OnError,\n      null,\n      this.options.fileHandler\n    );\n\n    this._parsedStory = this.parser.ParseStory();\n\n    if (this.errors.length === 0) {\n      this.parsedStory.countAllVisits = this.options.countAllVisits;\n      this._runtimeStory = this.parsedStory.ExportRuntime(this.OnError);\n    } else {\n      this._runtimeStory = null;\n    }\n\n    return this.runtimeStory;\n  };\n\n  public readonly RetrieveDebugSourceForLatestContent = (): void => {\n    for (const outputObj of this.runtimeStory.state.outputStream) {\n      const textContent = asOrNull(outputObj, StringValue);\n      if (textContent !== null) {\n        const range = new DebugSourceRange(\n          textContent.value?.length || 0,\n          textContent.debugMetadata,\n          textContent.value || \"unknown\"\n        );\n\n        this.debugSourceRanges.push(range);\n      }\n    }\n  };\n\n  public readonly DebugMetadataForContentAtOffset = (\n    offset: number\n  ): DebugMetadata | null => {\n    let currOffset = 0;\n\n    let lastValidMetadata: DebugMetadata | null = null;\n    for (const range of this.debugSourceRanges) {\n      if (range.debugMetadata !== null) {\n        lastValidMetadata = range.debugMetadata;\n      }\n\n      if (offset >= currOffset && offset < currOffset + range.length) {\n        return lastValidMetadata;\n      }\n\n      currOffset += range.length;\n    }\n\n    return null;\n  };\n\n  public readonly OnError = (message: string, errorType: ErrorType) => {\n    switch (errorType) {\n      case ErrorType.Author:\n        this._authorMessages.push(message);\n        break;\n\n      case ErrorType.Warning:\n        this._warnings.push(message);\n        break;\n\n      case ErrorType.Error:\n        this._errors.push(message);\n        break;\n    }\n\n    if (this.options.errorHandler !== null) {\n      this.options.errorHandler(message, errorType);\n    }\n  };\n}\n"],"names":["ErrorType","CompilerOptions","sourceFilename","pluginNames","countAllVisits","errorHandler","fileHandler","DebugSourceRange","length","debugMetadata","text","Argument","identifier","isByReference","isDivertTarget","asOrNull","obj","type","unsafeTypeAssertion","asOrThrows","Error","asINamedContentOrNull","hasValidName","name","nullIfUndefined","isEquatable","_typeof","Equals","filterUndef","element","undefined","Debug","ParsedObject","_this","typeName","subContent","content","Array","isArray","ss","hasOwnProperty","parent","push","index","splice","queryFunc","tObj","nestedResult","Find","foundSoFar","found","FindAll","message","source","this","_debugMetadata","value","Boolean","ancestor","_runtimeObject","GenerateRuntimeObject","runtimeObject","path","result","reverse","context","ResolveReferences","isWarning","_alreadyHadError","_alreadyHadWarning","AuthorWarning","warningMessage","Warning","Path","_components","_componentsString","_isRelative","arguments","componentsString","Component","head","tail","concat","relative","slice","self","lastComponentIdx","i","l","isIndex","pathToAppend","p","upwardMoves","isParent","join","isRelative","substring","split","str","test","parseInt","otherPath","c","indexOrName","parentId","toString","otherComp","Assert","condition","console","warn","trace","variable","NullException","throwNullException","InkObject","root","rootContentContainer","targetContent","ContentAtPath","dm","startLineNumber","_path","comps","child","container","Container","namedChild","unshift","indexOf","nearestContainer","GetComponent","contentContainer","globalPath","ownPath","minPathLength","Math","min","lastSharedPathCompIndex","ownComp","numUpwardsMoves","componentCount","newPathComps","up","ToParent","down","globalPathStr","relativePathStr","PathByAppendingPath","ConvertPathToRelative","prop","StringBuilder","string","Append","format","args","replace","match","num","InkListItem","originName","itemName","fullName","nameParts","otherItem","JSON","stringify","key","parse","isLikeInkListItem","Null","inkListItem","item","InkList","otherList","_originNames","originNames","origins","singleOriginListName","originStory","SetInitialOriginName","listDefinitions","def","TryListGetDefinition","exists","singleElement","Add","Key","Value","itemOrItemName","AddItem","origin","intVal","TryGetValueForItem","foundListDef","ContainsItemWithName","itemVal","ValueForItem","fromSerializedKey","has","serialized","serializedKey","set","delete","size","maxOriginName","maxItem","every","Count","initialOriginName","initialOriginNames","max","isNull","list","items","ContainsKey","union","intersection","listToRemove","minItem","minBound","maxBound","ordered","orderedItems","minValue","maxValue","Number","MAX_SAFE_INTEGER","isInteger","subList","SetInitialOriginNames","otherInkList","sort","x","y","localeCompare","sb","NaN","myListItem","listValue","FindSingleItemListWithName","Map","StoryException","useEndLineNumber","tryGetValueFromMap","map","val","get","ValueType","AbstractValue","Create","valueObject","targetType","valueType","preferredNumberType","Int","IntValue","Float","isNaN","FloatValue","BoolValue","StringValue","String","DivertTargetValue","ListValue","Bool","newType","BadCastException","_isNewline","_this2","_isInlineWhitespace","isNewline","isInlineWhitespace","parsedInt","defaultValue","tryParseInt","parsedFloat","parseFloat","tryParseFloat","targetPath","DivertTarget","VariablePointerValue","variableName","contextIndex","_contextIndex","VariablePointer","listOrSingleItem","singleValue","List","oldValue","newValue","oldList","newList","SearchResult","approximate","searchResult","_content","AddContent","namedOnlyContentDict","namedContent","inkObject","named","existingNamedOnly","namedOnlyContent","AddToNamedContentOnly","flags","visitsShouldBeCounted","CountFlags","Visits","turnIndexShouldBeCounted","Turns","countingAtStartOnly","CountStartOnly","flag","_pathToFirstLeafContent","internalPathToFirstLeafContent","components","contentObjOrList","contentObj","TryAddNamedContent","namedContentObj","AssertType","partialPathStart","partialPathLength","currentContainer","currentObj","comp","foundObj","ContentWithPathComponent","otherContainer","component","foundContent","BuildStringOfHierarchy","indentation","pointedObj","appendIndentation","AppendFormat","AppendLine","onlyNamed","ControlCommand","commandType","CommandType","NotSet","_commandType","EvalStart","EvalOutput","EvalEnd","Duplicate","PopEvaluatedValue","PopFunction","PopTunnel","BeginString","EndString","NoOp","ChoiceCount","TurnsSince","ReadCount","Random","SeedRandom","VisitIndex","SequenceShuffleIndex","StartThread","Done","End","ListFromInt","ListRange","ListRandom","Expression","RuntimeContainer","RuntimeControlCommand","GenerateIntoContainer","outputWhenComplete","_prototypeRuntimeConstantExpression","copy","Copy","Void","NativeFunctionCall","GenerateNativeFunctionsIfNecessary","numberOfParameters","_isPrototype","_name","_nativeFunctions","_prototype","_numberOfParameters","parameters","Call","hasList","CallBinaryListOperation","coercedParams","CoerceValuesToSingleType","coercedType","CallType","parametersOfSingleType","param1","valType","val1","paramCount","_operationFuncs","opForTypeObj","val2","opForType","resultVal","CallListIncrementOperation","v1","v2","op","asBooleanOrThrows","isTruthy","listIntParams","listVal","resultInkList","listItemKey","listItemValue","listItem","intOp","targetInt","itemOrigin","incrementedItem","TryGetItemWithValue","parametersIn","specialCaseList","parametersOut","originOfMaxItem","castedValue","Cast","functionName","t","AddIntBinaryOp","Subtract","Multiply","Divide","floor","Mod","AddIntUnaryOp","Negate","Equal","Greater","Less","GreaterThanOrEquals","LessThanOrEquals","NotEquals","Not","And","Or","Max","Min","Pow","pow","Floor","Identity","Ceiling","AddFloatBinaryOp","AddFloatUnaryOp","ceil","AddStringBinaryOp","Has","includes","Hasnt","AddListBinaryOp","Union","Without","Contains","Intersect","GreaterThan","LessThan","AddListUnaryOp","Invert","inverse","All","all","ListMin","MinAsList","ListMax","MaxAsList","ValueOfList","AddOpToNativeFunc","d1","d2","nativeFunc","AddOpFuncForType","NumberExpression","subtype","isInt","isFloat","isBool","UnaryExpression","inner","innerExpression","CallWithName","nativeNameForOp","innerNumber","BinaryExpression","left","right","opName","leftExpression","rightExpression","NativeNameForOp","leftUnary","CharacterSet","arg","Set","add","start","end","charCodeAt","fromCharCode","chars","AddCharacters","AddRange","CharacterRange","_start","_end","excludes","_correspondingCharSet","ii","_excludes","PushPopType","ChoicePoint","onceOnly","_pathOnChoice","choiceTargetObj","choiceTarget","ResolvePath","pathOnChoice","CompactPathString","hasCondition","hasStartContent","hasChoiceOnlyContent","isInvisibleDefault","SymbolType","Pointer","PathByAppendingComponent","Divert","stackPushType","pushesToStack","_targetPath","targetObj","targetPointer","Resolve","_targetPointer","lastComponent","StartOf","variableDivertName","otherDivert","hasVariableTarget","targetStr","isConditional","Function","targetPathString","VariableAssignment","isNewDeclaration","isGlobal","Choice","startContent","choiceOnlyContent","innerContent","_outerContainer","_runtimeChoice","_returnToR1","varAssign","RuntimeVariableAssignment","_divertToStartContentOuter","RuntimeDivert","_startContentRuntimeContainer","varDivert","_r1Label","choiceOnlyRuntimeContent","AddContentsOfContainer","_innerContentContainer","_returnToR2","_divertToStartContentInner","_r2Label","innerChoiceOnlyContent","story","indentationDepth","_condition","innerContentContainer","runtimeChoice","CheckForNamingCollisions","SubFlowAndWeave","StringParserElement","fromElement","_uniqueIdCounter","uniqueId","characterIndex","characterInLineIndex","lineIndex","customFlags","reportedErrorInScope","StringParserState","_stack","_numElements","prevElement","newElement","CopyFrom","expectedRuleId","currentElement","penultimateEl","lastEl","SquashFrom","ParseSuccess","Symbol","StringParser","state","Push","Pop","stateAtSucceedRule","Peek","stateAtBeginRule","PeekPenultimate","RuleDidSucceed","Squash","finalResult","rule","recoveryRule","ParseObject","butSaw","lineRemainder","LineRemainder","ErrorOnLine","lineNumber","errorReportedAlreadyInScope","errorType","NoteErrorReported","hadError","ParseUntilCharactersFromString","trueOrFalse","ruleId","BeginRule","stackHeightBefore","stackHeight","FailRule","SucceedRule","array","results","ParseString","flatten","resultCollection","ruleA","ruleB","untilTerminator","firstA","TryAddResultToList","lastMainResult","outerResult","remainingLength","cli","li","success","tempIdx","_chars","maxCount","ParseCharactersFromString","charSet","ParseCharactersFromCharSet","maxCountOrShouldIncludeStrChars","shouldIncludeChars","startIndex","count","lastCharIndex","CancelRule","oldIndex","oldCharacterInLineIndex","negative","parsedString","numbersCharacterSet","MIN_SAFE_INTEGER","leadingInt","ParseInt","afterDecimalPointStr","strPreProc","PreProcessInputString","inputString","stopRule","pauseCharacters","endCharacters","pauseAndEnd","values","partialParsedString","ParseUntilCharactersFromCharSet","endOfInput","pauseCharacter","currentCharacter","FlowLevel","CommentEliminator","stringList","Interleave","Optional","CommentsAndNewlines","MainInk","ParseUntil","_commentOrNewlineStartCharacter","newLines","ParseNewline","ParseSingleComment","OneOf","EndOfLineComment","BlockComment","_newlineCharacters","startLineIndex","commentResult","_commentBlockEndCharacter","repeat","Conditional","initialCondition","branches","branchContainer","ownExpression","isElse","_reJoinTarget","pathToReJoin","branch","returnDivert","Text","ConstantDeclaration","assignedExpression","constantIdentifier","_expression","Var","Gather","argOne","argTwo","baseTargetLevel","WeavePoint","dotSeparatedComponents","baseTargetObject","ResolveBaseTarget","ResolveTailComponents","originalContext","firstComp","firstComponent","ancestorContext","deepSearch","foundBase","GetChildFromContext","rootTarget","foundComponent","compName","minimumExpectedLevel","foundFlow","FlowBase","flowLevel","childName","minimumLevel","forceDeepSearch","ambiguousChildLevel","weaveContext","Weave","WeavePointNamed","flowContext","shouldDeepSearch","Knot","ContentWithNameAtLevel","Object","_baseTargetLevel","baseLevelIsAmbiguous","Story","_dotSeparatedComponents","filter","ReturnType","returnedExpression","ClosestFlowBase","iamFlowbase","Identifier","topLevelObjects","isFunction","isIncludedStory","contentObjs","isRootStory","weaveObjs","subFlowObjs","_subFlowsByName","subFlow","_firstChildFlow","finalContent","_rootWeave","varName","fromNode","ownerFlow","isArgument","variableDeclarations","isTemporary","varDecl","varab","prevDeclError","ResolveWeavePointNaming","foundReturn","CheckForDisallowedFunctionFlowControl","Stitch","GenerateArgumentVariableAssignments","contentIdx","childFlow","childFlowRuntime","hasParameters","_startingSubFlowDivert","_startingSubFlowRuntime","existingChild","errorMsg","GetType","ValidateTermination","WarningInTermination","paramName","assign","level","weavePointResult","DeepSearchForAnyLevelContent","weaveResultSelf","deepResult","divert","isFunctionCall","choice","terminatingObject","terminatingDivert","isTunnel","target","PreProcessTopLevelObjects","SplitWeaveAndSubFlowContent","_","Arg","jj","symbolType","ContentList","objects","RegExp","contentObjRuntime","dontFlatten","DontFlattenContainer","moreObjects","VariableReference","pathForCount","pathStringForCount","pathIdentifiers","constantValue","constants","GenerateConstantIntoContainer","isConstantReference","_runtimeVarRef","RuntimeVariableReference","listItemName","listName","ResolveListItem","isListItemReference","id","parsedPath","targetForCount","ResolveFromContext","containerForCounting","runtimePath","targetFlow","ResolveVariableWithName","FunctionCall","foundList","ResolveList","usingProxyDivert","isChoiceCount","isTurns","isTurnsSince","isReadCount","divertTarget","variableDivertTarget","_divertTargetToCount","_variableReferenceToCount","isRandom","isSeedRandom","isListRange","isListRandom","CallExistsWithName","nativeCall","msg","RuntimeInkList","_proxyDivert","shouldPopReturnedValue","strArgs","runtimeDivert","attemptingTurnCountOfVariableTarget","targetObject","runtimeVarRef","SequenceType","MultipleConditionExpression","conditionExpressions","isFirst","subExpressions","_runtimeDivert","_runtimeDivertTargetValue","runtimeDivertTargetValue","otherDivTarget","isDone","isEnd","usageContext","badUsage","foundUsage","usageParent","binaryExprParent","funcCall","ConditionalSingleBranch","parentFunc","ResolveTargetContent","CheckArgumentValidity","requiresArgCodeGen","isThread","targetArguments","argToPass","argExpected","varRef","varPointer","Tunnel","isEmpty","variableTargetName","PathAsVariableName","flowBaseScope","resolveResult","argument","find","a","numArgs","butClause","flowArg","divArgExpr","knotCountPath","externalName","external","externals","externalArgCount","argumentNames","ownArgCount","returnString","targetWasFound","isBuiltIn","isExternal","numberOfComponents","IsBuiltIn","IsExternal","externalArgs","RuntimePath","CheckExternalArgumentValidity","GatherPointToResolve","targetRuntimeObj","SequenceDivertToResolve","CustomFlags","Sequence","elementContentLists","sequenceType","_sequenceDivertsToResolve","once","Once","cycle","Cycle","stopping","Stopping","shuffle","Shuffle","seqBranchCount","sequenceElements","postShuffleNoOp","lastIdx","skipShuffleDivert","AddDivertToResolve","elementCountToShuffle","postSequenceNoOp","elIndex","sequenceDivert","contentContainerForSequenceBranch","InsertContent","seqBranchCompleteDivert","elementContentList","seqElObject","toResolve","TunnelOnwards","divertAfter","returnRuntimeContainer","evalStart","evalEnd","cmd","_overrideDivertTarget","_divertAfter","ListDefinition","_items","_itemNameToValues","itemDefinitions","_elementsByName","el","initialValues","itemDef","inInitialList","RuntimeInkListItem","seriesValue","currentValue","e","explicitValue","allItems","RuntimeListDefinition","isGlobalDeclaration","isTemporaryNewDeclaration","listDef","variableIdentifier","newDeclScope","isNewTemporaryDeclaration","AddNewVariableDeclaration","expression","listDefinition","_runtimeAssignment","variableAssignment","isDeclaration","Temp","variableReference","resolvedVarAssignment","cont","indentIndex","namedWeavePoints","w","_namedWeavePoints","weavePoint","existingWeavePoint","existingObj","weaveIndentIdx","baseIndentIndex","innerWeaveStartIdx","innerWeaveObj","weaveContentCount","weaveContent","weave","contentList","_rootContainer","looseEnds","gatherPointsToResolve","AddRuntimeForWeavePoint","AddRuntimeForNestedWeave","AddGeneralRuntimeContent","PassLooseEndsToAncestors","gather","autoEnter","hasSeenChoiceInSection","gatherContainer","runtimeContainer","_unnamedGatherCount","rootContainer","looseEnd","looseWeavePoint","AddRuntimeForGather","previousWeavePoint","_choiceCount","addContentToPreviousWeavePoint","WeavePointHasLooseEnd","closestInnerWeaveAncestor","closestOuterWeaveAncestor","nested","weaveAncestor","received","ReceiveLooseEnd","receivingWeave","childWeaveLooseEnd","varAss","returned","IsGlobalDeclaration","parentWeave","laterObj","badTerminationHandler","lastParsedSignificantObject","looseEndFlow","ContentThatFollowsWeavePoint","ValidateFlowOfObjectsTerminates","terminatingObj","conditional","toLowerCase","objFlow","defaultObj","terminated","flowObj","d","innerDivert","ancestorFlows","ancestry","flow","weavePointName","otherContentWithName","DetermineBaseIndentationFromContent","ConstructWeaveHierarchyFromIndentation","lastObject","lastText","lastWeave","isNestedWeave","BadNestedTerminationHandler","gatherPoint","CheckForWeavePointNamingCollisions","_innerWeave","startsWith","duplicatesStackValue","matchingEquality","_conditionalDivert","isTrueBranch","needsEval","_contentContainer","GenerateRuntimeForContent","isInline","_ownExpression","StatementLevel","DebugMetadata","newDebugMetadata","fileName","sourceName","startCharacterNumber","endLineNumber","endCharacterNumber","ExternalDeclaration","AddExternal","FlowDecl","Wrap","_objToWrap","Glue","glue","IncDecExpression","varIdentifier","isIncOrExpression","isInc","varResolveResult","incrementDecrementWord","IncludedFile","includedStory","InfixOperator","precedence","requireWhitespace","parentStory","stitchName","subFlowsByName","knotWithStitchName","stitch","itemIdentifierList","runtimeRawList","itemIdentifier","ListElementDefinition","indentifier","parentList","ListItem","Tag","tagText","ListDefinitionsOrigin","lists","_lists","_allUnambiguousListValueCache","listOfLists","definition","JsonSerialisation","jArray","skipLast","jTok","runtimeObj","JTokenToRuntimeObject","writer","dictionary","WriteObjectStart","WritePropertyStart","WriteRuntimeObject","WritePropertyEnd","WriteObjectEnd","WriteArrayStart","WriteArrayEnd","dict","WriteIntProperty","WriteRuntimeContainer","divTypeKey","WriteProperty","choicePoint","pathStringOnChoice","boolVal","WriteBool","WriteInt","floatVal","WriteFloat","strVal","Write","WriteStringStart","WriteStringInner","WriteStringEnd","WriteInkList","divTargetVal","varPtrVal","controlCmd","_controlCommandNames","readCountPath","tag","WriteChoice","jObject","token","firstChar","propValue","varPtr","isDivert","divPushType","readCountVarRef","isVarAss","isGlobalVar","isNewDecl","listContent","rawList","namesAsObjs","nameToVal","JObjectToChoice","JArrayToContainer","toJson","me","removes","space","k","v","some","r","withoutName","countFlags","hasNameProperty","hasTerminator","namedContainer","WriteNull","JArrayToRuntimeObjList","namedContentItem","namedSubContainer","jObj","sourcePath","originalThreadIndex","WritePropertyNameStart","WritePropertyNameInner","WritePropertyNameEnd","listDefJson","defsObj","allDefs","nameValueKey","nameValue","TOTAL_VALUES","CallStack","storyContext","_startOfRoot","Reset","toCopy","_threads","otherThread","_threadCounter","callStack","elements","cs","callstack","Thread","Element","jThreadObj","thread","WriteObject","WriteJson","newThread","currentThread","threadIndex","forkedThread","canPopThread","elementIsEvaluateFromGame","FunctionEvaluationFromGame","externalEvaluationStackHeight","outputStreamLengthWithPushed","currentPointer","evaluationStackHeightWhenPushed","functionStartInOutputStream","canPop","CanPop","pop","currentElementIndex","contextElement","varValue","temporaryVariables","declareNew","RetainListOriginsForAssignment","filtered","isCurrent","pointer","inExpressionEvaluation","jThreadCallstack","jElTok","jElementObj","pushPopType","currentContainerPathStr","currentContainerPathStrToken","threadPointerResult","temps","JObjectToDictionaryRuntimeObjs","clear","prevContentObjPath","prevPath","previousPointer","PointerAtPath","WriteDictionaryRuntimeObjs","resolvedPointer","VariablesState","listDefsOrigin","_globalVariables","_callStack","_listDefsOrigin","Proxy","$","variableChangedEventCallbacks","callback","_batchObservingVariableChanges","_changedVariablesForBatchObs","variableChangedEvent","varContents","patch","TryGetGlobal","_defaultGlobalVariables","SetGlobal","globals","namedVarKey","namedVarValue","changedVariables","jToken","varValKey","varValValue","loadedToken","tokenInkObject","keyValKey","keyValValue","dontSaveDefaultValues","defaultVal","RuntimeObjectsEqual","obj1","obj2","constructor","GetRawVariableWithName","ValueAtVariablePointer","variableValue","GetTemporaryVariableWithName","GetVariableWithName","setGlobal","GlobalVariableExistsWithName","ResolveVariablePointer","existingPointer","SetTemporaryVariable","batchObservingVariableChanges","AddChangedVariable","GetContextIndexOfVariableNamed","doubleRedirectionPointer","PRNG","seed","next","StatePatch","_globals","_changedVariables","_visitCounts","_turnIndices","SimpleJson","Reader","ToDictionary","ToArray","_rootObject","Writer","StartNewObject","newObject","State","Property","currentCollection","currentPropertyName","propertyName","_propertyNameStack","_collectionStack","None","_jsonObject","_stateStack","StateElement","innerOrContent","IncrementChildCount","childCount","_currentPropertyName","PropertyName","_addToCurrentObject","error","POSITIVE_INFINITY","NEGATIVE_INFINITY","_currentString","currEl","Flow","SetJsonToken","outputStream","currentChoices","jChoiceThreadsObj","LoadFlowChoiceThreads","WriteListRuntimeObjs","hasChoiceThreads","threadAtGeneration","ThreadWithIndex","jChoiceThreads","foundActiveThread","jSavedChoiceThread","StoryState","_currentFlow","kDefaultFlowName","OutputStreamDirty","_evaluationStack","_variablesState","currentTurnIndex","timeSeed","Date","getTime","storySeed","previousRandom","GoToStart","indented","ToJson","json","TextToDictionary","LoadJsonObj","onDidLoadState","pathString","visitCountOut","_patch","TryGetVisitCount","containerPathStr","count2","currCount","VisitCountForContainer","SetVisitCount","SetTurnIndex","TryGetTurnIndex","index2","depth","canContinue","_currentErrors","_currentWarnings","_currentTurnIndex","hasError","currentErrors","currentWarnings","_outputStreamTextDirty","textContent","_currentText","CleanOutputWhitespace","currentWhitespaceStart","startOfLine","charAt","_outputStreamTagsDirty","_currentTags","mainContentContainer","flowName","_namedFlows","variablesState","SwitchFlow_Internal","SwitchToDefaultFlow_Internal","namedFlowKey","namedFlowValue","hasWarning","evaluationStack","divertedPointer","didSafeExit","ApplyPatch","visitCounts","ApplyCountChanges","turnIndices","newCount","isVisit","WriteIntDictionary","kInkSaveStateVersion","inkVersionCurrent","jSaveVersion","kMinCompatibleLoadVersion","flowsObj","flowsObjDict","keys","entries","currFlowName","currentDivertTargetPath","divertPath","JObjectToIntDictionary","objs","listText","TrySplittingHeadTailWhitespace","textObj","PushToOutputStreamIndividual","single","headFirstNewlineIdx","headLastNewlineIdx","tailLastNewlineIdx","tailFirstNewlineIdx","listTexts","innerStrStart","innerStrEnd","leadingSpaces","innerStrText","numSpaces","trailingSpaces","includeInOutput","TrimNewlinesFromOutputStream","functionTrimIndex","glueTrimIndex","o","isNonWhitespace","RemoveExistingGlue","callStackElements","outputStreamEndsInNewline","outputStreamContainsContent","removeWhitespaceFrom","txt","n","numberOfObjects","functionStartPoint","popType","TrimWhitespaceFromFunctionEnd","incrementingTurnIndex","newPointer","funcContainer","PassArgumentsToEvaluationStack","PushEvaluationStack","callStackTrace","originalEvaluationStackHeight","returnedObj","poppedObj","PopEvaluationStack","PopCallStack","returnVal","Stopwatch","startTime","nVal","isFinite","_mainContentContainer","jsonString","_listDefinitions","_externals","rootObject","versionObj","formatFromFile","inkVersionMinimumCompatible","listDefsObj","rootToken","JTokenToListDefinitions","ResetState","choices","_state","IfAsyncWeCant","currentText","currentTags","currentFlowName","shouldReturn","ObserveVariableChange","VariableStateDidChangeEvent","bind","ResetGlobals","ResetErrors","ForceEnd","originalPointer","ChoosePath","ContinueInternal","SnapshotDefaultGlobals","_asyncSaving","RemoveFlow_Internal","ContinueAsync","_asyncContinueActive","millisecsLimitAsync","_hasValidatedExternals","ValidateExternalBindings","_profiler","PreContinue","isAsyncTimeLimited","_recursiveContinueCount","ResetOutput","durationStopwatch","Start","_sawLookaheadUnsafeFunctionAfterNewline","ContinueSingleStep","AddError","ElapsedMilliseconds","Stop","_stateSnapshotAtLastNewline","RestoreStateSnapshot","generatedChoices","_temporaryEvaluationContainer","onDidContinue","PostContinue","onError","err","PreStep","Step","PostStep","TryFollowDefaultInvisibleChoice","PreSnapshot","inStringEvaluation","change","CalculateNewlineOutputStateChange","OutputStateChange","ExtendedBeyondNewline","NewlineRemoved","DiscardSnapshot","StateSnapshot","PostSnapshot","prevText","currText","prevTagCount","currTagCount","newlineStillExists","NoChange","Continue","pathLengthToUse","CopyAndStartPatching","RestoreAfterPatch","ApplyAnyPatch","stateToSave","shouldAddToStream","containerToEnter","VisitContainer","currentContentObj","isLogicOrFlowControl","PerformLogicAndFlowControl","ProcessChoice","contextIdx","ContextForVariableNamed","PushToOutputStream","NextContent","PushThread","atStart","IncrementVisitCountForContainer","RecordTurnIndexVisitToContainer","_prevContainers","prevAncestor","currentChildOfContainer","currentContainerAncestor","allChildrenEnteredAtStart","enteringAtStart","showChoice","conditionValue","IsTruthy","startText","choiceOnlyText","ForkThread","divTarget","currentDivert","intContent","errorMessage","CallExternalFunction","evalCommand","output","PeekEvaluationStack","overrideTunnelReturnTarget","popped","TryExitFunctionEvaluationFromGame","names","expected","contentStackForString","outputCountConsumed","command","PopFromOutputStream","choiceCount","extraNote","eitherCount","correctObj","TurnsSinceForContainer","maxInt","minInt","randomRange","resultSeed","nextRandom","chosenValue","shuffleIndex","NextSequenceShuffleIndex","PopThread","listNameVal","generatedListValue","foundItem","targetList","ListWithSubRange","listItemIndex","listEnumerator","randomItem","assignedVal","Assign","foundValue","containerForCount","func","funcParams","resetCallstack","onChoosePathString","ResetCallstack","funcDetail","activityStr","SetChosenPath","VisitChangedContainersDueToDivert","choiceIdx","choiceToChoose","onMakeChoice","KnotContainerWithName","returnTextOutput","onEvaluateFunction","trim","outputStreamBefore","StartFunctionEvaluationFromGame","stringOutput","textOutput","CompleteFunctionEvaluationFromGame","onCompleteEvaluateFunction","exprContainer","startCallStackHeight","evalStackHeight","funcName","numberOfArguments","funcDef","fallbackFunctionContainer","foundExternal","lookAheadSafe","allowExternalFunctionFallbacks","valueObj","funcResult","function","returnObj","lookaheadSafe","BindExternalFunctionGeneral","_this3","coercedArgs","TryCoerce","apply","missingExternals","from","fallbackFound","observer","_variableObservers","variableNames","observers","ObserveVariable","specificVariableName","variableObservers","newValueObj","TagsAtStartOfFlowContainerWithPathString","flowContainer","firstContent","tags","IncrementContentPointer","didPop","successfulIncrement","nextAncestor","indexInAncestor","allChoices","invisibleChoices","numElementsIntVal","seqContainer","numElements","seqCount","loopIndex","iterationIndex","seqPathStr","sequenceHash","randomSeed","random","unpickedIndices","chosen","chosenIndex","currentDebugMetadata","errorTypeStr","lineNum","toplevelObjects","isInclude","_errorHandler","constDecl","existingDefinition","constantName","runObj","_listDefs","variableInitialisation","runtimeLists","runtimeListDefinition","runtimeVarAss","runtimeStory","RuntimeStory","FlattenContainersIn","ItemNamed","originalFoundList","itemInThisList","innerContainers","innerContainer","namedInnerContainer","TryFlattenContainer","_dontFlattenContainers","parentContainer","ownDebugMetadata","Author","_hadError","_hadWarning","namedFuncTarget","decl","typeNameToPrint","typeNameOverride","IsReservedKeyword","maybeKnotOrFunction","knotOrFunction","NameConflictError","topLevelContent","flowsFromOtherFiles","file","posOfObj","nonFlowContent","subStory","subStoryObj","StringExpression","otherStr","isSingleString","InkParser","_filename","_externalErrorHandler","rootParser","_fileHandler","StatementsAtLevel","Top","_rootParser","mainRule","separatorRule","firstElement","Parse","allElements","nextElementRuleId","nextElement","stateAtStart","stateAtEnd","md","parsedObj","CreateDebugMetadata","parsedListObjs","parsedListObj","hasOwnDebugMetadata","warningType","fullMessage","Whitespace","IdentifierWithMetadata","identifierCharSet","ListAllCharacterRanges","charRange","ToCharacterSet","onceOnlyChoice","bullets","OptionalExclude","optionalName","BracketedName","conditionExpr","ChoiceCondition","_parsingChoice","startTextAndLogic","MixedTextAndLogic","optionOnlyContent","hasWeaveStyleInlineBrackets","optionOnlyTextAndLogic","Expect","innerTextAndLogic","diverts","MultiDivert","emptyContent","Tags","divObj","div","conditions","ChoiceSingleCondition","ChoiceConditionsSpace","Newline","condExpr","DisallowIncrement","gatherDashCountObj","GatherDashes","gatherDashCount","ParseDashNotArrow","ParseSingleCharacter","initialQueryExpression","ConditionExpression","InnerConditionalContent","alternatives","canBeInline","InlineConditionalBranches","MultilineConditionalBranches","soleContent","InnerBlock","elseBranch","SingleMultilineCondition","ErrorWithParsedObject","emptyTrueBranch","earlierBranchesHaveOwnExpression","isLast","alt","finalClause","Exclude","trueBranch","MultilineWhitespace","multipleConditions","OneOrMore","expr","ElseExpression","mixedTextAndLogicResults","terminateWithSpace","lastObjIdx","lastObj","TrimEndWhitespace","onlyTags","firstText","EndOfLine","SkipToNextLine","Spaced","ContentText","InlineLogicOrGlue","ContentTextAllowingEscapeChar","ContentTextNoEscape","gotEscapeChar","_nonTextPauseCharacters","_nonTextEndCharacters","_notTextEndCharactersChoice","_notTextEndCharactersString","endChars","parsingStringExpression","pureTextContent","ParseDivertArrow","ParseThreadArrow","threadDivert","arrowsAndDiverts","ParseDivertArrowOrTunnelOnwards","DivertIdentifierWithArguments","tunnelOnwards","tunnelOnwardDivert","gatherDivert","targetComponents","DotSeparatedDivertPathComponents","optionalArguments","ExpressionFunctionCallArguments","numArrows","ParseTempKeyword","isIncrement","isDecrement","minimumPrecedence","ExpressionUnary","infixOp","ParseInfixOperator","expectationMessage","multiaryExpr","ExpressionInfixRight","ExpressionDivertTarget","prefixOp","ExpressionNot","ExpressionList","ExpressionParen","ExpressionFunctionCall","ExpressionVariableName","ExpressionLiteral","WithInner","postfixOp","ExpressionFloat","ExpressionInt","ExpressionBool","ExpressionString","SingleDivert","intOrNull","floatOrNull","ParseFloat","textAndLogic","iden","commas","innerExpr","_binaryOperators","memberNames","SeparatedList","ListMember","identifier2","RegisterBinaryOperator","infix","_maxBinaryOpLength","filename","fullFilename","ResolveInkFilename","FilenameIsAlreadyOpen","AddOpenFilename","includedString","LoadInkFileContents","ParseStory","RemoveOpenFilename","_openFilenames","knotDecl","KnotDeclaration","KnotStitchNoContentRecoveryRule","KnotTitleEquals","knotName","isFunc","parameterNames","BracketedKnotDeclArguments","multiEquals","StitchDeclaration","flowArgs","flowArguments","FlowDeclArgument","firstIden","divertArrow","secondIden","funcIdentifier","argNames","ReturnStatement","TempDeclarationOrAssignment","funCall","ListElementDefinitionSeparator","AnyWhitespace","needsToCloseParen","elementValue","elementValueNum","InlineLogic","RuntimeGlue","logic","InnerLogic","explicitSeqType","SequenceTypeAnnotation","contentLists","InnerSequenceObjects","InnerSequence","InnerExpression","isNumberCharsOnly","seqType","parsedSeqType","annotation","SequenceTypeSymbolAnnotation","SequenceTypeWordAnnotation","_sequenceTypeSymbols","sequenceAnnotations","sequenceTypes","SequenceTypeSingleWord","combinedSequenceType","word","InnerMultilineSequenceObjects","InnerInlineSequenceObjects","interleavedContentAndPipes","justHadContent","contentOrPipe","SingleMultilineSequenceElement","StatementAtLevel","StatementsBreakForLevel","rulesAtLevel","_statementRulesAtLevel","statement","breakRules","_statementBreakRulesAtLevel","breakRuleResult","levels","breakingRules","Line","KnotDefinition","StitchDefinition","ListDeclaration","VariableDeclaration","ConstDeclaration","IncludeStatement","LogicLine","LineOfMixedTextAndLogic","inlineRule","_endOfTagCharSet","fullTagText","RuntimeTag","EndOfFile","newlines","_inlineWhitespaceChars","anyWhitespace","RegisterExpressionOperators","GenerateStatementLevelRules","OnStringParserError","fullRootInkPath","Process","GetFlag","ParsingString","SetFlag","_identifierCharSet","ExtendIdentifierCharacterRanges","Define","LatinBasic","LatinExtendedA","LatinExtendedB","Arabic","Armenian","Cyrillic","Greek","Hebrew","Korean","Compiler","inkSource","options","_parser","OnError","_parsedStory","parser","errors","parsedStory","_runtimeStory","ExportRuntime","range","debugSourceRanges","offset","currOffset","lastValidMetadata","_authorMessages","_warnings","_errors","_inputString","_options","_debugSourceRanges"],"mappings":"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"}